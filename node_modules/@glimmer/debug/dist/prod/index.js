import{Op as n}from"@glimmer/vm";function e(n,e){return null}function r(n,e,r){}function t(n,e){}function o(n,e,r){}new Array(n.Size).fill(null),new Array(n.Size).fill(null);const i=["u32","i32","owner","handle","str","option-str","array","str-array","bool","primitive","register","unknown","symbol-table","scope"];function u(n,e){let r;if(void 0===e.format)throw new Error(`Missing format in ${JSON.stringify(e)}`);r=Array.isArray(e.format)?e.format[0]:e.format;let t=Array.isArray(e.format)?function(n){if(!Array.isArray(n))throw new Error(`Expected operands array, got ${JSON.stringify(n)}`);return n.map(l)}(e.format.slice(1)):[];return{name:r,mnemonic:n,before:null,stackChange:f(e["operand-stack"]),ops:t,operands:t.length,check:!0!==e.skip}}function f(n){if(void 0===n)return 0;let e=n[0],r=n[1];return c(e)||c(r)?null:r.length-e.length}function c(n){if(!Array.isArray(n))throw new Error(`Unexpected stack entry: ${JSON.stringify(n)}`);return n.some((n=>"..."===n.slice(-3)))}function l(n){let[e,r]=n.split(":");if(t=r,-1!==i.indexOf(t))return{name:e,type:r};throw new Error(`Expected operand, found ${JSON.stringify(n)}`);var t}function a(n){return{machine:s(n.machine),syscall:s(n.syscall)}}function s(n){let e=Object.create(null);for(const[r,t]of Object.entries(n))e[r]=u(r,t);return e}function p(n,e,r,t){let o,i=[`export enum ${n} {`];Object.values(e).forEach(((n,e)=>{i.push(`  ${n.name} = ${r+e},`),o=e})),i.push(`  Size = ${o+r+1},`),i.push("}");let u,f=i.join("\n");return u=t?w`
      export function is${n}(value: number): value is ${n} {
        return value >= ${r} && value <= ${t};
      }
    `:w`
      export function is${n}(value: number): value is ${n} {
        return value >= ${r};
      }
    `,{enumString:f,predicate:u}}function w(n,...e){let r="";for(let t=0;t<n.length;t++)r+=`${n[t]}${void 0!==e[t]?String(e[t]):""}`;r=/^\s*?\n?([\s\S]*?)\s*$/u.exec(r)[1];let t=Number.MAX_SAFE_INTEGER;for(let n of r.split("\n")){let e=/^\s*/u.exec(n)[0].length;t=Math.min(t,e)}let o="";for(let n of r.split("\n"))o+=n.slice(t)+"\n";return o}const m=["METADATA","MACHINE_METADATA"];function $(n,e,r){return`${n}[${"MACHINE_METADATA"===n?"MachineOp":"Op"}.${e[r].name}] = ${y(e[r],0)};`}function y(n,e){if("object"!=typeof n||null===n)return"string"==typeof n?`'${n}'`:JSON.stringify(n);if(Array.isArray(n))return`[${n.map((n=>y(n,e))).join(", ")}]`;let r=["{"];for(let t of Object.keys(n))r.push(`${" ".repeat(e+2)}${t}: ${y(n[t],e+2)},`);return r.push(`${" ".repeat(e)}}`),r.join("\n")}function A(n,e){let r=[];for(let t of Object.keys(e))r.push($(n,e,t));return r.join("\n\n")}class h{validate(n){return!0}expected(){return"<noop>"}}function g(n){return new h}function d(n){return new h}function v(n){return new h}function E(n){return new h}function b(n){return new h}function O(n){return new h}function x(n){return new h}function S(n,e){return`Got ${n}, expected:\n${e}`}function j(n,e,r=S){return n}function M(n){}const N=new h,k=new h,T=new h,J=new h,_=new h,z=new h,C=new h,D=new h,I=new h,G=new h;function H(n,e){return new h}const F=new h,R=new h,U=new h,X=new h,q=new h;export{O as CheckArray,F as CheckBlockSymbolTable,J as CheckBoolean,x as CheckDict,X as CheckDocumentFragment,U as CheckElement,k as CheckFunction,_ as CheckHandle,d as CheckInstanceof,b as CheckInterface,E as CheckMaybe,q as CheckNode,T as CheckNumber,G as CheckObject,v as CheckOption,H as CheckOr,N as CheckPrimitive,R as CheckProgramSymbolTable,I as CheckSafeString,z as CheckString,C as CheckUndefined,D as CheckUnknown,m as META_KIND,i as OPERAND_TYPES,p as buildEnum,A as buildMetas,$ as buildSingleMeta,j as check,o as debug,r as debugSlice,t as logOpcode,u as normalize,a as normalizeAll,s as normalizeParsed,e as opcodeMetadata,M as recordStackSize,w as strip,g as wrap};
//# sourceMappingURL=index.js.map
