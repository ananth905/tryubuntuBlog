{"version":3,"file":"index.js","sources":["../../lib/opcode-metadata.ts","../../lib/debug.ts","../../lib/metadata.ts","../../lib/stack-check.ts"],"sourcesContent":["/* This file is generated by build/debug.js */\n\nimport type { Nullable, VmMachineOp, VmOp } from '@glimmer/interfaces';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { MachineOp, Op } from '@glimmer/vm';\n\nimport type { NormalizedMetadata } from './metadata';\n\nexport function opcodeMetadata(\n  op: VmMachineOp | VmOp,\n  isMachine: 0 | 1\n): Nullable<NormalizedMetadata> {\n  if (!LOCAL_DEBUG) {\n    return null;\n  }\n\n  let value = isMachine ? MACHINE_METADATA[op] : METADATA[op];\n\n  return value || null;\n}\n\nconst METADATA: Nullable<NormalizedMetadata>[] = new Array(Op.Size).fill(null);\nconst MACHINE_METADATA: Nullable<NormalizedMetadata>[] = new Array(Op.Size).fill(null);\n\nif (LOCAL_DEBUG) {\n  MACHINE_METADATA[MachineOp.PushFrame] = {\n    name: 'PushFrame',\n    mnemonic: 'pushf',\n    before: null,\n    stackChange: 2,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.PopFrame] = {\n    name: 'PopFrame',\n    mnemonic: 'popf',\n    before: null,\n    stackChange: -2,\n    ops: [],\n    operands: 0,\n    check: false,\n  };\n\n  MACHINE_METADATA[MachineOp.InvokeVirtual] = {\n    name: 'InvokeVirtual',\n    mnemonic: 'vcall',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.InvokeStatic] = {\n    name: 'InvokeStatic',\n    mnemonic: 'scall',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'offset',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.Jump] = {\n    name: 'Jump',\n    mnemonic: 'goto',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'to',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.Return] = {\n    name: 'Return',\n    mnemonic: 'ret',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: false,\n  };\n\n  MACHINE_METADATA[MachineOp.ReturnTo] = {\n    name: 'ReturnTo',\n    mnemonic: 'setra',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'offset',\n        type: 'i32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n  METADATA[Op.Helper] = {\n    name: 'Helper',\n    mnemonic: 'ncall',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'helper',\n        type: 'handle',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.DynamicHelper] = {\n    name: 'DynamicHelper',\n    mnemonic: 'dynamiccall',\n    before: null,\n    stackChange: null,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.SetNamedVariables] = {\n    name: 'SetNamedVariables',\n    mnemonic: 'vsargs',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetBlocks] = {\n    name: 'SetBlocks',\n    mnemonic: 'vbblocks',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetVariable] = {\n    name: 'SetVariable',\n    mnemonic: 'sbvar',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'symbol',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetBlock] = {\n    name: 'SetBlock',\n    mnemonic: 'sblock',\n    before: null,\n    stackChange: -3,\n    ops: [\n      {\n        name: 'symbol',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetVariable] = {\n    name: 'GetVariable',\n    mnemonic: 'symload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'symbol',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetProperty] = {\n    name: 'GetProperty',\n    mnemonic: 'getprop',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'property',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetBlock] = {\n    name: 'GetBlock',\n    mnemonic: 'blockload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'block',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SpreadBlock] = {\n    name: 'SpreadBlock',\n    mnemonic: 'blockspread',\n    before: null,\n    stackChange: 2,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.HasBlock] = {\n    name: 'HasBlock',\n    mnemonic: 'hasblockload',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.HasBlockParams] = {\n    name: 'HasBlockParams',\n    mnemonic: 'hasparamsload',\n    before: null,\n    stackChange: -2,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Concat] = {\n    name: 'Concat',\n    mnemonic: 'concat',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.IfInline] = {\n    name: 'IfInline',\n    mnemonic: 'ifinline',\n    before: null,\n    stackChange: -2,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Not] = {\n    name: 'Not',\n    mnemonic: 'not',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Constant] = {\n    name: 'Constant',\n    mnemonic: 'rconstload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'constant',\n        type: 'unknown',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ConstantReference] = {\n    name: 'ConstantReference',\n    mnemonic: 'rconstrefload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'constant',\n        type: 'unknown',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Primitive] = {\n    name: 'Primitive',\n    mnemonic: 'pconstload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'constant',\n        type: 'primitive',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PrimitiveReference] = {\n    name: 'PrimitiveReference',\n    mnemonic: 'ptoref',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.ReifyU32] = {\n    name: 'ReifyU32',\n    mnemonic: 'reifyload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Dup] = {\n    name: 'Dup',\n    mnemonic: 'dup',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n      {\n        name: 'offset',\n        type: 'u32',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.Pop] = {\n    name: 'Pop',\n    mnemonic: 'pop',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: false,\n  };\n\n  METADATA[Op.Load] = {\n    name: 'Load',\n    mnemonic: 'put',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Fetch] = {\n    name: 'Fetch',\n    mnemonic: 'regload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.RootScope] = {\n    name: 'RootScope',\n    mnemonic: 'rscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'symbols',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.VirtualRootScope] = {\n    name: 'VirtualRootScope',\n    mnemonic: 'vrscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ChildScope] = {\n    name: 'ChildScope',\n    mnemonic: 'cscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopScope] = {\n    name: 'PopScope',\n    mnemonic: 'scopepop',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Text] = {\n    name: 'Text',\n    mnemonic: 'apnd_text',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'contents',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Comment] = {\n    name: 'Comment',\n    mnemonic: 'apnd_comment',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'contents',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.AppendHTML] = {\n    name: 'AppendHTML',\n    mnemonic: 'apnd_dynhtml',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendSafeHTML] = {\n    name: 'AppendSafeHTML',\n    mnemonic: 'apnd_dynshtml',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendDocumentFragment] = {\n    name: 'AppendDocumentFragment',\n    mnemonic: 'apnd_dynfrag',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendNode] = {\n    name: 'AppendNode',\n    mnemonic: 'apnd_dynnode',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendText] = {\n    name: 'AppendText',\n    mnemonic: 'apnd_dyntext',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.OpenElement] = {\n    name: 'OpenElement',\n    mnemonic: 'apnd_tag',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'tag',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.OpenDynamicElement] = {\n    name: 'OpenDynamicElement',\n    mnemonic: 'apnd_dyntag',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PushRemoteElement] = {\n    name: 'PushRemoteElement',\n    mnemonic: 'apnd_remotetag',\n    before: null,\n    stackChange: -3,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.StaticAttr] = {\n    name: 'StaticAttr',\n    mnemonic: 'apnd_attr',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'name',\n        type: 'str',\n      },\n      {\n        name: 'value',\n        type: 'str',\n      },\n      {\n        name: 'namespace',\n        type: 'option-str',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.DynamicAttr] = {\n    name: 'DynamicAttr',\n    mnemonic: 'apnd_dynattr',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'name',\n        type: 'str',\n      },\n      {\n        name: 'trusting',\n        type: 'bool',\n      },\n      {\n        name: 'namespace',\n        type: 'option-str',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.ComponentAttr] = {\n    name: 'ComponentAttr',\n    mnemonic: 'apnd_cattr',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'name',\n        type: 'str',\n      },\n      {\n        name: 'trusting',\n        type: 'bool',\n      },\n      {\n        name: 'namespace',\n        type: 'option-str',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.FlushElement] = {\n    name: 'FlushElement',\n    mnemonic: 'apnd_flushtag',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CloseElement] = {\n    name: 'CloseElement',\n    mnemonic: 'apnd_closetag',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopRemoteElement] = {\n    name: 'PopRemoteElement',\n    mnemonic: 'apnd_closeremotetag',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Modifier] = {\n    name: 'Modifier',\n    mnemonic: 'apnd_modifier',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'helper',\n        type: 'handle',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.BindDynamicScope] = {\n    name: 'BindDynamicScope',\n    mnemonic: 'setdynscope',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'names',\n        type: 'str-array',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushDynamicScope] = {\n    name: 'PushDynamicScope',\n    mnemonic: 'dynscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopDynamicScope] = {\n    name: 'PopDynamicScope',\n    mnemonic: 'dynscopepop',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CompileBlock] = {\n    name: 'CompileBlock',\n    mnemonic: 'cmpblock',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PushBlockScope] = {\n    name: 'PushBlockScope',\n    mnemonic: 'scopeload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'scope',\n        type: 'scope',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushSymbolTable] = {\n    name: 'PushSymbolTable',\n    mnemonic: 'dsymload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'table',\n        type: 'symbol-table',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.InvokeYield] = {\n    name: 'InvokeYield',\n    mnemonic: 'invokeyield',\n    before: null,\n    stackChange: null,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.JumpIf] = {\n    name: 'JumpIf',\n    mnemonic: 'iftrue',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'to',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.JumpUnless] = {\n    name: 'JumpUnless',\n    mnemonic: 'iffalse',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'to',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.JumpEq] = {\n    name: 'JumpEq',\n    mnemonic: 'ifeq',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'to',\n        type: 'i32',\n      },\n      {\n        name: 'comparison',\n        type: 'i32',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.AssertSame] = {\n    name: 'AssertSame',\n    mnemonic: 'assert_eq',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Enter] = {\n    name: 'Enter',\n    mnemonic: 'blk_start',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'args',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Exit] = {\n    name: 'Exit',\n    mnemonic: 'blk_end',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.ToBoolean] = {\n    name: 'ToBoolean',\n    mnemonic: 'anytobool',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.EnterList] = {\n    name: 'EnterList',\n    mnemonic: 'list_start',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'address',\n        type: 'u32',\n      },\n      {\n        name: 'address',\n        type: 'u32',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.ExitList] = {\n    name: 'ExitList',\n    mnemonic: 'list_end',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Iterate] = {\n    name: 'Iterate',\n    mnemonic: 'iter',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'end',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: false,\n  };\n\n  METADATA[Op.Main] = {\n    name: 'Main',\n    mnemonic: 'main',\n    before: null,\n    stackChange: -2,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ContentType] = {\n    name: 'ContentType',\n    mnemonic: 'ctload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.DynamicContentType] = {\n    name: 'DynamicContentType',\n    mnemonic: 'dctload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Curry] = {\n    name: 'Curry',\n    mnemonic: 'curry',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'type',\n        type: 'u32',\n      },\n      {\n        name: 'is-strict',\n        type: 'bool',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.PushComponentDefinition] = {\n    name: 'PushComponentDefinition',\n    mnemonic: 'cmload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'spec',\n        type: 'handle',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushDynamicComponentInstance] = {\n    name: 'PushDynamicComponentInstance',\n    mnemonic: 'dciload',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.ResolveDynamicComponent] = {\n    name: 'ResolveDynamicComponent',\n    mnemonic: 'cdload',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'owner',\n        type: 'owner',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushArgs] = {\n    name: 'PushArgs',\n    mnemonic: 'argsload',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'names',\n        type: 'str-array',\n      },\n      {\n        name: 'block-names',\n        type: 'str-array',\n      },\n      {\n        name: 'flags',\n        type: 'u32',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.PushEmptyArgs] = {\n    name: 'PushEmptyArgs',\n    mnemonic: 'emptyargsload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopArgs] = {\n    name: 'PopArgs',\n    mnemonic: 'argspop',\n    before: null,\n    stackChange: null,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PrepareArgs] = {\n    name: 'PrepareArgs',\n    mnemonic: 'argsprep',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: false,\n  };\n\n  METADATA[Op.CaptureArgs] = {\n    name: 'CaptureArgs',\n    mnemonic: 'argscapture',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CreateComponent] = {\n    name: 'CreateComponent',\n    mnemonic: 'comp_create',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'flags',\n        type: 'u32',\n      },\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.RegisterComponentDestructor] = {\n    name: 'RegisterComponentDestructor',\n    mnemonic: 'comp_dest',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PutComponentOperations] = {\n    name: 'PutComponentOperations',\n    mnemonic: 'comp_elops',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.GetComponentSelf] = {\n    name: 'GetComponentSelf',\n    mnemonic: 'comp_selfload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetComponentTagName] = {\n    name: 'GetComponentTagName',\n    mnemonic: 'comp_tagload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetComponentLayout] = {\n    name: 'GetComponentLayout',\n    mnemonic: 'comp_layoutload',\n    before: null,\n    stackChange: 2,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.BindEvalScope] = {\n    name: 'BindEvalScope',\n    mnemonic: 'eval_scope',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetupForEval] = {\n    name: 'SetupForEval',\n    mnemonic: 'eval_setup',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PopulateLayout] = {\n    name: 'PopulateLayout',\n    mnemonic: 'comp_layoutput',\n    before: null,\n    stackChange: -2,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.InvokeComponentLayout] = {\n    name: 'InvokeComponentLayout',\n    mnemonic: 'comp_invokelayout',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.BeginComponentTransaction] = {\n    name: 'BeginComponentTransaction',\n    mnemonic: 'comp_begin',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CommitComponentTransaction] = {\n    name: 'CommitComponentTransaction',\n    mnemonic: 'comp_commit',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.DidCreateElement] = {\n    name: 'DidCreateElement',\n    mnemonic: 'comp_created',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.DidRenderLayout] = {\n    name: 'DidRenderLayout',\n    mnemonic: 'comp_rendered',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ResolveMaybeLocal] = {\n    name: 'ResolveMaybeLocal',\n    mnemonic: 'eval_varload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'local',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Debugger] = {\n    name: 'Debugger',\n    mnemonic: 'debugger',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'symbols',\n        type: 'str-array',\n      },\n      {\n        name: 'debugInfo',\n        type: 'array',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n}\n","import type {\n  CompileTimeConstants,\n  Dict,\n  Maybe,\n  Recast,\n  ResolutionTimeConstants,\n  RuntimeOp,\n  TemplateCompilationContext,\n} from '@glimmer/interfaces';\nimport type { Register } from '@glimmer/vm';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { decodeHandle, decodeImmediate, enumerate, LOCAL_LOGGER } from '@glimmer/util';\nimport { $fp, $pc, $ra, $s0, $s1, $sp, $t0, $t1, $v0 } from '@glimmer/vm';\n\nimport type { Primitive } from './stack-check';\n\nimport { opcodeMetadata } from './opcode-metadata';\n\nexport interface DebugConstants {\n  getValue<T>(handle: number): T;\n  getArray<T>(value: number): T[];\n}\n\nexport function debugSlice(context: TemplateCompilationContext, start: number, end: number) {\n  if (LOCAL_SHOULD_LOG) {\n    LOCAL_LOGGER.group(`%c${start}:${end}`, 'color: #999');\n\n    let heap = context.program.heap;\n    let opcode = context.program.createOp(heap);\n\n    let _size = 0;\n    for (let i = start; i < end; i = i + _size) {\n      opcode.offset = i;\n      let [name, params] = debug(\n        context.program.constants as Recast<\n          CompileTimeConstants & ResolutionTimeConstants,\n          DebugConstants\n        >,\n        opcode,\n        opcode.isMachine\n      )!;\n      LOCAL_LOGGER.log(`${i}. ${logOpcode(name, params)}`);\n      _size = opcode.size;\n    }\n    opcode.offset = -_size;\n    LOCAL_LOGGER.groupEnd();\n  }\n}\n\nexport function logOpcode(type: string, params: Maybe<Dict>): string | void {\n  if (LOCAL_SHOULD_LOG) {\n    let out = type;\n\n    if (params) {\n      let args = Object.keys(params)\n        .map((p) => ` ${p}=${json(params[p])}`)\n        .join('');\n      out += args;\n    }\n    return `(${out})`;\n  }\n}\n\nfunction json(param: unknown) {\n  if (LOCAL_SHOULD_LOG) {\n    if (typeof param === 'function') {\n      return '<function>';\n    }\n\n    let string;\n    try {\n      string = JSON.stringify(param);\n    } catch (e) {\n      return '<object>';\n    }\n\n    if (string === undefined) {\n      return 'undefined';\n    }\n\n    let debug = JSON.parse(string);\n    if (typeof debug === 'object' && debug !== null && debug.GlimmerDebug !== undefined) {\n      return debug.GlimmerDebug;\n    }\n\n    return string;\n  }\n}\n\nexport function debug(\n  c: DebugConstants,\n  op: RuntimeOp,\n  isMachine: 0 | 1\n): [string, Dict] | undefined {\n  if (LOCAL_SHOULD_LOG) {\n    let metadata = opcodeMetadata(op.type, isMachine);\n\n    if (!metadata) {\n      throw new Error(`Missing Opcode Metadata for ${op}`);\n    }\n\n    let out = Object.create(null);\n\n    for (const [index, operand] of enumerate(metadata.ops)) {\n      let actualOperand = opcodeOperand(op, index);\n\n      switch (operand.type) {\n        case 'u32':\n        case 'i32':\n        case 'owner':\n          out[operand.name] = actualOperand;\n          break;\n        case 'handle':\n          out[operand.name] = c.getValue(actualOperand);\n          break;\n        case 'str':\n        case 'option-str':\n        case 'array':\n          out[operand.name] = c.getValue(actualOperand);\n          break;\n        case 'str-array':\n          out[operand.name] = c.getArray(actualOperand);\n          break;\n        case 'bool':\n          out[operand.name] = !!actualOperand;\n          break;\n        case 'primitive':\n          out[operand.name] = decodePrimitive(actualOperand, c);\n          break;\n        case 'register':\n          out[operand.name] = decodeRegister(actualOperand);\n          break;\n        case 'unknown':\n          out[operand.name] = c.getValue(actualOperand);\n          break;\n        case 'symbol-table':\n        case 'scope':\n          out[operand.name] = `<scope ${actualOperand}>`;\n          break;\n        default:\n          throw new Error(`Unexpected operand type ${operand.type} for debug output`);\n      }\n    }\n\n    return [metadata.name, out];\n  }\n\n  return undefined;\n}\n\nfunction opcodeOperand(opcode: RuntimeOp, index: number): number {\n  switch (index) {\n    case 0:\n      return opcode.op1;\n    case 1:\n      return opcode.op2;\n    case 2:\n      return opcode.op3;\n    default:\n      throw new Error(`Unexpected operand index (must be 0-2)`);\n  }\n}\n\nfunction decodeRegister(register: Register): string {\n  switch (register) {\n    case $pc:\n      return 'pc';\n    case $ra:\n      return 'ra';\n    case $fp:\n      return 'fp';\n    case $sp:\n      return 'sp';\n    case $s0:\n      return 's0';\n    case $s1:\n      return 's1';\n    case $t0:\n      return 't0';\n    case $t1:\n      return 't1';\n    case $v0:\n      return 'v0';\n  }\n}\n\nfunction decodePrimitive(primitive: number, constants: DebugConstants): Primitive {\n  if (primitive >= 0) {\n    return constants.getValue(decodeHandle(primitive));\n  }\n  return decodeImmediate(primitive);\n}\n","import type { Dict, Nullable, PresentArray } from '@glimmer/interfaces';\n\n// TODO: How do these map onto constant and machine types?\nexport const OPERAND_TYPES = [\n  'u32',\n  'i32',\n  'owner',\n  'handle',\n  'str',\n  'option-str',\n  'array',\n  'str-array',\n  'bool',\n  'primitive',\n  'register',\n  'unknown',\n  'symbol-table',\n  'scope',\n];\n\nfunction isOperandType(s: string): s is OperandType {\n  return OPERAND_TYPES.indexOf(s as any) !== -1;\n}\n\nexport type OperandType = (typeof OPERAND_TYPES)[number];\n\nexport interface Operand {\n  type: OperandType;\n  name: string;\n}\n\nexport type OperandList = ([] | [Operand] | [Operand, Operand] | [Operand, Operand, Operand]) &\n  Operand[];\n\nexport interface NormalizedMetadata {\n  name: string;\n  mnemonic: string;\n  before: null;\n  stackChange: Nullable<number>;\n  ops: OperandList;\n  operands: number;\n  check: boolean;\n}\n\nexport type Stack = [string[], string[]];\n\nexport interface RawOperandMetadata {\n  kind: 'machine' | 'syscall';\n  format: RawOperandFormat;\n  skip?: true;\n  operation: string;\n  'operand-stack'?: [string[], string[]];\n  notes?: string;\n}\n\nexport type OperandName = `${string}:${string}`;\nexport type RawOperandFormat = OperandName | PresentArray<OperandName>;\n\nexport function normalize(key: string, input: RawOperandMetadata): NormalizedMetadata {\n  let name: string;\n\n  if (input.format === undefined) {\n    throw new Error(`Missing format in ${JSON.stringify(input)}`);\n  }\n\n  if (Array.isArray(input.format)) {\n    name = input.format[0];\n  } else {\n    name = input.format;\n  }\n\n  let ops: OperandList = Array.isArray(input.format) ? operands(input.format.slice(1)) : [];\n\n  return {\n    name,\n    mnemonic: key,\n    before: null,\n    stackChange: stackChange(input['operand-stack']),\n    ops,\n    operands: ops.length,\n    check: input.skip === true ? false : true,\n  };\n}\n\nfunction stackChange(stack?: Stack): Nullable<number> {\n  if (stack === undefined) {\n    return 0;\n  }\n\n  let before = stack[0];\n  let after = stack[1];\n\n  if (hasRest(before) || hasRest(after)) {\n    return null;\n  }\n\n  return after.length - before.length;\n}\n\nfunction hasRest(input: string[]): boolean {\n  if (!Array.isArray(input)) {\n    throw new Error(`Unexpected stack entry: ${JSON.stringify(input)}`);\n  }\n  return input.some((s) => s.slice(-3) === '...');\n}\n\nfunction operands(input: `${string}:${string}`[]): OperandList {\n  if (!Array.isArray(input)) {\n    throw new Error(`Expected operands array, got ${JSON.stringify(input)}`);\n  }\n  return input.map(op) as OperandList;\n}\n\nfunction op(input: `${string}:${string}`): Operand {\n  let [name, type] = input.split(':') as [string, string];\n\n  if (isOperandType(type)) {\n    return { name, type };\n  } else {\n    throw new Error(`Expected operand, found ${JSON.stringify(input)}`);\n  }\n}\n\nexport interface NormalizedOpcodes {\n  readonly machine: Dict<NormalizedMetadata>;\n  readonly syscall: Dict<NormalizedMetadata>;\n}\n\nexport function normalizeAll(parsed: {\n  machine: Dict<RawOperandMetadata>;\n  syscall: Dict<RawOperandMetadata>;\n}): NormalizedOpcodes {\n  let machine = normalizeParsed(parsed.machine);\n  let syscall = normalizeParsed(parsed.syscall);\n\n  return { machine, syscall };\n}\n\nexport function normalizeParsed(parsed: Dict<RawOperandMetadata>): Dict<NormalizedMetadata> {\n  let out = Object.create(null) as Dict<NormalizedMetadata>;\n\n  for (const [key, value] of Object.entries(parsed)) {\n    out[key] = normalize(key, value);\n  }\n\n  return out;\n}\n\nexport function buildEnum(\n  name: string,\n  parsed: Dict<NormalizedMetadata>,\n  offset: number,\n  max?: number\n): { enumString: string; predicate: string } {\n  let e = [`export enum ${name} {`];\n\n  let last: number;\n\n  Object.values(parsed).forEach((value, i) => {\n    e.push(`  ${value.name} = ${offset + i},`);\n    last = i;\n  });\n\n  e.push(`  Size = ${last! + offset + 1},`);\n  e.push('}');\n\n  let enumString = e.join('\\n');\n\n  let predicate;\n\n  if (max) {\n    predicate = strip`\n      export function is${name}(value: number): value is ${name} {\n        return value >= ${offset} && value <= ${max};\n      }\n    `;\n  } else {\n    predicate = strip`\n      export function is${name}(value: number): value is ${name} {\n        return value >= ${offset};\n      }\n    `;\n  }\n\n  return { enumString, predicate };\n}\n\nexport function strip(strings: TemplateStringsArray, ...args: unknown[]) {\n  let out = '';\n  for (let i = 0; i < strings.length; i++) {\n    let string = strings[i];\n    let dynamic = args[i] !== undefined ? String(args[i]) : '';\n\n    out += `${string}${dynamic}`;\n  }\n\n  // eslint-disable-next-line regexp/no-super-linear-backtracking\n  out = /^\\s*?\\n?([\\s\\S]*?)\\s*$/u.exec(out)![1] as string;\n\n  let min = Number.MAX_SAFE_INTEGER;\n\n  for (let line of out.split('\\n')) {\n    let leading = /^\\s*/u.exec(line)![0].length;\n\n    min = Math.min(min, leading);\n  }\n\n  let stripped = '';\n\n  for (let line of out.split('\\n')) {\n    stripped += line.slice(min) + '\\n';\n  }\n\n  return stripped;\n}\n\nexport const META_KIND = ['METADATA', 'MACHINE_METADATA'];\nexport type META_KIND = (typeof META_KIND)[number];\n\nexport function buildSingleMeta<D extends Dict<NormalizedMetadata>>(\n  kind: META_KIND,\n  all: D,\n  key: keyof D\n): string {\n  let e = kind === 'MACHINE_METADATA' ? 'MachineOp' : 'Op';\n  return `${kind}[${e}.${all[key]!.name}] = ${stringify(all[key], 0)};`;\n}\n\nfunction stringify(o: unknown, pad: number): string {\n  if (typeof o !== 'object' || o === null) {\n    if (typeof o === 'string') {\n      return `'${o}'`;\n    }\n    return JSON.stringify(o);\n  }\n\n  if (Array.isArray(o)) {\n    return `[${o.map((v) => stringify(v, pad)).join(', ')}]`;\n  }\n\n  let out = ['{'];\n\n  for (let key of Object.keys(o)) {\n    out.push(`${' '.repeat(pad + 2)}${key}: ${stringify((o as Dict)[key], pad + 2)},`);\n  }\n\n  out.push(`${' '.repeat(pad)}}`);\n\n  return out.join('\\n');\n}\n\nexport function buildMetas(kind: META_KIND, all: Dict<NormalizedMetadata>): string {\n  let out = [];\n\n  for (let key of Object.keys(all)) {\n    out.push(buildSingleMeta(kind, all, key));\n  }\n\n  return out.join('\\n\\n');\n}\n","import type {\n  BlockSymbolTable,\n  Dict,\n  Maybe,\n  Nullable,\n  ProgramSymbolTable,\n  SimpleDocumentFragment,\n  SimpleElement,\n  SimpleNode,\n} from '@glimmer/interfaces';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\n\nexport interface Checker<T> {\n  type: T;\n\n  validate(value: unknown): value is T;\n  expected(): string;\n}\n\nclass NoopChecker<T> implements Checker<T> {\n  declare type: T;\n  validate(value: unknown): value is T {\n    return true;\n  }\n  expected(): string {\n    return '<noop>';\n  }\n}\n\nexport function wrap<T>(checker: () => Checker<T>): Checker<T> {\n  if (!LOCAL_DEBUG) {\n    return new NoopChecker<T>();\n  }\n\n  class Wrapped {\n    declare type: T;\n\n    validate(value: unknown): value is T {\n      return checker().validate(value);\n    }\n\n    expected(): string {\n      return checker().expected();\n    }\n  }\n\n  return new Wrapped();\n}\n\nexport interface Constructor<T> extends Function {\n  prototype: T;\n}\n\nclass TypeofChecker<T> implements Checker<T> {\n  declare type: T;\n\n  constructor(private expectedType: string) {}\n\n  validate(value: unknown): value is T {\n    return typeof value === this.expectedType;\n  }\n\n  expected(): string {\n    return `typeof ${this.expectedType}`;\n  }\n}\n\nexport type Primitive = undefined | null | boolean | number | string;\n\nclass PrimitiveChecker implements Checker<Primitive> {\n  declare type: Primitive;\n\n  validate(value: unknown): value is Primitive {\n    return (\n      typeof value !== 'string' ||\n      typeof value === 'number' ||\n      typeof value === 'string' ||\n      value === undefined ||\n      value === null\n    );\n  }\n\n  expected(): string {\n    return `a primitive`;\n  }\n}\n\nclass NullChecker implements Checker<null> {\n  declare type: null;\n\n  validate(value: unknown): value is null {\n    return value === null;\n  }\n\n  expected(): string {\n    return `null`;\n  }\n}\n\nclass UndefinedChecker implements Checker<undefined> {\n  declare type: undefined;\n\n  validate(value: unknown): value is undefined {\n    return value === undefined;\n  }\n\n  expected(): string {\n    return `undefined`;\n  }\n}\n\nclass InstanceofChecker<T> implements Checker<T> {\n  declare type: T;\n\n  constructor(private Class: Constructor<T>) {}\n\n  validate(value: unknown): value is T {\n    return value ? value instanceof this.Class : false;\n  }\n\n  expected(): string {\n    return `an instance of ${this.Class.name}`;\n  }\n}\n\nclass OptionChecker<T> implements Checker<Nullable<T>> {\n  declare type: Nullable<T>;\n\n  constructor(\n    private checker: Checker<T>,\n    private emptyValue: null | undefined\n  ) {}\n\n  validate(value: unknown): value is Nullable<T> {\n    if (value === this.emptyValue) return true;\n    return this.checker.validate(value);\n  }\n\n  expected(): string {\n    return `${this.checker.expected()} or null`;\n  }\n}\n\nclass MaybeChecker<T> implements Checker<Maybe<T>> {\n  declare type: Maybe<T>;\n\n  constructor(private checker: Checker<T>) {}\n\n  validate(value: unknown): value is Maybe<T> {\n    if (value === null || value === undefined) return true;\n    return this.checker.validate(value);\n  }\n\n  expected(): string {\n    return `${this.checker.expected()} or null or undefined`;\n  }\n}\n\nclass OrChecker<T, U> implements Checker<T | U> {\n  declare type: T | U;\n\n  constructor(\n    private left: Checker<T>,\n    private right: Checker<U>\n  ) {}\n\n  validate(value: unknown): value is T | U {\n    return this.left.validate(value) || this.right.validate(value);\n  }\n\n  expected(): string {\n    return `${this.left.expected()} or ${this.right.expected()}`;\n  }\n}\n\nclass ExactValueChecker<T> implements Checker<T> {\n  declare type: T;\n\n  constructor(\n    private value: T,\n    private desc: string\n  ) {}\n\n  validate(obj: unknown): obj is T {\n    return obj === this.value;\n  }\n\n  expected(): string {\n    return this.desc;\n  }\n}\n\nclass PropertyChecker<T> implements Checker<T> {\n  declare type: T;\n\n  constructor(private checkers: Dict<Checker<unknown>>) {}\n\n  validate(obj: unknown): obj is T {\n    if (typeof obj !== 'object') return false;\n    if (obj === null || obj === undefined) return false;\n\n    return Object.entries(this.checkers).every(([k, checker]) =>\n      k in obj ? checker.validate((obj as Dict)[k]) : false\n    );\n  }\n\n  expected(): string {\n    let pairs = Object.entries(this.checkers).map(([k, checker]) => {\n      return `${k}: ${checker.expected()}`;\n    });\n\n    return `{ ${pairs.join(',')} }`;\n  }\n}\n\nclass ArrayChecker<T> implements Checker<T[]> {\n  declare type: T[];\n\n  constructor(private checker: Checker<T>) {}\n\n  validate(obj: unknown): obj is T[] {\n    if (obj === null || obj === undefined) return false;\n    if (!Array.isArray(obj)) return false;\n\n    return obj.every((item) => this.checker.validate(item));\n  }\n\n  expected(): string {\n    return `Array<${this.checker.expected()}>`;\n  }\n}\n\nclass DictChecker<T> implements Checker<Dict<T>> {\n  declare type: Dict<T>;\n\n  constructor(private checker: Checker<T>) {}\n\n  validate(value: unknown): value is Dict<T> {\n    let isDict =\n      typeof value === 'object' && value !== null && Object.getPrototypeOf(value) === null;\n\n    if (!isDict) return false;\n\n    let { checker } = this;\n\n    for (let key in value as Dict) {\n      if (!checker.validate((value as Dict)[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  expected(): string {\n    return `a primitive`;\n  }\n}\n\nclass OpaqueChecker implements Checker<unknown> {\n  type: unknown;\n\n  validate(_obj: unknown): _obj is unknown {\n    return true;\n  }\n\n  expected(): string {\n    return `any`;\n  }\n}\n\nclass ObjectChecker implements Checker<unknown> {\n  declare type: object;\n\n  validate(obj: unknown): obj is object {\n    return typeof obj === 'function' || (typeof obj === 'object' && obj !== null);\n  }\n\n  expected(): string {\n    return `an object or function (valid WeakMap key)`;\n  }\n}\n\nexport interface SafeString {\n  toHTML(): string;\n}\n\nclass SafeStringChecker implements Checker<SafeString> {\n  declare type: SafeString;\n\n  validate(value: unknown): value is SafeString {\n    return (\n      typeof value === 'object' && value !== null && typeof (value as any).toHTML === 'function'\n    );\n  }\n\n  expected(): string {\n    return `SafeString`;\n  }\n}\n\nexport function CheckInstanceof<T>(Class: Constructor<T>): Checker<T> {\n  if (!LOCAL_DEBUG) {\n    return new NoopChecker();\n  }\n\n  return new InstanceofChecker<T>(Class);\n}\n\nexport function CheckOption<T>(checker: Checker<T>): Checker<Nullable<T>> {\n  if (!LOCAL_DEBUG) {\n    return new NoopChecker();\n  }\n\n  return new OptionChecker(checker, null);\n}\n\nexport function CheckMaybe<T>(checker: Checker<T>): Checker<Maybe<T>> {\n  if (!LOCAL_DEBUG) {\n    return new NoopChecker();\n  }\n\n  return new MaybeChecker(checker);\n}\n\nexport function CheckInterface<\n  I extends { [P in keyof O]: O[P]['type'] },\n  O extends Dict<Checker<unknown>>,\n>(obj: O): Checker<I> {\n  if (!LOCAL_DEBUG) {\n    return new NoopChecker();\n  }\n\n  return new PropertyChecker(obj);\n}\n\nexport function CheckArray<T>(obj: Checker<T>): Checker<T[]> {\n  if (!LOCAL_DEBUG) {\n    return new NoopChecker();\n  }\n  return new ArrayChecker(obj);\n}\n\nexport function CheckDict<T>(obj: Checker<T>): Checker<Dict<T>> {\n  if (!LOCAL_DEBUG) {\n    return new NoopChecker();\n  }\n  return new DictChecker(obj);\n}\n\nfunction defaultMessage(value: unknown, expected: string): string {\n  return `Got ${value}, expected:\\n${expected}`;\n}\n\nexport function check<T>(\n  value: unknown,\n  checker: Checker<T>,\n  message?: (value: unknown, expected: string) => string\n): T;\nexport function check<T, U extends T>(value: T, checker: (value: T) => asserts value is U): U;\nexport function check<T>(\n  value: unknown,\n  checker: Checker<T> | ((value: unknown) => void),\n  message: (value: unknown, expected: string) => string = defaultMessage\n): T {\n  if (!LOCAL_DEBUG) {\n    return value as T;\n  }\n\n  if (typeof checker === 'function') {\n    checker(value);\n    return value as T;\n  }\n  if (checker.validate(value)) {\n    return value;\n  } else {\n    throw new Error(message(value, checker.expected()));\n  }\n}\n\nlet size = 0;\n\nexport function recordStackSize(sp: number) {\n  size = sp;\n}\n\nexport function expectStackChange(stack: { sp: number }, expected: number, name: string) {\n  if (LOCAL_DEBUG) {\n    return;\n  }\n\n  let actual = stack.sp - size;\n\n  if (actual === expected) return;\n\n  throw new Error(\n    `Expected stack to change by ${expected}, but it changed by ${actual} in ${name}`\n  );\n}\n\nexport const CheckPrimitive: Checker<Primitive> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new PrimitiveChecker();\nexport const CheckFunction: Checker<Function> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new TypeofChecker<Function>('function');\nexport const CheckNumber: Checker<number> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new TypeofChecker<number>('number');\nexport const CheckBoolean: Checker<boolean> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new TypeofChecker<boolean>('boolean');\nexport const CheckHandle: Checker<number> = LOCAL_DEBUG ? CheckNumber : new NoopChecker();\nexport const CheckString: Checker<string> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new TypeofChecker<string>('string');\nexport const CheckNull: Checker<null> = !LOCAL_DEBUG ? new NoopChecker() : new NullChecker();\nexport const CheckUndefined: Checker<undefined> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new UndefinedChecker();\nexport const CheckUnknown: Checker<unknown> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new OpaqueChecker();\nexport const CheckSafeString: Checker<SafeString> = !LOCAL_DEBUG\n  ? new NoopChecker()\n  : new SafeStringChecker();\nexport const CheckObject: Checker<object> = !LOCAL_DEBUG ? new NoopChecker() : new ObjectChecker();\n\nexport function CheckOr<T, U>(left: Checker<T>, right: Checker<U>): Checker<T | U> {\n  if (!LOCAL_DEBUG) {\n    return new NoopChecker<T | U>();\n  }\n  return new OrChecker(left, right);\n}\n\nexport function CheckValue<T>(value: T, desc = String(value)): Checker<T> {\n  if (!LOCAL_DEBUG) {\n    return new NoopChecker<T>();\n  }\n  return new ExactValueChecker(value, desc);\n}\n\nexport const CheckBlockSymbolTable: Checker<BlockSymbolTable> = LOCAL_DEBUG\n  ? CheckInterface({\n      parameters: CheckArray(CheckNumber),\n    })\n  : new NoopChecker();\n\nexport const CheckProgramSymbolTable: Checker<ProgramSymbolTable> = LOCAL_DEBUG\n  ? CheckInterface({\n      hasEval: CheckBoolean,\n      symbols: CheckArray(CheckString),\n    })\n  : new NoopChecker();\n\nexport const CheckElement: Checker<SimpleElement> = LOCAL_DEBUG\n  ? CheckInterface({\n      nodeType: CheckValue(1),\n      tagName: CheckString,\n      nextSibling: CheckUnknown,\n    })\n  : new NoopChecker();\n\nexport const CheckDocumentFragment: Checker<SimpleDocumentFragment> = LOCAL_DEBUG\n  ? CheckInterface({\n      nodeType: CheckValue(11),\n      nextSibling: CheckUnknown,\n    })\n  : new NoopChecker();\n\nexport const CheckNode: Checker<SimpleNode> = LOCAL_DEBUG\n  ? CheckInterface({\n      nodeType: CheckNumber,\n      nextSibling: CheckUnknown,\n    })\n  : new NoopChecker();\n"],"names":["opcodeMetadata","op","isMachine","debugSlice","context","start","end","logOpcode","type","params","debug","c","Array","Op","Size","fill","OPERAND_TYPES","normalize","key","input","name","undefined","format","Error","JSON","stringify","isArray","ops","map","operands","slice","mnemonic","before","stackChange","length","check","skip","stack","after","hasRest","some","s","split","indexOf","normalizeAll","parsed","machine","normalizeParsed","syscall","out","Object","create","value","entries","buildEnum","offset","max","last","e","values","forEach","i","push","predicate","enumString","join","strip","strings","args","String","exec","min","Number","MAX_SAFE_INTEGER","line","leading","Math","stripped","META_KIND","buildSingleMeta","kind","all","o","pad","v","keys","repeat","buildMetas","NoopChecker","validate","expected","wrap","checker","CheckInstanceof","Class","CheckOption","CheckMaybe","CheckInterface","obj","CheckArray","CheckDict","defaultMessage","message","recordStackSize","sp","CheckPrimitive","CheckFunction","CheckNumber","CheckBoolean","CheckHandle","CheckString","CheckUndefined","CheckUnknown","CheckSafeString","CheckObject","CheckOr","left","right","CheckBlockSymbolTable","CheckProgramSymbolTable","CheckElement","CheckDocumentFragment","CheckNode"],"mappings":"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"}