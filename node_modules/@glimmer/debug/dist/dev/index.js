import { Op } from "@glimmer/vm";

/* This file is generated by build/debug.js */ function opcodeMetadata(op, isMachine) {
    return null;
}

function debugSlice(context, start, end) {}

function logOpcode(type, params) {}

function debug(c, op, isMachine) {}

// TODO: How do these map onto constant and machine types?
new Array(Op.Size).fill(null), new Array(Op.Size).fill(null);

const OPERAND_TYPES = [ "u32", "i32", "owner", "handle", "str", "option-str", "array", "str-array", "bool", "primitive", "register", "unknown", "symbol-table", "scope" ];

function normalize(key, input) {
    let name;
    if (void 0 === input.format) throw new Error(`Missing format in ${JSON.stringify(input)}`);
    name = Array.isArray(input.format) ? input.format[0] : input.format;
    let ops = Array.isArray(input.format) ? function(input) {
        if (!Array.isArray(input)) throw new Error(`Expected operands array, got ${JSON.stringify(input)}`);
        return input.map(op);
    }(input.format.slice(1)) : [];
    return {
        name: name,
        mnemonic: key,
        before: null,
        stackChange: stackChange(input["operand-stack"]),
        ops: ops,
        operands: ops.length,
        check: !0 !== input.skip
    };
}

function stackChange(stack) {
    if (void 0 === stack) return 0;
    let before = stack[0], after = stack[1];
    return hasRest(before) || hasRest(after) ? null : after.length - before.length;
}

function hasRest(input) {
    if (!Array.isArray(input)) throw new Error(`Unexpected stack entry: ${JSON.stringify(input)}`);
    return input.some((s => "..." === s.slice(-3)));
}

function op(input) {
    let [name, type] = input.split(":");
    if (s = type, -1 !== OPERAND_TYPES.indexOf(s)) return {
        name: name,
        type: type
    };
    throw new Error(`Expected operand, found ${JSON.stringify(input)}`);
    var s;
}

function normalizeAll(parsed) {
    return {
        machine: normalizeParsed(parsed.machine),
        syscall: normalizeParsed(parsed.syscall)
    };
}

function normalizeParsed(parsed) {
    let out = Object.create(null);
    for (const [key, value] of Object.entries(parsed)) out[key] = normalize(key, value);
    return out;
}

function buildEnum(name, parsed, offset, max) {
    let last, e = [ `export enum ${name} {` ];
    Object.values(parsed).forEach(((value, i) => {
        e.push(`  ${value.name} = ${offset + i},`), last = i;
    })), e.push(`  Size = ${last + offset + 1},`), e.push("}");
    let predicate, enumString = e.join("\n");
    return predicate = max ? strip`
      export function is${name}(value: number): value is ${name} {
        return value >= ${offset} && value <= ${max};
      }
    ` : strip`
      export function is${name}(value: number): value is ${name} {
        return value >= ${offset};
      }
    `, {
        enumString: enumString,
        predicate: predicate
    };
}

function strip(strings, ...args) {
    let out = "";
    for (let i = 0; i < strings.length; i++) out += `${strings[i]}${void 0 !== args[i] ? String(args[i]) : ""}`;
    // eslint-disable-next-line regexp/no-super-linear-backtracking
        out = /^\s*?\n?([\s\S]*?)\s*$/u.exec(out)[1];
    let min = Number.MAX_SAFE_INTEGER;
    for (let line of out.split("\n")) {
        let leading = /^\s*/u.exec(line)[0].length;
        min = Math.min(min, leading);
    }
    let stripped = "";
    for (let line of out.split("\n")) stripped += line.slice(min) + "\n";
    return stripped;
}

const META_KIND = [ "METADATA", "MACHINE_METADATA" ];

function buildSingleMeta(kind, all, key) {
    return `${kind}[${"MACHINE_METADATA" === kind ? "MachineOp" : "Op"}.${all[key].name}] = ${stringify(all[key], 0)};`;
}

function stringify(o, pad) {
    if ("object" != typeof o || null === o) return "string" == typeof o ? `'${o}'` : JSON.stringify(o);
    if (Array.isArray(o)) return `[${o.map((v => stringify(v, pad))).join(", ")}]`;
    let out = [ "{" ];
    for (let key of Object.keys(o)) out.push(`${" ".repeat(pad + 2)}${key}: ${stringify(o[key], pad + 2)},`);
    return out.push(`${" ".repeat(pad)}}`), out.join("\n");
}

function buildMetas(kind, all) {
    let out = [];
    for (let key of Object.keys(all)) out.push(buildSingleMeta(kind, all, key));
    return out.join("\n\n");
}

class NoopChecker {
    validate(value) {
        return !0;
    }
    expected() {
        return "<noop>";
    }
}

function wrap(checker) {
    return new NoopChecker;
}

function CheckInstanceof(Class) {
    return new NoopChecker;
}

function CheckOption(checker) {
    return new NoopChecker;
}

function CheckMaybe(checker) {
    return new NoopChecker;
}

function CheckInterface(obj) {
    return new NoopChecker;
}

function CheckArray(obj) {
    return new NoopChecker;
}

function CheckDict(obj) {
    return new NoopChecker;
}

function defaultMessage(value, expected) {
    return `Got ${value}, expected:\n${expected}`;
}

function check(value, checker, message = defaultMessage) {
    return value;
}

function recordStackSize(sp) {}

const CheckPrimitive = new NoopChecker, CheckFunction = new NoopChecker, CheckNumber = new NoopChecker, CheckBoolean = new NoopChecker, CheckHandle = new NoopChecker, CheckString = new NoopChecker, CheckUndefined = new NoopChecker, CheckUnknown = new NoopChecker, CheckSafeString = new NoopChecker, CheckObject = new NoopChecker;

function CheckOr(left, right) {
    return new NoopChecker;
}

const CheckBlockSymbolTable = new NoopChecker, CheckProgramSymbolTable = new NoopChecker, CheckElement = new NoopChecker, CheckDocumentFragment = new NoopChecker, CheckNode = new NoopChecker;

export { CheckArray, CheckBlockSymbolTable, CheckBoolean, CheckDict, CheckDocumentFragment, CheckElement, CheckFunction, CheckHandle, CheckInstanceof, CheckInterface, CheckMaybe, CheckNode, CheckNumber, CheckObject, CheckOption, CheckOr, CheckPrimitive, CheckProgramSymbolTable, CheckSafeString, CheckString, CheckUndefined, CheckUnknown, META_KIND, OPERAND_TYPES, buildEnum, buildMetas, buildSingleMeta, check, debug, debugSlice, logOpcode, normalize, normalizeAll, normalizeParsed, opcodeMetadata, recordStackSize, strip, wrap };
//# sourceMappingURL=index.js.map
