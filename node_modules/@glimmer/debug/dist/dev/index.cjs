'use strict';

var vm = require('@glimmer/vm');

/* This file is generated by build/debug.js */

function opcodeMetadata(op, isMachine) {
  {
    return null;
  }
}
new Array(vm.Op.Size).fill(null);
new Array(vm.Op.Size).fill(null);

function debugSlice(context, start, end) {
}
function logOpcode(type, params) {
}
function debug(c, op, isMachine) {
  return undefined;
}

// TODO: How do these map onto constant and machine types?
const OPERAND_TYPES = ['u32', 'i32', 'owner', 'handle', 'str', 'option-str', 'array', 'str-array', 'bool', 'primitive', 'register', 'unknown', 'symbol-table', 'scope'];
function isOperandType(s) {
  return OPERAND_TYPES.indexOf(s) !== -1;
}
function normalize(key, input) {
  let name;
  if (input.format === undefined) {
    throw new Error(`Missing format in ${JSON.stringify(input)}`);
  }
  if (Array.isArray(input.format)) {
    name = input.format[0];
  } else {
    name = input.format;
  }
  let ops = Array.isArray(input.format) ? operands(input.format.slice(1)) : [];
  return {
    name,
    mnemonic: key,
    before: null,
    stackChange: stackChange(input['operand-stack']),
    ops,
    operands: ops.length,
    check: input.skip === true ? false : true
  };
}
function stackChange(stack) {
  if (stack === undefined) {
    return 0;
  }
  let before = stack[0];
  let after = stack[1];
  if (hasRest(before) || hasRest(after)) {
    return null;
  }
  return after.length - before.length;
}
function hasRest(input) {
  if (!Array.isArray(input)) {
    throw new Error(`Unexpected stack entry: ${JSON.stringify(input)}`);
  }
  return input.some(s => s.slice(-3) === '...');
}
function operands(input) {
  if (!Array.isArray(input)) {
    throw new Error(`Expected operands array, got ${JSON.stringify(input)}`);
  }
  return input.map(op);
}
function op(input) {
  let [name, type] = input.split(':');
  if (isOperandType(type)) {
    return {
      name,
      type
    };
  } else {
    throw new Error(`Expected operand, found ${JSON.stringify(input)}`);
  }
}
function normalizeAll(parsed) {
  let machine = normalizeParsed(parsed.machine);
  let syscall = normalizeParsed(parsed.syscall);
  return {
    machine,
    syscall
  };
}
function normalizeParsed(parsed) {
  let out = Object.create(null);
  for (const [key, value] of Object.entries(parsed)) {
    out[key] = normalize(key, value);
  }
  return out;
}
function buildEnum(name, parsed, offset, max) {
  let e = [`export enum ${name} {`];
  let last;
  Object.values(parsed).forEach((value, i) => {
    e.push(`  ${value.name} = ${offset + i},`);
    last = i;
  });
  e.push(`  Size = ${last + offset + 1},`);
  e.push('}');
  let enumString = e.join('\n');
  let predicate;
  if (max) {
    predicate = strip`
      export function is${name}(value: number): value is ${name} {
        return value >= ${offset} && value <= ${max};
      }
    `;
  } else {
    predicate = strip`
      export function is${name}(value: number): value is ${name} {
        return value >= ${offset};
      }
    `;
  }
  return {
    enumString,
    predicate
  };
}
function strip(strings, ...args) {
  let out = '';
  for (let i = 0; i < strings.length; i++) {
    let string = strings[i];
    let dynamic = args[i] !== undefined ? String(args[i]) : '';
    out += `${string}${dynamic}`;
  }

  // eslint-disable-next-line regexp/no-super-linear-backtracking
  out = /^\s*?\n?([\s\S]*?)\s*$/u.exec(out)[1];
  let min = Number.MAX_SAFE_INTEGER;
  for (let line of out.split('\n')) {
    let leading = /^\s*/u.exec(line)[0].length;
    min = Math.min(min, leading);
  }
  let stripped = '';
  for (let line of out.split('\n')) {
    stripped += line.slice(min) + '\n';
  }
  return stripped;
}
const META_KIND = ['METADATA', 'MACHINE_METADATA'];
function buildSingleMeta(kind, all, key) {
  let e = kind === 'MACHINE_METADATA' ? 'MachineOp' : 'Op';
  return `${kind}[${e}.${all[key].name}] = ${stringify(all[key], 0)};`;
}
function stringify(o, pad) {
  if (typeof o !== 'object' || o === null) {
    if (typeof o === 'string') {
      return `'${o}'`;
    }
    return JSON.stringify(o);
  }
  if (Array.isArray(o)) {
    return `[${o.map(v => stringify(v, pad)).join(', ')}]`;
  }
  let out = ['{'];
  for (let key of Object.keys(o)) {
    out.push(`${' '.repeat(pad + 2)}${key}: ${stringify(o[key], pad + 2)},`);
  }
  out.push(`${' '.repeat(pad)}}`);
  return out.join('\n');
}
function buildMetas(kind, all) {
  let out = [];
  for (let key of Object.keys(all)) {
    out.push(buildSingleMeta(kind, all, key));
  }
  return out.join('\n\n');
}

class NoopChecker {
  validate(value) {
    return true;
  }
  expected() {
    return '<noop>';
  }
}
function wrap(checker) {
  {
    return new NoopChecker();
  }
}
function CheckInstanceof(Class) {
  {
    return new NoopChecker();
  }
}
function CheckOption(checker) {
  {
    return new NoopChecker();
  }
}
function CheckMaybe(checker) {
  {
    return new NoopChecker();
  }
}
function CheckInterface(obj) {
  {
    return new NoopChecker();
  }
}
function CheckArray(obj) {
  {
    return new NoopChecker();
  }
}
function CheckDict(obj) {
  {
    return new NoopChecker();
  }
}
function defaultMessage(value, expected) {
  return `Got ${value}, expected:\n${expected}`;
}
function check(value, checker, message = defaultMessage) {
  {
    return value;
  }
}
function recordStackSize(sp) {
}
const CheckPrimitive = new NoopChecker() ;
const CheckFunction = new NoopChecker() ;
const CheckNumber = new NoopChecker() ;
const CheckBoolean = new NoopChecker() ;
const CheckHandle = new NoopChecker();
const CheckString = new NoopChecker() ;
const CheckUndefined = new NoopChecker() ;
const CheckUnknown = new NoopChecker() ;
const CheckSafeString = new NoopChecker() ;
const CheckObject = new NoopChecker() ;
function CheckOr(left, right) {
  {
    return new NoopChecker();
  }
}
const CheckBlockSymbolTable = new NoopChecker();
const CheckProgramSymbolTable = new NoopChecker();
const CheckElement = new NoopChecker();
const CheckDocumentFragment = new NoopChecker();
const CheckNode = new NoopChecker();

exports.CheckArray = CheckArray;
exports.CheckBlockSymbolTable = CheckBlockSymbolTable;
exports.CheckBoolean = CheckBoolean;
exports.CheckDict = CheckDict;
exports.CheckDocumentFragment = CheckDocumentFragment;
exports.CheckElement = CheckElement;
exports.CheckFunction = CheckFunction;
exports.CheckHandle = CheckHandle;
exports.CheckInstanceof = CheckInstanceof;
exports.CheckInterface = CheckInterface;
exports.CheckMaybe = CheckMaybe;
exports.CheckNode = CheckNode;
exports.CheckNumber = CheckNumber;
exports.CheckObject = CheckObject;
exports.CheckOption = CheckOption;
exports.CheckOr = CheckOr;
exports.CheckPrimitive = CheckPrimitive;
exports.CheckProgramSymbolTable = CheckProgramSymbolTable;
exports.CheckSafeString = CheckSafeString;
exports.CheckString = CheckString;
exports.CheckUndefined = CheckUndefined;
exports.CheckUnknown = CheckUnknown;
exports.META_KIND = META_KIND;
exports.OPERAND_TYPES = OPERAND_TYPES;
exports.buildEnum = buildEnum;
exports.buildMetas = buildMetas;
exports.buildSingleMeta = buildSingleMeta;
exports.check = check;
exports.debug = debug;
exports.debugSlice = debugSlice;
exports.logOpcode = logOpcode;
exports.normalize = normalize;
exports.normalizeAll = normalizeAll;
exports.normalizeParsed = normalizeParsed;
exports.opcodeMetadata = opcodeMetadata;
exports.recordStackSize = recordStackSize;
exports.strip = strip;
exports.wrap = wrap;
//# sourceMappingURL=index.cjs.map
