{"version":3,"file":"index.js","sources":["../../lib/util/args-proxy.ts","../../../debug/lib/opcode-metadata.ts","../../lib/util/capabilities.ts","../../lib/public/helper.ts","../../lib/internal/defaults.ts","../../lib/internal/api.ts","../../lib/public/component.ts","../../lib/public/modifier.ts","../../lib/public/api.ts","../../lib/public/template.ts"],"sourcesContent":["import type {\n  Arguments,\n  CapturedArguments,\n  CapturedNamedArguments,\n  CapturedPositionalArguments,\n} from '@glimmer/interfaces';\nimport type { Tag } from '@glimmer/validator';\nimport { valueForRef } from '@glimmer/reference';\nimport { track } from '@glimmer/validator';\n\nconst CUSTOM_TAG_FOR = new WeakMap<object, (obj: object, key: string) => Tag>();\n\nexport function getCustomTagFor(obj: object): ((obj: object, key: string) => Tag) | undefined {\n  return CUSTOM_TAG_FOR.get(obj);\n}\n\nexport function setCustomTagFor(obj: object, customTagFn: (obj: object, key: string) => Tag) {\n  CUSTOM_TAG_FOR.set(obj, customTagFn);\n}\n\nfunction convertToInt(prop: number | string | symbol): number | null {\n  if (typeof prop === 'symbol') return null;\n\n  const num = Number(prop);\n\n  if (isNaN(num)) return null;\n\n  return num % 1 === 0 ? num : null;\n}\n\nfunction tagForNamedArg(namedArgs: CapturedNamedArguments, key: string): Tag {\n  return track(() => {\n    if (key in namedArgs) {\n      valueForRef(namedArgs[key]!);\n    }\n  });\n}\n\nfunction tagForPositionalArg(positionalArgs: CapturedPositionalArguments, key: string): Tag {\n  return track(() => {\n    if (key === '[]') {\n      // consume all of the tags in the positional array\n      positionalArgs.forEach(valueForRef);\n    }\n\n    const parsed = convertToInt(key);\n\n    if (parsed !== null && parsed < positionalArgs.length) {\n      // consume the tag of the referenced index\n      valueForRef(positionalArgs[parsed]!);\n    }\n  });\n}\n\nclass NamedArgsProxy implements ProxyHandler<{}> {\n  declare set?: (target: {}, prop: string | number | symbol) => boolean;\n\n  constructor(private named: CapturedNamedArguments) {}\n\n  get(_target: {}, prop: string | number | symbol) {\n    const ref = this.named[prop as string];\n\n    if (ref !== undefined) {\n      return valueForRef(ref);\n    }\n  }\n\n  has(_target: {}, prop: string | number | symbol) {\n    return prop in this.named;\n  }\n\n  ownKeys() {\n    return Object.keys(this.named);\n  }\n\n  isExtensible() {\n    return false;\n  }\n\n  getOwnPropertyDescriptor(_target: {}, prop: string | number | symbol) {\n    if (import.meta.env.DEV && !(prop in this.named)) {\n      throw new Error(\n        `args proxies do not have real property descriptors, so you should never need to call getOwnPropertyDescriptor yourself. This code exists for enumerability, such as in for-in loops and Object.keys(). Attempted to get the descriptor for \\`${String(\n          prop\n        )}\\``\n      );\n    }\n\n    return {\n      enumerable: true,\n      configurable: true,\n    };\n  }\n}\n\nclass PositionalArgsProxy implements ProxyHandler<[]> {\n  declare set?: (target: [], prop: string | number | symbol) => boolean;\n  declare ownKeys?: (target: []) => string[];\n\n  constructor(private positional: CapturedPositionalArguments) {}\n\n  get(target: [], prop: string | number | symbol) {\n    let { positional } = this;\n\n    if (prop === 'length') {\n      return positional.length;\n    }\n\n    const parsed = convertToInt(prop);\n\n    if (parsed !== null && parsed < positional.length) {\n      return valueForRef(positional[parsed]!);\n    }\n\n    return (target as any)[prop];\n  }\n\n  isExtensible() {\n    return false;\n  }\n\n  has(_target: [], prop: string | number | symbol) {\n    const parsed = convertToInt(prop);\n\n    return parsed !== null && parsed < this.positional.length;\n  }\n}\n\nexport const argsProxyFor = (\n  capturedArgs: CapturedArguments,\n  type: 'component' | 'helper' | 'modifier'\n): Arguments => {\n  const { named, positional } = capturedArgs;\n\n  let getNamedTag = (_obj: object, key: string) => tagForNamedArg(named, key);\n  let getPositionalTag = (_obj: object, key: string) => tagForPositionalArg(positional, key);\n\n  const namedHandler = new NamedArgsProxy(named);\n  const positionalHandler = new PositionalArgsProxy(positional);\n\n  const namedTarget = Object.create(null);\n  const positionalTarget: unknown[] = [];\n\n  if (import.meta.env.DEV) {\n    const setHandler = function (_target: unknown, prop: symbol | string | number): never {\n      throw new Error(\n        `You attempted to set ${String(\n          prop\n        )} on the arguments of a component, helper, or modifier. Arguments are immutable and cannot be updated directly; they always represent the values that are passed down. If you want to set default values, you should use a getter and local tracked state instead.`\n      );\n    };\n\n    const forInDebugHandler = (): never => {\n      throw new Error(\n        `Object.keys() was called on the positional arguments array for a ${type}, which is not supported. This function is a low-level function that should not need to be called for positional argument arrays. You may be attempting to iterate over the array using for...in instead of for...of.`\n      );\n    };\n\n    namedHandler.set = setHandler;\n    positionalHandler.set = setHandler;\n    positionalHandler.ownKeys = forInDebugHandler;\n  }\n\n  const namedProxy = new Proxy(namedTarget, namedHandler);\n  const positionalProxy = new Proxy(positionalTarget, positionalHandler);\n\n  setCustomTagFor(namedProxy, getNamedTag);\n  setCustomTagFor(positionalProxy, getPositionalTag);\n\n  return {\n    named: namedProxy,\n    positional: positionalProxy,\n  };\n};\n","/* This file is generated by build/debug.js */\n\nimport type { Nullable, VmMachineOp, VmOp } from '@glimmer/interfaces';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { MachineOp, Op } from '@glimmer/vm';\n\nimport type { NormalizedMetadata } from './metadata';\n\nexport function opcodeMetadata(\n  op: VmMachineOp | VmOp,\n  isMachine: 0 | 1\n): Nullable<NormalizedMetadata> {\n  if (!LOCAL_DEBUG) {\n    return null;\n  }\n\n  let value = isMachine ? MACHINE_METADATA[op] : METADATA[op];\n\n  return value || null;\n}\n\nconst METADATA: Nullable<NormalizedMetadata>[] = new Array(Op.Size).fill(null);\nconst MACHINE_METADATA: Nullable<NormalizedMetadata>[] = new Array(Op.Size).fill(null);\n\nif (LOCAL_DEBUG) {\n  MACHINE_METADATA[MachineOp.PushFrame] = {\n    name: 'PushFrame',\n    mnemonic: 'pushf',\n    before: null,\n    stackChange: 2,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.PopFrame] = {\n    name: 'PopFrame',\n    mnemonic: 'popf',\n    before: null,\n    stackChange: -2,\n    ops: [],\n    operands: 0,\n    check: false,\n  };\n\n  MACHINE_METADATA[MachineOp.InvokeVirtual] = {\n    name: 'InvokeVirtual',\n    mnemonic: 'vcall',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.InvokeStatic] = {\n    name: 'InvokeStatic',\n    mnemonic: 'scall',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'offset',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.Jump] = {\n    name: 'Jump',\n    mnemonic: 'goto',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'to',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.Return] = {\n    name: 'Return',\n    mnemonic: 'ret',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: false,\n  };\n\n  MACHINE_METADATA[MachineOp.ReturnTo] = {\n    name: 'ReturnTo',\n    mnemonic: 'setra',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'offset',\n        type: 'i32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n  METADATA[Op.Helper] = {\n    name: 'Helper',\n    mnemonic: 'ncall',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'helper',\n        type: 'handle',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.DynamicHelper] = {\n    name: 'DynamicHelper',\n    mnemonic: 'dynamiccall',\n    before: null,\n    stackChange: null,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.SetNamedVariables] = {\n    name: 'SetNamedVariables',\n    mnemonic: 'vsargs',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetBlocks] = {\n    name: 'SetBlocks',\n    mnemonic: 'vbblocks',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetVariable] = {\n    name: 'SetVariable',\n    mnemonic: 'sbvar',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'symbol',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetBlock] = {\n    name: 'SetBlock',\n    mnemonic: 'sblock',\n    before: null,\n    stackChange: -3,\n    ops: [\n      {\n        name: 'symbol',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetVariable] = {\n    name: 'GetVariable',\n    mnemonic: 'symload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'symbol',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetProperty] = {\n    name: 'GetProperty',\n    mnemonic: 'getprop',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'property',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetBlock] = {\n    name: 'GetBlock',\n    mnemonic: 'blockload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'block',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SpreadBlock] = {\n    name: 'SpreadBlock',\n    mnemonic: 'blockspread',\n    before: null,\n    stackChange: 2,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.HasBlock] = {\n    name: 'HasBlock',\n    mnemonic: 'hasblockload',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.HasBlockParams] = {\n    name: 'HasBlockParams',\n    mnemonic: 'hasparamsload',\n    before: null,\n    stackChange: -2,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Concat] = {\n    name: 'Concat',\n    mnemonic: 'concat',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.IfInline] = {\n    name: 'IfInline',\n    mnemonic: 'ifinline',\n    before: null,\n    stackChange: -2,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Not] = {\n    name: 'Not',\n    mnemonic: 'not',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Constant] = {\n    name: 'Constant',\n    mnemonic: 'rconstload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'constant',\n        type: 'unknown',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ConstantReference] = {\n    name: 'ConstantReference',\n    mnemonic: 'rconstrefload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'constant',\n        type: 'unknown',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Primitive] = {\n    name: 'Primitive',\n    mnemonic: 'pconstload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'constant',\n        type: 'primitive',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PrimitiveReference] = {\n    name: 'PrimitiveReference',\n    mnemonic: 'ptoref',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.ReifyU32] = {\n    name: 'ReifyU32',\n    mnemonic: 'reifyload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Dup] = {\n    name: 'Dup',\n    mnemonic: 'dup',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n      {\n        name: 'offset',\n        type: 'u32',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.Pop] = {\n    name: 'Pop',\n    mnemonic: 'pop',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: false,\n  };\n\n  METADATA[Op.Load] = {\n    name: 'Load',\n    mnemonic: 'put',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Fetch] = {\n    name: 'Fetch',\n    mnemonic: 'regload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.RootScope] = {\n    name: 'RootScope',\n    mnemonic: 'rscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'symbols',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.VirtualRootScope] = {\n    name: 'VirtualRootScope',\n    mnemonic: 'vrscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ChildScope] = {\n    name: 'ChildScope',\n    mnemonic: 'cscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopScope] = {\n    name: 'PopScope',\n    mnemonic: 'scopepop',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Text] = {\n    name: 'Text',\n    mnemonic: 'apnd_text',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'contents',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Comment] = {\n    name: 'Comment',\n    mnemonic: 'apnd_comment',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'contents',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.AppendHTML] = {\n    name: 'AppendHTML',\n    mnemonic: 'apnd_dynhtml',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendSafeHTML] = {\n    name: 'AppendSafeHTML',\n    mnemonic: 'apnd_dynshtml',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendDocumentFragment] = {\n    name: 'AppendDocumentFragment',\n    mnemonic: 'apnd_dynfrag',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendNode] = {\n    name: 'AppendNode',\n    mnemonic: 'apnd_dynnode',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendText] = {\n    name: 'AppendText',\n    mnemonic: 'apnd_dyntext',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.OpenElement] = {\n    name: 'OpenElement',\n    mnemonic: 'apnd_tag',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'tag',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.OpenDynamicElement] = {\n    name: 'OpenDynamicElement',\n    mnemonic: 'apnd_dyntag',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PushRemoteElement] = {\n    name: 'PushRemoteElement',\n    mnemonic: 'apnd_remotetag',\n    before: null,\n    stackChange: -3,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.StaticAttr] = {\n    name: 'StaticAttr',\n    mnemonic: 'apnd_attr',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'name',\n        type: 'str',\n      },\n      {\n        name: 'value',\n        type: 'str',\n      },\n      {\n        name: 'namespace',\n        type: 'option-str',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.DynamicAttr] = {\n    name: 'DynamicAttr',\n    mnemonic: 'apnd_dynattr',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'name',\n        type: 'str',\n      },\n      {\n        name: 'trusting',\n        type: 'bool',\n      },\n      {\n        name: 'namespace',\n        type: 'option-str',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.ComponentAttr] = {\n    name: 'ComponentAttr',\n    mnemonic: 'apnd_cattr',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'name',\n        type: 'str',\n      },\n      {\n        name: 'trusting',\n        type: 'bool',\n      },\n      {\n        name: 'namespace',\n        type: 'option-str',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.FlushElement] = {\n    name: 'FlushElement',\n    mnemonic: 'apnd_flushtag',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CloseElement] = {\n    name: 'CloseElement',\n    mnemonic: 'apnd_closetag',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopRemoteElement] = {\n    name: 'PopRemoteElement',\n    mnemonic: 'apnd_closeremotetag',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Modifier] = {\n    name: 'Modifier',\n    mnemonic: 'apnd_modifier',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'helper',\n        type: 'handle',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.BindDynamicScope] = {\n    name: 'BindDynamicScope',\n    mnemonic: 'setdynscope',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'names',\n        type: 'str-array',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushDynamicScope] = {\n    name: 'PushDynamicScope',\n    mnemonic: 'dynscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopDynamicScope] = {\n    name: 'PopDynamicScope',\n    mnemonic: 'dynscopepop',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CompileBlock] = {\n    name: 'CompileBlock',\n    mnemonic: 'cmpblock',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PushBlockScope] = {\n    name: 'PushBlockScope',\n    mnemonic: 'scopeload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'scope',\n        type: 'scope',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushSymbolTable] = {\n    name: 'PushSymbolTable',\n    mnemonic: 'dsymload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'table',\n        type: 'symbol-table',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.InvokeYield] = {\n    name: 'InvokeYield',\n    mnemonic: 'invokeyield',\n    before: null,\n    stackChange: null,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.JumpIf] = {\n    name: 'JumpIf',\n    mnemonic: 'iftrue',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'to',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.JumpUnless] = {\n    name: 'JumpUnless',\n    mnemonic: 'iffalse',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'to',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.JumpEq] = {\n    name: 'JumpEq',\n    mnemonic: 'ifeq',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'to',\n        type: 'i32',\n      },\n      {\n        name: 'comparison',\n        type: 'i32',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.AssertSame] = {\n    name: 'AssertSame',\n    mnemonic: 'assert_eq',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Enter] = {\n    name: 'Enter',\n    mnemonic: 'blk_start',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'args',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Exit] = {\n    name: 'Exit',\n    mnemonic: 'blk_end',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.ToBoolean] = {\n    name: 'ToBoolean',\n    mnemonic: 'anytobool',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.EnterList] = {\n    name: 'EnterList',\n    mnemonic: 'list_start',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'address',\n        type: 'u32',\n      },\n      {\n        name: 'address',\n        type: 'u32',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.ExitList] = {\n    name: 'ExitList',\n    mnemonic: 'list_end',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Iterate] = {\n    name: 'Iterate',\n    mnemonic: 'iter',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'end',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: false,\n  };\n\n  METADATA[Op.Main] = {\n    name: 'Main',\n    mnemonic: 'main',\n    before: null,\n    stackChange: -2,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ContentType] = {\n    name: 'ContentType',\n    mnemonic: 'ctload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.DynamicContentType] = {\n    name: 'DynamicContentType',\n    mnemonic: 'dctload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Curry] = {\n    name: 'Curry',\n    mnemonic: 'curry',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'type',\n        type: 'u32',\n      },\n      {\n        name: 'is-strict',\n        type: 'bool',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.PushComponentDefinition] = {\n    name: 'PushComponentDefinition',\n    mnemonic: 'cmload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'spec',\n        type: 'handle',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushDynamicComponentInstance] = {\n    name: 'PushDynamicComponentInstance',\n    mnemonic: 'dciload',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.ResolveDynamicComponent] = {\n    name: 'ResolveDynamicComponent',\n    mnemonic: 'cdload',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'owner',\n        type: 'owner',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushArgs] = {\n    name: 'PushArgs',\n    mnemonic: 'argsload',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'names',\n        type: 'str-array',\n      },\n      {\n        name: 'block-names',\n        type: 'str-array',\n      },\n      {\n        name: 'flags',\n        type: 'u32',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.PushEmptyArgs] = {\n    name: 'PushEmptyArgs',\n    mnemonic: 'emptyargsload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopArgs] = {\n    name: 'PopArgs',\n    mnemonic: 'argspop',\n    before: null,\n    stackChange: null,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PrepareArgs] = {\n    name: 'PrepareArgs',\n    mnemonic: 'argsprep',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: false,\n  };\n\n  METADATA[Op.CaptureArgs] = {\n    name: 'CaptureArgs',\n    mnemonic: 'argscapture',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CreateComponent] = {\n    name: 'CreateComponent',\n    mnemonic: 'comp_create',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'flags',\n        type: 'u32',\n      },\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.RegisterComponentDestructor] = {\n    name: 'RegisterComponentDestructor',\n    mnemonic: 'comp_dest',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PutComponentOperations] = {\n    name: 'PutComponentOperations',\n    mnemonic: 'comp_elops',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.GetComponentSelf] = {\n    name: 'GetComponentSelf',\n    mnemonic: 'comp_selfload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetComponentTagName] = {\n    name: 'GetComponentTagName',\n    mnemonic: 'comp_tagload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetComponentLayout] = {\n    name: 'GetComponentLayout',\n    mnemonic: 'comp_layoutload',\n    before: null,\n    stackChange: 2,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.BindEvalScope] = {\n    name: 'BindEvalScope',\n    mnemonic: 'eval_scope',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetupForEval] = {\n    name: 'SetupForEval',\n    mnemonic: 'eval_setup',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PopulateLayout] = {\n    name: 'PopulateLayout',\n    mnemonic: 'comp_layoutput',\n    before: null,\n    stackChange: -2,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.InvokeComponentLayout] = {\n    name: 'InvokeComponentLayout',\n    mnemonic: 'comp_invokelayout',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.BeginComponentTransaction] = {\n    name: 'BeginComponentTransaction',\n    mnemonic: 'comp_begin',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CommitComponentTransaction] = {\n    name: 'CommitComponentTransaction',\n    mnemonic: 'comp_commit',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.DidCreateElement] = {\n    name: 'DidCreateElement',\n    mnemonic: 'comp_created',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.DidRenderLayout] = {\n    name: 'DidRenderLayout',\n    mnemonic: 'comp_rendered',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ResolveMaybeLocal] = {\n    name: 'ResolveMaybeLocal',\n    mnemonic: 'eval_varload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'local',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Debugger] = {\n    name: 'Debugger',\n    mnemonic: 'debugger',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'symbols',\n        type: 'str-array',\n      },\n      {\n        name: 'debugInfo',\n        type: 'array',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n}\n","import type {\n  AttributeHookCapability,\n  Capabilities,\n  CapabilityMask,\n  CreateArgsCapability,\n  CreateCallerCapability,\n  CreateInstanceCapability,\n  DynamicLayoutCapability,\n  DynamicScopeCapability,\n  DynamicTagCapability,\n  ElementHookCapability,\n  Expand,\n  HasSubOwnerCapability,\n  InternalComponentCapability,\n  InternalComponentManager,\n  PrepareArgsCapability,\n  UpdateHookCapability,\n  WillDestroyCapability,\n  WithCreateInstance,\n  WithDynamicLayout,\n  WithPrepareArgs,\n  WithSubOwner,\n  WithUpdateHook,\n  WrappedCapability,\n} from '@glimmer/interfaces';\nimport { check, CheckNumber } from '@glimmer/debug';\nimport { InternalComponentCapabilities } from '@glimmer/vm';\n\nexport const FROM_CAPABILITIES = import.meta.env.DEV ? new WeakSet() : undefined;\n\nexport function buildCapabilities<T extends object>(capabilities: T): T & Capabilities {\n  if (import.meta.env.DEV) {\n    FROM_CAPABILITIES!.add(capabilities);\n    Object.freeze(capabilities);\n  }\n\n  return capabilities as T & Capabilities;\n}\n\nconst EMPTY = InternalComponentCapabilities.Empty;\n\ntype CapabilityOptions = Expand<{\n  [P in keyof Omit<typeof InternalComponentCapabilities, 'Empty'>]?: boolean | undefined;\n}>;\n\n/**\n * Converts a ComponentCapabilities object into a 32-bit integer representation.\n */\nexport function capabilityFlagsFrom(capabilities: CapabilityOptions): CapabilityMask {\n  return (EMPTY |\n    capability(capabilities, 'dynamicLayout') |\n    capability(capabilities, 'dynamicTag') |\n    capability(capabilities, 'prepareArgs') |\n    capability(capabilities, 'createArgs') |\n    capability(capabilities, 'attributeHook') |\n    capability(capabilities, 'elementHook') |\n    capability(capabilities, 'dynamicScope') |\n    capability(capabilities, 'createCaller') |\n    capability(capabilities, 'updateHook') |\n    capability(capabilities, 'createInstance') |\n    capability(capabilities, 'wrapped') |\n    capability(capabilities, 'willDestroy') |\n    capability(capabilities, 'hasSubOwner')) as CapabilityMask;\n}\n\nfunction capability(\n  capabilities: CapabilityOptions,\n  capability: keyof CapabilityOptions\n): InternalComponentCapability {\n  return capabilities[capability] ? InternalComponentCapabilities[capability] : EMPTY;\n}\n\nexport type InternalComponentCapabilityFor<C extends InternalComponentCapability> =\n  C extends DynamicLayoutCapability\n    ? WithDynamicLayout\n    : C extends DynamicTagCapability\n      ? InternalComponentManager\n      : C extends PrepareArgsCapability\n        ? WithPrepareArgs\n        : C extends CreateArgsCapability\n          ? InternalComponentManager\n          : C extends AttributeHookCapability\n            ? InternalComponentManager\n            : C extends ElementHookCapability\n              ? InternalComponentManager\n              : C extends DynamicScopeCapability\n                ? InternalComponentManager\n                : C extends CreateCallerCapability\n                  ? InternalComponentManager\n                  : C extends UpdateHookCapability\n                    ? WithUpdateHook\n                    : C extends CreateInstanceCapability\n                      ? WithCreateInstance\n                      : C extends WrappedCapability\n                        ? InternalComponentManager\n                        : C extends WillDestroyCapability\n                          ? InternalComponentManager\n                          : C extends HasSubOwnerCapability\n                            ? WithSubOwner\n                            : never;\n\nexport function managerHasCapability<F extends InternalComponentCapability>(\n  _manager: InternalComponentManager,\n  capabilities: CapabilityMask,\n  capability: F\n): _manager is InternalComponentCapabilityFor<F> {\n  check(capabilities, CheckNumber);\n  return !!(capabilities & capability);\n}\n\nexport function hasCapability(\n  capabilities: CapabilityMask,\n  capability: InternalComponentCapability\n): boolean {\n  check(capabilities, CheckNumber);\n  return !!(capabilities & capability);\n}\n","import type {\n  Helper,\n  HelperCapabilities,\n  HelperCapabilitiesVersions,\n  HelperDefinitionState,\n  HelperManager,\n  HelperManagerWithDestroyable,\n  HelperManagerWithValue,\n  InternalHelperManager,\n  Owner,\n} from '@glimmer/interfaces';\nimport { associateDestroyableChild } from '@glimmer/destroyable';\nimport { createComputeRef, createConstRef, UNDEFINED_REFERENCE } from '@glimmer/reference';\n\nimport type { ManagerFactory } from './index';\n\nimport { argsProxyFor } from '../util/args-proxy';\nimport { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';\n\nexport function helperCapabilities<Version extends keyof HelperCapabilitiesVersions>(\n  managerAPI: Version,\n  options: Partial<HelperCapabilities> = {}\n): HelperCapabilities {\n  if (import.meta.env.DEV && managerAPI !== '3.23') {\n    throw new Error('Invalid helper manager compatibility specified');\n  }\n\n  if (\n    import.meta.env.DEV &&\n    (!(options.hasValue || options.hasScheduledEffect) ||\n      (options.hasValue && options.hasScheduledEffect))\n  ) {\n    throw new Error(\n      'You must pass either the `hasValue` OR the `hasScheduledEffect` capability when defining a helper manager. Passing neither, or both, is not permitted.'\n    );\n  }\n\n  if (import.meta.env.DEV && options.hasScheduledEffect) {\n    throw new Error(\n      'The `hasScheduledEffect` capability has not yet been implemented for helper managers. Please pass `hasValue` instead'\n    );\n  }\n\n  return buildCapabilities({\n    hasValue: Boolean(options.hasValue),\n    hasDestroyable: Boolean(options.hasDestroyable),\n    hasScheduledEffect: Boolean(options.hasScheduledEffect),\n  });\n}\n\n////////////\n\nexport function hasValue(\n  manager: HelperManager<unknown>\n): manager is HelperManagerWithValue<unknown> {\n  return manager.capabilities.hasValue;\n}\n\nexport function hasDestroyable(\n  manager: HelperManager<unknown>\n): manager is HelperManagerWithDestroyable<unknown> {\n  return manager.capabilities.hasDestroyable;\n}\n\n////////////\n\nexport class CustomHelperManager<O extends Owner = Owner> implements InternalHelperManager<O> {\n  constructor(private factory: ManagerFactory<O | undefined, HelperManager<unknown>>) {}\n\n  private helperManagerDelegates = new WeakMap<O, HelperManager<unknown>>();\n  private undefinedDelegate: HelperManager<unknown> | null = null;\n\n  private getDelegateForOwner(owner: O) {\n    let delegate = this.helperManagerDelegates.get(owner);\n\n    if (delegate === undefined) {\n      let { factory } = this;\n      delegate = factory(owner);\n\n      if (import.meta.env.DEV && !FROM_CAPABILITIES!.has(delegate.capabilities)) {\n        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200\n        throw new Error(\n          `Custom helper managers must have a \\`capabilities\\` property that is the result of calling the \\`capabilities('3.23')\\` (imported via \\`import { capabilities } from '@ember/helper';\\`). Received: \\`${JSON.stringify(\n            delegate.capabilities\n          )}\\` for: \\`${delegate}\\``\n        );\n      }\n\n      this.helperManagerDelegates.set(owner, delegate);\n    }\n\n    return delegate;\n  }\n\n  getDelegateFor(owner: O | undefined) {\n    if (owner === undefined) {\n      let { undefinedDelegate } = this;\n\n      if (undefinedDelegate === null) {\n        let { factory } = this;\n        this.undefinedDelegate = undefinedDelegate = factory(undefined);\n      }\n\n      return undefinedDelegate;\n    } else {\n      return this.getDelegateForOwner(owner);\n    }\n  }\n\n  getHelper(definition: HelperDefinitionState): Helper {\n    return (capturedArgs, owner) => {\n      let manager = this.getDelegateFor(owner as O | undefined);\n\n      const args = argsProxyFor(capturedArgs, 'helper');\n      const bucket = manager.createHelper(definition, args);\n\n      if (hasValue(manager)) {\n        let cache = createComputeRef(\n          () => (manager as HelperManagerWithValue<unknown>).getValue(bucket),\n          null,\n          import.meta.env.DEV && manager.getDebugName && manager.getDebugName(definition)\n        );\n\n        if (hasDestroyable(manager)) {\n          associateDestroyableChild(cache, manager.getDestroyable(bucket));\n        }\n\n        return cache;\n      } else if (hasDestroyable(manager)) {\n        let ref = createConstRef(\n          undefined,\n          import.meta.env.DEV && (manager.getDebugName?.(definition) ?? 'unknown helper')\n        );\n\n        associateDestroyableChild(ref, manager.getDestroyable(bucket));\n\n        return ref;\n      } else {\n        return UNDEFINED_REFERENCE;\n      }\n    };\n  }\n}\n","import type {\n  CapturedArguments as Arguments,\n  HelperCapabilities,\n  HelperManagerWithValue,\n} from '@glimmer/interfaces';\n\nimport { buildCapabilities } from '../util/capabilities';\n\ntype FnArgs<Args extends Arguments = Arguments> =\n  | [...Args['positional'], Args['named']]\n  | [...Args['positional']];\n\ntype AnyFunction = (...args: any[]) => unknown;\n\ninterface State {\n  fn: AnyFunction;\n  args: Arguments;\n}\n\nexport class FunctionHelperManager implements HelperManagerWithValue<State> {\n  capabilities = buildCapabilities({\n    hasValue: true,\n    hasDestroyable: false,\n    hasScheduledEffect: false,\n  }) as HelperCapabilities;\n\n  createHelper(fn: AnyFunction, args: Arguments): State {\n    return { fn, args };\n  }\n\n  getValue({ fn, args }: State): unknown {\n    if (Object.keys(args.named).length > 0) {\n      let argsForFn: FnArgs<Arguments> = [...args.positional, args.named];\n\n      return fn(...argsForFn);\n    }\n\n    return fn(...args.positional);\n  }\n\n  getDebugName(fn: AnyFunction): string {\n    if (fn.name) {\n      return `(helper function ${fn.name})`;\n    }\n\n    return '(anonymous helper function)';\n  }\n}\n","import type {\n  Helper,\n  InternalComponentManager,\n  InternalModifierManager,\n  Owner,\n} from '@glimmer/interfaces';\nimport { debugToString } from '@glimmer/util';\n\nimport { CustomHelperManager } from '../public/helper';\nimport { FunctionHelperManager } from './defaults';\n\ntype InternalManager =\n  | InternalComponentManager\n  | InternalModifierManager\n  | CustomHelperManager\n  | Helper;\n\nconst COMPONENT_MANAGERS = new WeakMap<object, InternalComponentManager>();\n\nconst MODIFIER_MANAGERS = new WeakMap<object, InternalModifierManager>();\n\nconst HELPER_MANAGERS = new WeakMap<object, CustomHelperManager | Helper>();\n\n///////////\n\nconst getPrototypeOf = Object.getPrototypeOf;\n\nfunction setManager<Def extends object>(\n  map: WeakMap<object, object>,\n  manager: object,\n  obj: Def\n): Def {\n  if (\n    import.meta.env.DEV &&\n    (typeof obj !== 'object' || obj === null) &&\n    typeof obj !== 'function'\n  ) {\n    throw new Error(\n      `Attempted to set a manager on a non-object value. Managers can only be associated with objects or functions. Value was ${debugToString!(\n        obj\n      )}`\n    );\n  }\n\n  if (import.meta.env.DEV && map.has(obj)) {\n    throw new Error(\n      `Attempted to set the same type of manager multiple times on a value. You can only associate one manager of each type with a given value. Value was ${debugToString!(\n        obj\n      )}`\n    );\n  }\n\n  map.set(obj, manager);\n  return obj;\n}\n\nfunction getManager<M extends InternalManager>(\n  map: WeakMap<object, M>,\n  obj: object\n): M | undefined {\n  let pointer = obj;\n  while (pointer !== undefined && pointer !== null) {\n    const manager = map.get(pointer);\n\n    if (manager !== undefined) {\n      return manager;\n    }\n\n    pointer = getPrototypeOf(pointer);\n  }\n\n  return undefined;\n}\n\n///////////\n\nexport function setInternalModifierManager<T extends object>(\n  manager: InternalModifierManager,\n  definition: T\n): T {\n  return setManager(MODIFIER_MANAGERS, manager, definition);\n}\n\nexport function getInternalModifierManager(definition: object): InternalModifierManager;\nexport function getInternalModifierManager(\n  definition: object,\n  isOptional: true | undefined\n): InternalModifierManager | null;\nexport function getInternalModifierManager(\n  definition: object,\n  isOptional?: true | undefined\n): InternalModifierManager | null {\n  if (\n    import.meta.env.DEV &&\n    typeof definition !== 'function' &&\n    (typeof definition !== 'object' || definition === null)\n  ) {\n    throw new Error(\n      `Attempted to use a value as a modifier, but it was not an object or function. Modifier definitions must be objects or functions with an associated modifier manager. The value was: ${definition}`\n    );\n  }\n\n  const manager = getManager(MODIFIER_MANAGERS, definition)!;\n\n  if (manager === undefined) {\n    if (isOptional === true) {\n      return null;\n    } else if (import.meta.env.DEV) {\n      throw new Error(\n        `Attempted to load a modifier, but there wasn't a modifier manager associated with the definition. The definition was: ${debugToString!(\n          definition\n        )}`\n      );\n    }\n  }\n\n  return manager;\n}\n\nexport function setInternalHelperManager<T extends object, O extends Owner>(\n  manager: CustomHelperManager<O> | Helper<O>,\n  definition: T\n): T {\n  return setManager(HELPER_MANAGERS, manager, definition);\n}\n\nconst DEFAULT_MANAGER = new CustomHelperManager(() => new FunctionHelperManager());\n\nexport function getInternalHelperManager(definition: object): CustomHelperManager | Helper;\nexport function getInternalHelperManager(\n  definition: object,\n  isOptional: true | undefined\n): CustomHelperManager | Helper | null;\nexport function getInternalHelperManager(\n  definition: object,\n  isOptional?: true | undefined\n): CustomHelperManager | Helper | null {\n  if (\n    import.meta.env.DEV &&\n    typeof definition !== 'function' &&\n    (typeof definition !== 'object' || definition === null)\n  ) {\n    throw new Error(\n      `Attempted to use a value as a helper, but it was not an object or function. Helper definitions must be objects or functions with an associated helper manager. The value was: ${definition}`\n    );\n  }\n\n  let manager = getManager(HELPER_MANAGERS, definition);\n\n  // Functions are special-cased because functions are defined\n  // as the \"default\" helper, per: https://github.com/emberjs/rfcs/pull/756\n  if (manager === undefined && typeof definition === 'function') {\n    manager = DEFAULT_MANAGER;\n  }\n\n  if (manager) {\n    return manager;\n  } else if (isOptional === true) {\n    return null;\n  } else if (import.meta.env.DEV) {\n    throw new Error(\n      `Attempted to load a helper, but there wasn't a helper manager associated with the definition. The definition was: ${debugToString!(\n        definition\n      )}`\n    );\n  }\n\n  return null;\n}\n\nexport function setInternalComponentManager<T extends object>(\n  factory: InternalComponentManager,\n  obj: T\n): T {\n  return setManager(COMPONENT_MANAGERS, factory, obj);\n}\n\nexport function getInternalComponentManager(definition: object): InternalComponentManager;\nexport function getInternalComponentManager(\n  definition: object,\n  isOptional: true | undefined\n): InternalComponentManager | null;\nexport function getInternalComponentManager(\n  definition: object,\n  isOptional?: true | undefined\n): InternalComponentManager | null {\n  if (\n    import.meta.env.DEV &&\n    typeof definition !== 'function' &&\n    (typeof definition !== 'object' || definition === null)\n  ) {\n    throw new Error(\n      `Attempted to use a value as a component, but it was not an object or function. Component definitions must be objects or functions with an associated component manager. The value was: ${definition}`\n    );\n  }\n\n  const manager = getManager(COMPONENT_MANAGERS, definition)!;\n\n  if (manager === undefined) {\n    if (isOptional === true) {\n      return null;\n    } else if (import.meta.env.DEV) {\n      throw new Error(\n        `Attempted to load a component, but there wasn't a component manager associated with the definition. The definition was: ${debugToString!(\n          definition\n        )}`\n      );\n    }\n  }\n\n  return manager;\n}\n\n///////////\n\nexport function hasInternalComponentManager(definition: object): boolean {\n  return (\n    hasDefaultComponentManager(definition) ||\n    getManager(COMPONENT_MANAGERS, definition) !== undefined\n  );\n}\n\nexport function hasInternalHelperManager(definition: object): boolean {\n  return (\n    hasDefaultHelperManager(definition) || getManager(HELPER_MANAGERS, definition) !== undefined\n  );\n}\n\nexport function hasInternalModifierManager(definition: object): boolean {\n  return (\n    hasDefaultModifierManager(definition) || getManager(MODIFIER_MANAGERS, definition) !== undefined\n  );\n}\n\nfunction hasDefaultComponentManager(_definition: object): boolean {\n  return false;\n}\n\nfunction hasDefaultHelperManager(definition: object): boolean {\n  return typeof definition === 'function';\n}\n\nfunction hasDefaultModifierManager(_definition: object): boolean {\n  return false;\n}\n","import type {\n  Arguments,\n  ComponentCapabilities,\n  ComponentCapabilitiesVersions,\n  ComponentDefinitionState,\n  ComponentManager,\n  ComponentManagerWithAsyncLifeCycleCallbacks,\n  ComponentManagerWithAsyncUpdateHook,\n  ComponentManagerWithDestructors,\n  ComponentManagerWithUpdateHook,\n  Destroyable,\n  InternalComponentCapabilities,\n  InternalComponentManager,\n  Nullable,\n  Owner,\n  VMArguments,\n} from '@glimmer/interfaces';\nimport type { Reference } from '@glimmer/reference';\nimport { registerDestructor } from '@glimmer/destroyable';\nimport { createConstRef } from '@glimmer/reference';\n\nimport type { ManagerFactory } from './api';\n\nimport { argsProxyFor } from '../util/args-proxy';\nimport { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';\n\nconst CAPABILITIES = {\n  dynamicLayout: false,\n  dynamicTag: false,\n  prepareArgs: false,\n  createArgs: true,\n  attributeHook: false,\n  elementHook: false,\n  createCaller: false,\n  dynamicScope: true,\n  updateHook: true,\n  createInstance: true,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport function componentCapabilities<Version extends keyof ComponentCapabilitiesVersions>(\n  managerAPI: Version,\n  options: ComponentCapabilitiesVersions[Version] = {}\n): ComponentCapabilities {\n  if (import.meta.env.DEV && managerAPI !== '3.13') {\n    throw new Error('Invalid component manager compatibility specified');\n  }\n\n  let updateHook = Boolean((options as ComponentCapabilitiesVersions['3.13']).updateHook);\n\n  return buildCapabilities({\n    asyncLifeCycleCallbacks: Boolean(options.asyncLifecycleCallbacks),\n    destructor: Boolean(options.destructor),\n    updateHook,\n  });\n}\n\nexport function hasAsyncLifeCycleCallbacks<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithAsyncLifeCycleCallbacks<ComponentInstance> {\n  return delegate.capabilities.asyncLifeCycleCallbacks;\n}\n\nexport function hasUpdateHook<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithUpdateHook<ComponentInstance> {\n  return delegate.capabilities.updateHook;\n}\n\nexport function hasAsyncUpdateHook<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithAsyncUpdateHook<ComponentInstance> {\n  return hasAsyncLifeCycleCallbacks(delegate) && hasUpdateHook(delegate);\n}\n\nexport function hasDestructors<ComponentInstance>(\n  delegate: ComponentManager<ComponentInstance>\n): delegate is ComponentManagerWithDestructors<ComponentInstance> {\n  return delegate.capabilities.destructor;\n}\n\n/**\n  The CustomComponentManager allows addons to provide custom component\n  implementations that integrate seamlessly into Ember. This is accomplished\n  through a delegate, registered with the custom component manager, which\n  implements a set of hooks that determine component behavior.\n\n  To create a custom component manager, instantiate a new CustomComponentManager\n  class and pass the delegate as the first argument:\n\n  ```js\n  let manager = new CustomComponentManager({\n    // ...delegate implementation...\n  });\n  ```\n\n  ## Delegate Hooks\n\n  Throughout the lifecycle of a component, the component manager will invoke\n  delegate hooks that are responsible for surfacing those lifecycle changes to\n  the end developer.\n\n  * `create()` - invoked when a new instance of a component should be created\n  * `update()` - invoked when the arguments passed to a component change\n  * `getContext()` - returns the object that should be\n*/\nexport class CustomComponentManager<O extends Owner, ComponentInstance>\n  implements InternalComponentManager<CustomComponentState<ComponentInstance>>\n{\n  private componentManagerDelegates = new WeakMap<O, ComponentManager<ComponentInstance>>();\n\n  constructor(private factory: ManagerFactory<O, ComponentManager<ComponentInstance>>) {}\n\n  private getDelegateFor(owner: O) {\n    let { componentManagerDelegates } = this;\n    let delegate = componentManagerDelegates.get(owner);\n\n    if (delegate === undefined) {\n      let { factory } = this;\n      delegate = factory(owner);\n\n      if (import.meta.env.DEV && !FROM_CAPABILITIES!.has(delegate.capabilities)) {\n        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200\n        throw new Error(\n          `Custom component managers must have a \\`capabilities\\` property that is the result of calling the \\`capabilities('3.13')\\` (imported via \\`import { capabilities } from '@ember/component';\\`). Received: \\`${JSON.stringify(\n            delegate.capabilities\n          )}\\` for: \\`${delegate}\\``\n        );\n      }\n\n      componentManagerDelegates.set(owner, delegate);\n    }\n\n    return delegate;\n  }\n\n  create(\n    owner: O,\n    definition: ComponentDefinitionState,\n    vmArgs: VMArguments\n  ): CustomComponentState<ComponentInstance> {\n    let delegate = this.getDelegateFor(owner);\n    let args = argsProxyFor(vmArgs.capture(), 'component');\n\n    let component: ComponentInstance = delegate.createComponent(definition, args);\n\n    return new CustomComponentState(component, delegate, args);\n  }\n\n  getDebugName(definition: ComponentDefinitionState): string {\n    return typeof definition === 'function' ? definition.name : definition.toString();\n  }\n\n  update(bucket: CustomComponentState<ComponentInstance>): void {\n    let { delegate } = bucket;\n    if (hasUpdateHook(delegate)) {\n      let { component, args } = bucket;\n\n      delegate.updateComponent(component, args);\n    }\n  }\n\n  didCreate({ component, delegate }: CustomComponentState<ComponentInstance>): void {\n    if (hasAsyncLifeCycleCallbacks(delegate)) {\n      delegate.didCreateComponent(component);\n    }\n  }\n\n  didUpdate({ component, delegate }: CustomComponentState<ComponentInstance>): void {\n    if (hasAsyncUpdateHook(delegate)) {\n      delegate.didUpdateComponent(component);\n    }\n  }\n\n  didRenderLayout(): void {}\n\n  didUpdateLayout(): void {}\n\n  getSelf({ component, delegate }: CustomComponentState<ComponentInstance>): Reference {\n    return createConstRef(delegate.getContext(component), 'this');\n  }\n\n  getDestroyable(bucket: CustomComponentState<ComponentInstance>): Nullable<Destroyable> {\n    const { delegate } = bucket;\n\n    if (hasDestructors(delegate)) {\n      const { component } = bucket;\n\n      registerDestructor(bucket, () => delegate.destroyComponent(component));\n      return bucket;\n    }\n\n    return null;\n  }\n\n  getCapabilities(): InternalComponentCapabilities {\n    return CAPABILITIES;\n  }\n}\n\n/**\n * Stores internal state about a component instance after it's been created.\n */\nexport class CustomComponentState<ComponentInstance> {\n  constructor(\n    public component: ComponentInstance,\n    public delegate: ComponentManager<ComponentInstance>,\n    public args: Arguments\n  ) {}\n}\n","import type {\n  Arguments,\n  CapturedArguments,\n  InternalModifierManager,\n  ModifierCapabilities,\n  ModifierCapabilitiesVersions,\n  ModifierManager,\n  Owner,\n  SimpleElement,\n  UpdatableTag,\n} from '@glimmer/interfaces';\nimport { registerDestructor } from '@glimmer/destroyable';\nimport { valueForRef } from '@glimmer/reference';\nimport { castToBrowser, dict } from '@glimmer/util';\nimport { createUpdatableTag, untrack } from '@glimmer/validator';\n\nimport type { ManagerFactory } from '.';\n\nimport { argsProxyFor } from '../util/args-proxy';\nimport { buildCapabilities, FROM_CAPABILITIES } from '../util/capabilities';\n\nexport function modifierCapabilities<Version extends keyof ModifierCapabilitiesVersions>(\n  managerAPI: Version,\n  optionalFeatures: ModifierCapabilitiesVersions[Version] = {}\n): ModifierCapabilities {\n  if (import.meta.env.DEV && managerAPI !== '3.22') {\n    throw new Error('Invalid modifier manager compatibility specified');\n  }\n\n  return buildCapabilities({\n    disableAutoTracking: Boolean(optionalFeatures.disableAutoTracking),\n  });\n}\n\nexport interface CustomModifierState<ModifierInstance> {\n  tag: UpdatableTag;\n  element: SimpleElement;\n  modifier: ModifierInstance;\n  delegate: ModifierManager<ModifierInstance>;\n  args: Arguments;\n  debugName?: string;\n}\n\n/**\n  The CustomModifierManager allows addons to provide custom modifier\n  implementations that integrate seamlessly into Ember. This is accomplished\n  through a delegate, registered with the custom modifier manager, which\n  implements a set of hooks that determine modifier behavior.\n  To create a custom modifier manager, instantiate a new CustomModifierManager\n  class and pass the delegate as the first argument:\n\n  ```js\n  let manager = new CustomModifierManager({\n    // ...delegate implementation...\n  });\n  ```\n\n  ## Delegate Hooks\n\n  Throughout the lifecycle of a modifier, the modifier manager will invoke\n  delegate hooks that are responsible for surfacing those lifecycle changes to\n  the end developer.\n  * `createModifier()` - invoked when a new instance of a modifier should be created\n  * `installModifier()` - invoked when the modifier is installed on the element\n  * `updateModifier()` - invoked when the arguments passed to a modifier change\n  * `destroyModifier()` - invoked when the modifier is about to be destroyed\n*/\nexport class CustomModifierManager<O extends Owner, ModifierInstance>\n  implements InternalModifierManager<CustomModifierState<ModifierInstance>>\n{\n  private componentManagerDelegates = new WeakMap<O, ModifierManager<ModifierInstance>>();\n\n  constructor(private factory: ManagerFactory<O, ModifierManager<ModifierInstance>>) {}\n\n  private getDelegateFor(owner: O) {\n    let { componentManagerDelegates } = this;\n    let delegate = componentManagerDelegates.get(owner);\n\n    if (delegate === undefined) {\n      let { factory } = this;\n      delegate = factory(owner);\n\n      if (import.meta.env.DEV && !FROM_CAPABILITIES!.has(delegate.capabilities)) {\n        // TODO: This error message should make sense in both Ember and Glimmer https://github.com/glimmerjs/glimmer-vm/issues/1200\n        throw new Error(\n          `Custom modifier managers must have a \\`capabilities\\` property that is the result of calling the \\`capabilities('3.22')\\` (imported via \\`import { capabilities } from '@ember/modifier';\\`). Received: \\`${JSON.stringify(\n            delegate.capabilities\n          )}\\` for: \\`${delegate}\\``\n        );\n      }\n\n      componentManagerDelegates.set(owner, delegate);\n    }\n\n    return delegate;\n  }\n\n  create(owner: O, element: SimpleElement, definition: object, capturedArgs: CapturedArguments) {\n    let delegate = this.getDelegateFor(owner);\n\n    let args = argsProxyFor(capturedArgs, 'modifier');\n    let instance: ModifierInstance = delegate.createModifier(definition, args);\n\n    let tag = createUpdatableTag();\n    let state: CustomModifierState<ModifierInstance>;\n\n    state = {\n      tag,\n      element,\n      delegate,\n      args,\n      modifier: instance,\n    };\n\n    registerDestructor(state, () => delegate.destroyModifier(instance, args));\n\n    return state;\n  }\n\n  getDebugName(definition: object) {\n    if (typeof definition === 'function') {\n      return definition.name || definition.toString();\n    } else {\n      return '<unknown>';\n    }\n  }\n\n  getDebugInstance({ modifier }: CustomModifierState<ModifierInstance>) {\n    return modifier;\n  }\n\n  getTag({ tag }: CustomModifierState<ModifierInstance>) {\n    return tag;\n  }\n\n  install({ element, args, modifier, delegate }: CustomModifierState<ModifierInstance>) {\n    let { capabilities } = delegate;\n\n    if (capabilities.disableAutoTracking === true) {\n      untrack(() => delegate.installModifier(modifier, castToBrowser(element, 'ELEMENT'), args));\n    } else {\n      delegate.installModifier(modifier, castToBrowser(element, 'ELEMENT'), args);\n    }\n  }\n\n  update({ args, modifier, delegate }: CustomModifierState<ModifierInstance>) {\n    let { capabilities } = delegate;\n\n    if (capabilities.disableAutoTracking === true) {\n      untrack(() => delegate.updateModifier(modifier, args));\n    } else {\n      delegate.updateModifier(modifier, args);\n    }\n  }\n\n  getDestroyable(state: CustomModifierState<ModifierInstance>) {\n    return state;\n  }\n}\n\nexport function reifyArgs({ named, positional }: CapturedArguments): {\n  named: Record<string, unknown>;\n  positional: unknown[];\n} {\n  let reifiedNamed = dict();\n\n  for (const [key, value] of Object.entries(named)) {\n    reifiedNamed[key] = valueForRef(value);\n  }\n\n  let reifiedPositional = positional.map(valueForRef);\n\n  return {\n    named: reifiedNamed,\n    positional: reifiedPositional,\n  };\n}\n","import type { ComponentManager, HelperManager, ModifierManager, Owner } from '@glimmer/interfaces';\n\nimport {\n  setInternalComponentManager,\n  setInternalHelperManager,\n  setInternalModifierManager,\n} from '../internal/api';\nimport { CustomComponentManager } from './component';\nimport { CustomHelperManager } from './helper';\nimport { CustomModifierManager } from './modifier';\n\ntype Manager = ComponentManager<unknown> | ModifierManager<unknown> | HelperManager<unknown>;\n\nexport type ManagerFactory<O, D extends Manager = Manager> = (owner: O) => D;\n\nexport function setComponentManager<O extends Owner, T extends object>(\n  factory: ManagerFactory<O, ComponentManager<unknown>>,\n  obj: T\n): T {\n  return setInternalComponentManager(new CustomComponentManager(factory), obj);\n}\n\nexport function setModifierManager<O extends Owner, T extends object>(\n  factory: ManagerFactory<O, ModifierManager<unknown>>,\n  obj: T\n): T {\n  return setInternalModifierManager(new CustomModifierManager(factory), obj);\n}\n\nexport function setHelperManager<O extends Owner, T extends object>(\n  factory: ManagerFactory<O | undefined, HelperManager<unknown>>,\n  obj: T\n): T {\n  return setInternalHelperManager(new CustomHelperManager(factory), obj);\n}\n","import type { TemplateFactory } from '@glimmer/interfaces';\nimport { debugToString } from '@glimmer/util';\n\nconst TEMPLATES: WeakMap<object, TemplateFactory> = new WeakMap();\n\nconst getPrototypeOf = Object.getPrototypeOf;\n\nexport function setComponentTemplate(factory: TemplateFactory, obj: object) {\n  if (\n    import.meta.env.DEV &&\n    !(obj !== null && (typeof obj === 'object' || typeof obj === 'function'))\n  ) {\n    throw new Error(`Cannot call \\`setComponentTemplate\\` on \\`${debugToString!(obj)}\\``);\n  }\n\n  if (import.meta.env.DEV && TEMPLATES.has(obj)) {\n    throw new Error(\n      `Cannot call \\`setComponentTemplate\\` multiple times on the same class (\\`${debugToString!(\n        obj\n      )}\\`)`\n    );\n  }\n\n  TEMPLATES.set(obj, factory);\n\n  return obj;\n}\n\nexport function getComponentTemplate(obj: object): TemplateFactory | undefined {\n  let pointer = obj;\n\n  while (pointer !== null) {\n    let template = TEMPLATES.get(pointer);\n\n    if (template !== undefined) {\n      return template;\n    }\n\n    pointer = getPrototypeOf(pointer);\n  }\n\n  return undefined;\n}\n"],"names":["CUSTOM_TAG_FOR","WeakMap","getCustomTagFor","obj","get","setCustomTagFor","customTagFn","set","convertToInt","prop","num","Number","isNaN","NamedArgsProxy","constructor","named","this","_target","ref","undefined","valueForRef","has","ownKeys","Object","keys","isExtensible","getOwnPropertyDescriptor","enumerable","configurable","PositionalArgsProxy","positional","target","length","parsed","argsProxyFor","capturedArgs","type","namedHandler","positionalHandler","namedTarget","create","namedProxy","Proxy","positionalProxy","getNamedTag","_obj","key","namedArgs","track","tagForNamedArg","getPositionalTag","positionalArgs","forEach","tagForPositionalArg","Array","Op","Size","fill","EMPTY","InternalComponentCapabilities","Empty","capabilityFlagsFrom","capabilities","capability","managerHasCapability","_manager","hasCapability","helperCapabilities","managerAPI","options","hasValue","Boolean","hasDestroyable","hasScheduledEffect","manager","CustomHelperManager","factory","helperManagerDelegates","undefinedDelegate","getDelegateForOwner","owner","delegate","getDelegateFor","getHelper","definition","args","bucket","createHelper","cache","createComputeRef","getValue","associateDestroyableChild","getDestroyable","createConstRef","UNDEFINED_REFERENCE","FunctionHelperManager","fn","getDebugName","name","COMPONENT_MANAGERS","MODIFIER_MANAGERS","HELPER_MANAGERS","getPrototypeOf","setManager","map","getManager","pointer","setInternalModifierManager","getInternalModifierManager","isOptional","setInternalHelperManager","DEFAULT_MANAGER","getInternalHelperManager","setInternalComponentManager","getInternalComponentManager","hasInternalComponentManager","hasInternalHelperManager","hasDefaultHelperManager","hasInternalModifierManager","CAPABILITIES","dynamicLayout","dynamicTag","prepareArgs","createArgs","attributeHook","elementHook","createCaller","dynamicScope","updateHook","createInstance","wrapped","willDestroy","hasSubOwner","componentCapabilities","asyncLifeCycleCallbacks","asyncLifecycleCallbacks","destructor","hasAsyncLifeCycleCallbacks","hasUpdateHook","CustomComponentManager","componentManagerDelegates","vmArgs","capture","component","createComponent","CustomComponentState","toString","update","updateComponent","didCreate","didCreateComponent","didUpdate","hasAsyncUpdateHook","didUpdateComponent","didRenderLayout","didUpdateLayout","getSelf","getContext","hasDestructors","registerDestructor","destroyComponent","getCapabilities","modifierCapabilities","optionalFeatures","disableAutoTracking","CustomModifierManager","element","state","instance","createModifier","tag","createUpdatableTag","modifier","destroyModifier","getDebugInstance","getTag","install","untrack","installModifier","castToBrowser","updateModifier","setComponentManager","setModifierManager","setHelperManager","TEMPLATES","setComponentTemplate","getComponentTemplate","template"],"mappings":"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"}