{"version":3,"file":"index.js","sources":["../../lib/compiler.ts","../../lib/opcode-builder/helpers/resolution.ts","../../../debug/lib/opcode-metadata.ts","../../lib/opcode-builder/opcodes.ts","../../lib/opcode-builder/operands.ts","../../lib/opcode-builder/encoder.ts","../../lib/compilable-template.ts","../../lib/opcode-builder/stdlib.ts","../../lib/utils.ts","../../lib/opcode-builder/helpers/vm.ts","../../lib/syntax/compilers.ts","../../lib/syntax/expressions.ts","../../lib/opcode-builder/helpers/expr.ts","../../lib/opcode-builder/helpers/shared.ts","../../lib/opcode-builder/helpers/blocks.ts","../../lib/opcode-builder/helpers/conditional.ts","../../lib/opcode-builder/helpers/components.ts","../../lib/opcode-builder/helpers/stdlib.ts","../../lib/program-context.ts","../../lib/opcode-builder/context.ts","../../lib/syntax/statements.ts","../../lib/opcode-builder/delegate.ts","../../lib/wrapped-component.ts","../../lib/template.ts"],"sourcesContent":["import type { HandleResult, TemplateCompilationContext } from '@glimmer/interfaces';\nimport { debugSlice } from '@glimmer/debug';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { extractHandle } from '@glimmer/util';\n\nexport let debugCompiler: (context: TemplateCompilationContext, handle: HandleResult) => void;\n\nif (LOCAL_SHOULD_LOG) {\n  debugCompiler = (context: TemplateCompilationContext, result: HandleResult) => {\n    let handle = extractHandle(result);\n    let { heap } = context.program;\n    let start = heap.getaddr(handle);\n    let end = start + heap.sizeof(handle);\n\n    debugSlice(context, start, end);\n  };\n}\n","import type {\n  CompileTimeConstants,\n  CompileTimeResolver,\n  ContainingMetadata,\n  Expressions,\n  Owner,\n  ResolutionTimeConstants,\n  ResolveComponentOp,\n  ResolveComponentOrHelperOp,\n  ResolveHelperOp,\n  ResolveModifierOp,\n  ResolveOptionalComponentOrHelperOp,\n  SexpOpcode,\n} from '@glimmer/interfaces';\nimport { assert, debugToString, expect, unwrap } from '@glimmer/util';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nfunction isGetLikeTuple(opcode: Expressions.Expression): opcode is Expressions.TupleExpression {\n  return Array.isArray(opcode) && opcode.length === 2;\n}\n\nfunction makeResolutionTypeVerifier(typeToVerify: SexpOpcode) {\n  return (\n    opcode: Expressions.Expression\n  ): opcode is Expressions.GetFree | Expressions.GetLexicalSymbol => {\n    if (!isGetLikeTuple(opcode)) return false;\n\n    let type = opcode[0];\n\n    return (\n      type === SexpOpcodes.GetStrictKeyword ||\n      type === SexpOpcodes.GetLexicalSymbol ||\n      type === typeToVerify\n    );\n  };\n}\n\nexport const isGetFreeComponent = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsComponentHead);\n\nexport const isGetFreeModifier = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsModifierHead);\n\nexport const isGetFreeHelper = makeResolutionTypeVerifier(SexpOpcodes.GetFreeAsHelperHead);\n\nexport const isGetFreeComponentOrHelper = makeResolutionTypeVerifier(\n  SexpOpcodes.GetFreeAsComponentOrHelperHead\n);\n\ninterface ResolvedContainingMetadata extends ContainingMetadata {\n  owner: Owner;\n  upvars: string[];\n}\n\nfunction assertResolverInvariants(meta: ContainingMetadata): ResolvedContainingMetadata {\n  if (import.meta.env.DEV) {\n    if (!meta.upvars) {\n      throw new Error(\n        'Attempted to resolve a component, helper, or modifier, but no free vars were found'\n      );\n    }\n\n    if (!meta.owner) {\n      throw new Error(\n        'Attempted to resolve a component, helper, or modifier, but no owner was associated with the template it was being resolved from'\n      );\n    }\n  }\n\n  return meta as unknown as ResolvedContainingMetadata;\n}\n\n/**\n * <Foo/>\n * <Foo></Foo>\n * <Foo @arg={{true}} />\n */\nexport function resolveComponent(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, then]: ResolveComponentOp\n): void {\n  assert(isGetFreeComponent(expr), 'Attempted to resolve a component with incorrect opcode');\n\n  let type = expr[0];\n\n  if (import.meta.env.DEV && expr[0] === SexpOpcodes.GetStrictKeyword) {\n    assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n    throw new Error(\n      `Attempted to resolve a component in a strict mode template, but that value was not in scope: ${\n        meta.upvars![expr[1]] ?? '{unknown variable}'\n      }`\n    );\n  }\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues, owner } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(\n      constants.component(\n        definition as object,\n        expect(owner, 'BUG: expected owner when resolving component definition')\n      )\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver.lookupComponent(name, owner)!;\n\n    if (import.meta.env.DEV && (typeof definition !== 'object' || definition === null)) {\n      assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a component, but nothing was found.`\n      );\n    }\n\n    then(constants.resolvedComponent(definition, name));\n  }\n}\n\n/**\n * (helper)\n * (helper arg)\n */\nexport function resolveHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, then]: ResolveHelperOp\n): void {\n  assert(isGetFreeHelper(expr), 'Attempted to resolve a helper with incorrect opcode');\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(constants.helper(definition as object));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    then(\n      lookupBuiltInHelper(expr as Expressions.GetStrictFree, resolver, meta, constants, 'helper')\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let helper = resolver.lookupHelper(name, owner)!;\n\n    if (import.meta.env.DEV && helper === null) {\n      assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a helper, but nothing was found.`\n      );\n    }\n\n    then(constants.helper(helper, name));\n  }\n}\n\n/**\n * <div {{modifier}}/>\n * <div {{modifier arg}}/>\n * <Foo {{modifier}}/>\n */\nexport function resolveModifier(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, then]: ResolveModifierOp\n): void {\n  assert(isGetFreeModifier(expr), 'Attempted to resolve a modifier with incorrect opcode');\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    then(constants.modifier(definition as object));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    let { upvars } = assertResolverInvariants(meta);\n    let name = unwrap(upvars[expr[1]]);\n    let modifier = resolver.lookupBuiltInModifier(name);\n\n    if (import.meta.env.DEV && modifier === null) {\n      assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n      throw new Error(\n        `Attempted to resolve a modifier in a strict mode template, but it was not in scope: ${name}`\n      );\n    }\n\n    then(constants.modifier(modifier!, name));\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n    let name = unwrap(upvars[expr[1]]);\n    let modifier = resolver.lookupModifier(name, owner)!;\n\n    if (import.meta.env.DEV && modifier === null) {\n      assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n      throw new Error(\n        `Attempted to resolve \\`${name}\\`, which was expected to be a modifier, but nothing was found.`\n      );\n    }\n\n    then(constants.modifier(modifier, name));\n  }\n}\n\n/**\n * {{component-or-helper arg}}\n */\nexport function resolveComponentOrHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, { ifComponent, ifHelper }]: ResolveComponentOrHelperOp\n): void {\n  assert(\n    isGetFreeComponentOrHelper(expr),\n    'Attempted to resolve a component or helper with incorrect opcode'\n  );\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues, owner } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    let component = constants.component(\n      definition as object,\n      expect(owner, 'BUG: expected owner when resolving component definition'),\n      true\n    );\n\n    if (component !== null) {\n      ifComponent(component);\n      return;\n    }\n\n    let helper = constants.helper(definition as object, null, true);\n\n    if (import.meta.env.DEV && helper === null) {\n      assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n      throw new Error(\n        `Attempted to use a value as either a component or helper, but it did not have a component manager or helper manager associated with it. The value was: ${debugToString!(\n          definition\n        )}`\n      );\n    }\n\n    ifHelper(expect(helper, 'BUG: helper must exist'));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    ifHelper(\n      lookupBuiltInHelper(\n        expr as Expressions.GetStrictFree,\n        resolver,\n        meta,\n        constants,\n        'component or helper'\n      )\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver.lookupComponent(name, owner);\n\n    if (definition !== null) {\n      ifComponent(constants.resolvedComponent(definition, name));\n    } else {\n      let helper = resolver.lookupHelper(name, owner);\n\n      if (import.meta.env.DEV && helper === null) {\n        assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n        throw new Error(\n          `Attempted to resolve \\`${name}\\`, which was expected to be a component or helper, but nothing was found.`\n        );\n      }\n\n      ifHelper(constants.helper(helper!, name));\n    }\n  }\n}\n\n/**\n * {{maybeHelperOrComponent}}\n */\nexport function resolveOptionalComponentOrHelper(\n  resolver: CompileTimeResolver,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  meta: ContainingMetadata,\n  [, expr, { ifComponent, ifHelper, ifValue }]: ResolveOptionalComponentOrHelperOp\n): void {\n  assert(\n    isGetFreeComponentOrHelper(expr),\n    'Attempted to resolve an optional component or helper with incorrect opcode'\n  );\n\n  let type = expr[0];\n\n  if (type === SexpOpcodes.GetLexicalSymbol) {\n    let { scopeValues, owner } = meta;\n    let definition = expect(scopeValues, 'BUG: scopeValues must exist if template symbol is used')[\n      expr[1]\n    ];\n\n    if (\n      typeof definition !== 'function' &&\n      (typeof definition !== 'object' || definition === null)\n    ) {\n      // The value is not an object, so it can't be a component or helper.\n      ifValue(constants.value(definition));\n      return;\n    }\n\n    let component = constants.component(\n      definition,\n      expect(owner, 'BUG: expected owner when resolving component definition'),\n      true\n    );\n\n    if (component !== null) {\n      ifComponent(component);\n      return;\n    }\n\n    let helper = constants.helper(definition, null, true);\n\n    if (helper !== null) {\n      ifHelper(helper);\n      return;\n    }\n\n    ifValue(constants.value(definition));\n  } else if (type === SexpOpcodes.GetStrictKeyword) {\n    ifHelper(\n      lookupBuiltInHelper(expr as Expressions.GetStrictFree, resolver, meta, constants, 'value')\n    );\n  } else {\n    let { upvars, owner } = assertResolverInvariants(meta);\n\n    let name = unwrap(upvars[expr[1]]);\n    let definition = resolver.lookupComponent(name, owner);\n\n    if (definition !== null) {\n      ifComponent(constants.resolvedComponent(definition, name));\n      return;\n    }\n\n    let helper = resolver.lookupHelper(name, owner);\n\n    if (helper !== null) {\n      ifHelper(constants.helper(helper, name));\n    }\n  }\n}\n\nfunction lookupBuiltInHelper(\n  expr: Expressions.GetStrictFree,\n  resolver: CompileTimeResolver,\n  meta: ContainingMetadata,\n  constants: ResolutionTimeConstants,\n  type: string\n): number {\n  let { upvars } = assertResolverInvariants(meta);\n\n  let name = unwrap(upvars[expr[1]]);\n  let helper = resolver.lookupBuiltInHelper(name);\n\n  if (import.meta.env.DEV && helper === null) {\n    assert(!meta.isStrictMode, 'Strict mode errors should already be handled at compile time');\n\n    // Keyword helper did not exist, which means that we're attempting to use a\n    // value of some kind that is not in scope\n    throw new Error(\n      `Attempted to resolve a ${type} in a strict mode template, but that value was not in scope: ${\n        meta.upvars![expr[1]] ?? '{unknown variable}'\n      }`\n    );\n  }\n\n  return constants.helper(helper!, name);\n}\n","/* This file is generated by build/debug.js */\n\nimport type { Nullable, VmMachineOp, VmOp } from '@glimmer/interfaces';\nimport { LOCAL_DEBUG } from '@glimmer/local-debug-flags';\nimport { MachineOp, Op } from '@glimmer/vm';\n\nimport type { NormalizedMetadata } from './metadata';\n\nexport function opcodeMetadata(\n  op: VmMachineOp | VmOp,\n  isMachine: 0 | 1\n): Nullable<NormalizedMetadata> {\n  if (!LOCAL_DEBUG) {\n    return null;\n  }\n\n  let value = isMachine ? MACHINE_METADATA[op] : METADATA[op];\n\n  return value || null;\n}\n\nconst METADATA: Nullable<NormalizedMetadata>[] = new Array(Op.Size).fill(null);\nconst MACHINE_METADATA: Nullable<NormalizedMetadata>[] = new Array(Op.Size).fill(null);\n\nif (LOCAL_DEBUG) {\n  MACHINE_METADATA[MachineOp.PushFrame] = {\n    name: 'PushFrame',\n    mnemonic: 'pushf',\n    before: null,\n    stackChange: 2,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.PopFrame] = {\n    name: 'PopFrame',\n    mnemonic: 'popf',\n    before: null,\n    stackChange: -2,\n    ops: [],\n    operands: 0,\n    check: false,\n  };\n\n  MACHINE_METADATA[MachineOp.InvokeVirtual] = {\n    name: 'InvokeVirtual',\n    mnemonic: 'vcall',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.InvokeStatic] = {\n    name: 'InvokeStatic',\n    mnemonic: 'scall',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'offset',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.Jump] = {\n    name: 'Jump',\n    mnemonic: 'goto',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'to',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  MACHINE_METADATA[MachineOp.Return] = {\n    name: 'Return',\n    mnemonic: 'ret',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: false,\n  };\n\n  MACHINE_METADATA[MachineOp.ReturnTo] = {\n    name: 'ReturnTo',\n    mnemonic: 'setra',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'offset',\n        type: 'i32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n  METADATA[Op.Helper] = {\n    name: 'Helper',\n    mnemonic: 'ncall',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'helper',\n        type: 'handle',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.DynamicHelper] = {\n    name: 'DynamicHelper',\n    mnemonic: 'dynamiccall',\n    before: null,\n    stackChange: null,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.SetNamedVariables] = {\n    name: 'SetNamedVariables',\n    mnemonic: 'vsargs',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetBlocks] = {\n    name: 'SetBlocks',\n    mnemonic: 'vbblocks',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetVariable] = {\n    name: 'SetVariable',\n    mnemonic: 'sbvar',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'symbol',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetBlock] = {\n    name: 'SetBlock',\n    mnemonic: 'sblock',\n    before: null,\n    stackChange: -3,\n    ops: [\n      {\n        name: 'symbol',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetVariable] = {\n    name: 'GetVariable',\n    mnemonic: 'symload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'symbol',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetProperty] = {\n    name: 'GetProperty',\n    mnemonic: 'getprop',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'property',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetBlock] = {\n    name: 'GetBlock',\n    mnemonic: 'blockload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'block',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SpreadBlock] = {\n    name: 'SpreadBlock',\n    mnemonic: 'blockspread',\n    before: null,\n    stackChange: 2,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.HasBlock] = {\n    name: 'HasBlock',\n    mnemonic: 'hasblockload',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.HasBlockParams] = {\n    name: 'HasBlockParams',\n    mnemonic: 'hasparamsload',\n    before: null,\n    stackChange: -2,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Concat] = {\n    name: 'Concat',\n    mnemonic: 'concat',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.IfInline] = {\n    name: 'IfInline',\n    mnemonic: 'ifinline',\n    before: null,\n    stackChange: -2,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Not] = {\n    name: 'Not',\n    mnemonic: 'not',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Constant] = {\n    name: 'Constant',\n    mnemonic: 'rconstload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'constant',\n        type: 'unknown',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ConstantReference] = {\n    name: 'ConstantReference',\n    mnemonic: 'rconstrefload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'constant',\n        type: 'unknown',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Primitive] = {\n    name: 'Primitive',\n    mnemonic: 'pconstload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'constant',\n        type: 'primitive',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PrimitiveReference] = {\n    name: 'PrimitiveReference',\n    mnemonic: 'ptoref',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.ReifyU32] = {\n    name: 'ReifyU32',\n    mnemonic: 'reifyload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Dup] = {\n    name: 'Dup',\n    mnemonic: 'dup',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n      {\n        name: 'offset',\n        type: 'u32',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.Pop] = {\n    name: 'Pop',\n    mnemonic: 'pop',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'count',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: false,\n  };\n\n  METADATA[Op.Load] = {\n    name: 'Load',\n    mnemonic: 'put',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Fetch] = {\n    name: 'Fetch',\n    mnemonic: 'regload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.RootScope] = {\n    name: 'RootScope',\n    mnemonic: 'rscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'symbols',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.VirtualRootScope] = {\n    name: 'VirtualRootScope',\n    mnemonic: 'vrscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'register',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ChildScope] = {\n    name: 'ChildScope',\n    mnemonic: 'cscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopScope] = {\n    name: 'PopScope',\n    mnemonic: 'scopepop',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Text] = {\n    name: 'Text',\n    mnemonic: 'apnd_text',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'contents',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Comment] = {\n    name: 'Comment',\n    mnemonic: 'apnd_comment',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'contents',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.AppendHTML] = {\n    name: 'AppendHTML',\n    mnemonic: 'apnd_dynhtml',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendSafeHTML] = {\n    name: 'AppendSafeHTML',\n    mnemonic: 'apnd_dynshtml',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendDocumentFragment] = {\n    name: 'AppendDocumentFragment',\n    mnemonic: 'apnd_dynfrag',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendNode] = {\n    name: 'AppendNode',\n    mnemonic: 'apnd_dynnode',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.AppendText] = {\n    name: 'AppendText',\n    mnemonic: 'apnd_dyntext',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.OpenElement] = {\n    name: 'OpenElement',\n    mnemonic: 'apnd_tag',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'tag',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.OpenDynamicElement] = {\n    name: 'OpenDynamicElement',\n    mnemonic: 'apnd_dyntag',\n    before: null,\n    stackChange: -1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PushRemoteElement] = {\n    name: 'PushRemoteElement',\n    mnemonic: 'apnd_remotetag',\n    before: null,\n    stackChange: -3,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.StaticAttr] = {\n    name: 'StaticAttr',\n    mnemonic: 'apnd_attr',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'name',\n        type: 'str',\n      },\n      {\n        name: 'value',\n        type: 'str',\n      },\n      {\n        name: 'namespace',\n        type: 'option-str',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.DynamicAttr] = {\n    name: 'DynamicAttr',\n    mnemonic: 'apnd_dynattr',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'name',\n        type: 'str',\n      },\n      {\n        name: 'trusting',\n        type: 'bool',\n      },\n      {\n        name: 'namespace',\n        type: 'option-str',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.ComponentAttr] = {\n    name: 'ComponentAttr',\n    mnemonic: 'apnd_cattr',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'name',\n        type: 'str',\n      },\n      {\n        name: 'trusting',\n        type: 'bool',\n      },\n      {\n        name: 'namespace',\n        type: 'option-str',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.FlushElement] = {\n    name: 'FlushElement',\n    mnemonic: 'apnd_flushtag',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CloseElement] = {\n    name: 'CloseElement',\n    mnemonic: 'apnd_closetag',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopRemoteElement] = {\n    name: 'PopRemoteElement',\n    mnemonic: 'apnd_closeremotetag',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Modifier] = {\n    name: 'Modifier',\n    mnemonic: 'apnd_modifier',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'helper',\n        type: 'handle',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.BindDynamicScope] = {\n    name: 'BindDynamicScope',\n    mnemonic: 'setdynscope',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'names',\n        type: 'str-array',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushDynamicScope] = {\n    name: 'PushDynamicScope',\n    mnemonic: 'dynscopepush',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopDynamicScope] = {\n    name: 'PopDynamicScope',\n    mnemonic: 'dynscopepop',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CompileBlock] = {\n    name: 'CompileBlock',\n    mnemonic: 'cmpblock',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PushBlockScope] = {\n    name: 'PushBlockScope',\n    mnemonic: 'scopeload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'scope',\n        type: 'scope',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushSymbolTable] = {\n    name: 'PushSymbolTable',\n    mnemonic: 'dsymload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'table',\n        type: 'symbol-table',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.InvokeYield] = {\n    name: 'InvokeYield',\n    mnemonic: 'invokeyield',\n    before: null,\n    stackChange: null,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.JumpIf] = {\n    name: 'JumpIf',\n    mnemonic: 'iftrue',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'to',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.JumpUnless] = {\n    name: 'JumpUnless',\n    mnemonic: 'iffalse',\n    before: null,\n    stackChange: -1,\n    ops: [\n      {\n        name: 'to',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.JumpEq] = {\n    name: 'JumpEq',\n    mnemonic: 'ifeq',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'to',\n        type: 'i32',\n      },\n      {\n        name: 'comparison',\n        type: 'i32',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.AssertSame] = {\n    name: 'AssertSame',\n    mnemonic: 'assert_eq',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Enter] = {\n    name: 'Enter',\n    mnemonic: 'blk_start',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'args',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Exit] = {\n    name: 'Exit',\n    mnemonic: 'blk_end',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.ToBoolean] = {\n    name: 'ToBoolean',\n    mnemonic: 'anytobool',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.EnterList] = {\n    name: 'EnterList',\n    mnemonic: 'list_start',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'address',\n        type: 'u32',\n      },\n      {\n        name: 'address',\n        type: 'u32',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.ExitList] = {\n    name: 'ExitList',\n    mnemonic: 'list_end',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Iterate] = {\n    name: 'Iterate',\n    mnemonic: 'iter',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'end',\n        type: 'u32',\n      },\n    ],\n    operands: 1,\n    check: false,\n  };\n\n  METADATA[Op.Main] = {\n    name: 'Main',\n    mnemonic: 'main',\n    before: null,\n    stackChange: -2,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ContentType] = {\n    name: 'ContentType',\n    mnemonic: 'ctload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.DynamicContentType] = {\n    name: 'DynamicContentType',\n    mnemonic: 'dctload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.Curry] = {\n    name: 'Curry',\n    mnemonic: 'curry',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'type',\n        type: 'u32',\n      },\n      {\n        name: 'is-strict',\n        type: 'bool',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.PushComponentDefinition] = {\n    name: 'PushComponentDefinition',\n    mnemonic: 'cmload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'spec',\n        type: 'handle',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushDynamicComponentInstance] = {\n    name: 'PushDynamicComponentInstance',\n    mnemonic: 'dciload',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.ResolveDynamicComponent] = {\n    name: 'ResolveDynamicComponent',\n    mnemonic: 'cdload',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'owner',\n        type: 'owner',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PushArgs] = {\n    name: 'PushArgs',\n    mnemonic: 'argsload',\n    before: null,\n    stackChange: null,\n    ops: [\n      {\n        name: 'names',\n        type: 'str-array',\n      },\n      {\n        name: 'block-names',\n        type: 'str-array',\n      },\n      {\n        name: 'flags',\n        type: 'u32',\n      },\n    ],\n    operands: 3,\n    check: true,\n  };\n\n  METADATA[Op.PushEmptyArgs] = {\n    name: 'PushEmptyArgs',\n    mnemonic: 'emptyargsload',\n    before: null,\n    stackChange: 1,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PopArgs] = {\n    name: 'PopArgs',\n    mnemonic: 'argspop',\n    before: null,\n    stackChange: null,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.PrepareArgs] = {\n    name: 'PrepareArgs',\n    mnemonic: 'argsprep',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: false,\n  };\n\n  METADATA[Op.CaptureArgs] = {\n    name: 'CaptureArgs',\n    mnemonic: 'argscapture',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CreateComponent] = {\n    name: 'CreateComponent',\n    mnemonic: 'comp_create',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'flags',\n        type: 'u32',\n      },\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n\n  METADATA[Op.RegisterComponentDestructor] = {\n    name: 'RegisterComponentDestructor',\n    mnemonic: 'comp_dest',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PutComponentOperations] = {\n    name: 'PutComponentOperations',\n    mnemonic: 'comp_elops',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.GetComponentSelf] = {\n    name: 'GetComponentSelf',\n    mnemonic: 'comp_selfload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetComponentTagName] = {\n    name: 'GetComponentTagName',\n    mnemonic: 'comp_tagload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.GetComponentLayout] = {\n    name: 'GetComponentLayout',\n    mnemonic: 'comp_layoutload',\n    before: null,\n    stackChange: 2,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.BindEvalScope] = {\n    name: 'BindEvalScope',\n    mnemonic: 'eval_scope',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.SetupForEval] = {\n    name: 'SetupForEval',\n    mnemonic: 'eval_setup',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.PopulateLayout] = {\n    name: 'PopulateLayout',\n    mnemonic: 'comp_layoutput',\n    before: null,\n    stackChange: -2,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.InvokeComponentLayout] = {\n    name: 'InvokeComponentLayout',\n    mnemonic: 'comp_invokelayout',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.BeginComponentTransaction] = {\n    name: 'BeginComponentTransaction',\n    mnemonic: 'comp_begin',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.CommitComponentTransaction] = {\n    name: 'CommitComponentTransaction',\n    mnemonic: 'comp_commit',\n    before: null,\n    stackChange: 0,\n    ops: [],\n    operands: 0,\n    check: true,\n  };\n\n  METADATA[Op.DidCreateElement] = {\n    name: 'DidCreateElement',\n    mnemonic: 'comp_created',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.DidRenderLayout] = {\n    name: 'DidRenderLayout',\n    mnemonic: 'comp_rendered',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'state',\n        type: 'register',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.ResolveMaybeLocal] = {\n    name: 'ResolveMaybeLocal',\n    mnemonic: 'eval_varload',\n    before: null,\n    stackChange: 1,\n    ops: [\n      {\n        name: 'local',\n        type: 'str',\n      },\n    ],\n    operands: 1,\n    check: true,\n  };\n\n  METADATA[Op.Debugger] = {\n    name: 'Debugger',\n    mnemonic: 'debugger',\n    before: null,\n    stackChange: 0,\n    ops: [\n      {\n        name: 'symbols',\n        type: 'str-array',\n      },\n      {\n        name: 'debugInfo',\n        type: 'array',\n      },\n    ],\n    operands: 2,\n    check: true,\n  };\n}\n","import type {\n  HighLevelEnd,\n  HighLevelLabel,\n  HighLevelResolveComponent,\n  HighLevelResolveComponentOrHelper,\n  HighLevelResolveHelper,\n  HighLevelResolveLocal,\n  HighLevelResolveModifier,\n  HighLevelResolveOptionalComponentOrHelper,\n  HighLevelResolveTemplateLocal,\n  HighLevelStart,\n  HighLevelStartLabels,\n  HighLevelStopLabels,\n} from '@glimmer/interfaces';\n\nexport const HighLevelResolutionOpcodes = {\n  Modifier: 1003 satisfies HighLevelResolveModifier,\n  Component: 1004 satisfies HighLevelResolveComponent,\n  Helper: 1005 satisfies HighLevelResolveHelper,\n  ComponentOrHelper: 1007 satisfies HighLevelResolveComponentOrHelper,\n  OptionalComponentOrHelper: 1008 satisfies HighLevelResolveOptionalComponentOrHelper,\n  Local: 1010 satisfies HighLevelResolveLocal,\n  TemplateLocal: 1011 satisfies HighLevelResolveTemplateLocal,\n} as const;\n\nexport const HighLevelBuilderOpcodes = {\n  Label: 1000 satisfies HighLevelLabel,\n  StartLabels: 1001 satisfies HighLevelStartLabels,\n  StopLabels: 1002 satisfies HighLevelStopLabels,\n  Start: 1000 satisfies HighLevelStart,\n  End: 1002 satisfies HighLevelEnd,\n} as const;\n","import type {\n  BlockOperand,\n  BlockOperandType,\n  CompilableTemplate,\n  DebugSymbolsOperand,\n  DebugSymbolsOperandType,\n  IsStrictModeOperand,\n  IsStrictModeOperandType,\n  LabelOperand,\n  LabelOperandType,\n  LayoutOperand,\n  LayoutOperandType,\n  NonSmallIntOperand,\n  NonSmallIntOperandType,\n  SerializedBlock,\n  SerializedInlineBlock,\n  StdLibOperand,\n  StdLibOperandType,\n  SymbolTable,\n  SymbolTableOperand,\n  SymbolTableOperandType,\n} from '@glimmer/interfaces';\nimport { assert, isSmallInt } from '@glimmer/util';\n\nexport const HighLevelOperands = {\n  Label: 1 satisfies LabelOperandType,\n  IsStrictMode: 2 satisfies IsStrictModeOperandType,\n  DebugSymbols: 3 satisfies DebugSymbolsOperandType,\n  Block: 4 satisfies BlockOperandType,\n  StdLib: 5 satisfies StdLibOperandType,\n  NonSmallInt: 6 satisfies NonSmallIntOperandType,\n  SymbolTable: 7 satisfies SymbolTableOperandType,\n  Layout: 8 satisfies LayoutOperandType,\n} as const;\n\nexport function labelOperand(value: string): LabelOperand {\n  return { type: HighLevelOperands.Label, value };\n}\n\nexport function debugSymbolsOperand(): DebugSymbolsOperand {\n  return { type: HighLevelOperands.DebugSymbols, value: undefined };\n}\n\nexport function isStrictMode(): IsStrictModeOperand {\n  return { type: HighLevelOperands.IsStrictMode, value: undefined };\n}\n\nexport function blockOperand(value: SerializedInlineBlock | SerializedBlock): BlockOperand {\n  return { type: HighLevelOperands.Block, value };\n}\n\nexport function stdlibOperand(\n  value:\n    | 'main'\n    | 'trusting-append'\n    | 'cautious-append'\n    | 'trusting-non-dynamic-append'\n    | 'cautious-non-dynamic-append'\n): StdLibOperand {\n  return { type: HighLevelOperands.StdLib, value };\n}\n\nexport function nonSmallIntOperand(value: number): NonSmallIntOperand {\n  assert(\n    !isSmallInt(value),\n    'Attempted to make a operand for an int that was not a small int, you should encode this as an immediate'\n  );\n  return { type: HighLevelOperands.NonSmallInt, value };\n}\n\nexport function symbolTableOperand(value: SymbolTable): SymbolTableOperand {\n  return { type: HighLevelOperands.SymbolTable, value };\n}\n\nexport function layoutOperand(value: CompilableTemplate): LayoutOperand {\n  return { type: HighLevelOperands.Layout, value };\n}\n","import type {\n  BuilderOp,\n  BuilderOpcode,\n  CompileTimeConstants,\n  CompileTimeHeap,\n  CompileTimeResolver,\n  ContainingMetadata,\n  Dict,\n  Encoder,\n  EncoderError,\n  HandleResult,\n  HighLevelOp,\n  InstructionEncoder,\n  Operand,\n  ResolutionTimeConstants,\n  SingleBuilderOperand,\n  STDLib,\n} from '@glimmer/interfaces';\nimport { InstructionEncoderImpl } from '@glimmer/encoder';\nimport {\n  assert,\n  dict,\n  EMPTY_STRING_ARRAY,\n  encodeHandle,\n  expect,\n  isPresentArray,\n  Stack,\n} from '@glimmer/util';\nimport { ARG_SHIFT, isMachineOp, MACHINE_MASK, MachineOp, Op, TYPE_SIZE } from '@glimmer/vm';\n\nimport { compilableBlock } from '../compilable-template';\nimport {\n  resolveComponent,\n  resolveComponentOrHelper,\n  resolveHelper,\n  resolveModifier,\n  resolveOptionalComponentOrHelper,\n} from './helpers/resolution';\nimport { HighLevelBuilderOpcodes, HighLevelResolutionOpcodes } from './opcodes';\nimport { HighLevelOperands } from './operands';\n\nexport class Labels {\n  labels: Dict<number> = dict();\n  targets: Array<{ at: number; target: string }> = [];\n\n  label(name: string, index: number) {\n    this.labels[name] = index;\n  }\n\n  target(at: number, target: string) {\n    this.targets.push({ at, target });\n  }\n\n  patch(heap: CompileTimeHeap): void {\n    let { targets, labels } = this;\n\n    for (const { at, target } of targets) {\n      let address = labels[target]! - at;\n\n      assert(heap.getbyaddr(at) === -1, 'Expected heap to contain a placeholder, but it did not');\n\n      heap.setbyaddr(at, address);\n    }\n  }\n}\n\nexport function encodeOp(\n  encoder: Encoder,\n  constants: CompileTimeConstants & ResolutionTimeConstants,\n  resolver: CompileTimeResolver,\n  meta: ContainingMetadata,\n  op: BuilderOp | HighLevelOp\n): void {\n  if (isBuilderOpcode(op[0])) {\n    let [type, ...operands] = op;\n    encoder.push(constants, type, ...(operands as SingleBuilderOperand[]));\n  } else {\n    switch (op[0]) {\n      case HighLevelBuilderOpcodes.Label:\n        return encoder.label(op[1]);\n      case HighLevelBuilderOpcodes.StartLabels:\n        return encoder.startLabels();\n      case HighLevelBuilderOpcodes.StopLabels:\n        return encoder.stopLabels();\n      case HighLevelResolutionOpcodes.Component:\n        return resolveComponent(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.Modifier:\n        return resolveModifier(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.Helper:\n        return resolveHelper(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.ComponentOrHelper:\n        return resolveComponentOrHelper(resolver, constants, meta, op);\n      case HighLevelResolutionOpcodes.OptionalComponentOrHelper:\n        return resolveOptionalComponentOrHelper(resolver, constants, meta, op);\n\n      case HighLevelResolutionOpcodes.Local: {\n        let freeVar = op[1];\n        let name = expect(meta.upvars, 'BUG: attempted to resolve value but no upvars found')[\n          freeVar\n        ]!;\n\n        let andThen = op[2];\n        andThen(name, meta.moduleName);\n\n        break;\n      }\n\n      case HighLevelResolutionOpcodes.TemplateLocal: {\n        let [, valueIndex, then] = op;\n        let value = expect(\n          meta.scopeValues,\n          'BUG: Attempted to get a template local, but template does not have any'\n        )[valueIndex];\n\n        then(constants.value(value));\n\n        break;\n      }\n\n      default:\n        throw new Error(`Unexpected high level opcode ${op[0]}`);\n    }\n  }\n}\n\nexport class EncoderImpl implements Encoder {\n  private labelsStack = new Stack<Labels>();\n  private encoder: InstructionEncoder = new InstructionEncoderImpl([]);\n  private errors: EncoderError[] = [];\n  private handle: number;\n\n  constructor(\n    private heap: CompileTimeHeap,\n    private meta: ContainingMetadata,\n    private stdlib?: STDLib\n  ) {\n    this.handle = heap.malloc();\n  }\n\n  error(error: EncoderError): void {\n    this.encoder.encode(Op.Primitive, 0);\n    this.errors.push(error);\n  }\n\n  commit(size: number): HandleResult {\n    let handle = this.handle;\n\n    this.heap.pushMachine(MachineOp.Return);\n    this.heap.finishMalloc(handle, size);\n\n    if (isPresentArray(this.errors)) {\n      return { errors: this.errors, handle };\n    } else {\n      return handle;\n    }\n  }\n\n  push(\n    constants: CompileTimeConstants,\n    type: BuilderOpcode,\n    ...args: SingleBuilderOperand[]\n  ): void {\n    let { heap } = this;\n\n    if (import.meta.env.DEV && (type as number) > TYPE_SIZE) {\n      throw new Error(`Opcode type over 8-bits. Got ${type}.`);\n    }\n\n    let machine = isMachineOp(type) ? MACHINE_MASK : 0;\n    let first = type | machine | (args.length << ARG_SHIFT);\n\n    heap.pushRaw(first);\n\n    for (let i = 0; i < args.length; i++) {\n      let op = args[i];\n      heap.pushRaw(this.operand(constants, op));\n    }\n  }\n\n  private operand(constants: CompileTimeConstants, operand: SingleBuilderOperand): Operand {\n    if (typeof operand === 'number') {\n      return operand;\n    }\n\n    if (typeof operand === 'object' && operand !== null) {\n      if (Array.isArray(operand)) {\n        return encodeHandle(constants.array(operand));\n      } else {\n        switch (operand.type) {\n          case HighLevelOperands.Label:\n            this.currentLabels.target(this.heap.offset, operand.value);\n            return -1;\n\n          case HighLevelOperands.IsStrictMode:\n            return encodeHandle(constants.value(this.meta.isStrictMode));\n\n          case HighLevelOperands.DebugSymbols:\n            return encodeHandle(constants.array(this.meta.evalSymbols || EMPTY_STRING_ARRAY));\n\n          case HighLevelOperands.Block:\n            return encodeHandle(constants.value(compilableBlock(operand.value, this.meta)));\n\n          case HighLevelOperands.StdLib:\n            return expect(\n              this.stdlib,\n              'attempted to encode a stdlib operand, but the encoder did not have a stdlib. Are you currently building the stdlib?'\n            )[operand.value];\n\n          case HighLevelOperands.NonSmallInt:\n          case HighLevelOperands.SymbolTable:\n          case HighLevelOperands.Layout:\n            return constants.value(operand.value);\n        }\n      }\n    }\n\n    return encodeHandle(constants.value(operand));\n  }\n\n  private get currentLabels(): Labels {\n    return expect(this.labelsStack.current, 'bug: not in a label stack');\n  }\n\n  label(name: string) {\n    this.currentLabels.label(name, this.heap.offset + 1);\n  }\n\n  startLabels() {\n    this.labelsStack.push(new Labels());\n  }\n\n  stopLabels() {\n    let label = expect(this.labelsStack.pop(), 'unbalanced push and pop labels');\n    label.patch(this.heap);\n  }\n}\n\nfunction isBuilderOpcode(op: number): op is BuilderOpcode {\n  return op < HighLevelBuilderOpcodes.Start;\n}\n","import type {\n  BlockSymbolTable,\n  BuilderOp,\n  CompilableBlock,\n  CompilableProgram,\n  CompilableTemplate,\n  CompileTimeCompilationContext,\n  ContainingMetadata,\n  HandleResult,\n  HighLevelOp,\n  LayoutWithContext,\n  Nullable,\n  SerializedBlock,\n  SerializedInlineBlock,\n  Statement,\n  SymbolTable,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\nimport { EMPTY_ARRAY } from '@glimmer/util';\n\nimport type { HighLevelStatementOp } from './syntax/compilers';\n\nimport { debugCompiler } from './compiler';\nimport { templateCompilationContext } from './opcode-builder/context';\nimport { encodeOp } from './opcode-builder/encoder';\nimport { meta } from './opcode-builder/helpers/shared';\nimport { STATEMENTS } from './syntax/statements';\n\nexport const PLACEHOLDER_HANDLE = -1;\n\nclass CompilableTemplateImpl<S extends SymbolTable> implements CompilableTemplate<S> {\n  compiled: Nullable<HandleResult> = null;\n\n  constructor(\n    readonly statements: WireFormat.Statement[],\n    readonly meta: ContainingMetadata,\n    // Part of CompilableTemplate\n    readonly symbolTable: S,\n    // Used for debugging\n    readonly moduleName = 'plain block'\n  ) {}\n\n  // Part of CompilableTemplate\n  compile(context: CompileTimeCompilationContext): HandleResult {\n    return maybeCompile(this, context);\n  }\n}\n\nexport function compilable(layout: LayoutWithContext, moduleName: string): CompilableProgram {\n  let [statements, symbols, hasEval] = layout.block;\n  return new CompilableTemplateImpl(\n    statements,\n    meta(layout),\n    {\n      symbols,\n      hasEval,\n    },\n    moduleName\n  );\n}\n\nfunction maybeCompile(\n  compilable: CompilableTemplateImpl<SymbolTable>,\n  context: CompileTimeCompilationContext\n): HandleResult {\n  if (compilable.compiled !== null) return compilable.compiled;\n\n  compilable.compiled = PLACEHOLDER_HANDLE;\n\n  let { statements, meta } = compilable;\n\n  let result = compileStatements(statements, meta, context);\n  compilable.compiled = result;\n\n  return result;\n}\n\nexport function compileStatements(\n  statements: Statement[],\n  meta: ContainingMetadata,\n  syntaxContext: CompileTimeCompilationContext\n): HandleResult {\n  let sCompiler = STATEMENTS;\n  let context = templateCompilationContext(syntaxContext, meta);\n\n  let {\n    encoder,\n    program: { constants, resolver },\n  } = context;\n\n  function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n    encodeOp(encoder, constants, resolver, meta, op as BuilderOp | HighLevelOp);\n  }\n\n  for (const statement of statements) {\n    sCompiler.compile(pushOp, statement);\n  }\n\n  let handle = context.encoder.commit(meta.size);\n\n  if (LOCAL_SHOULD_LOG) {\n    debugCompiler(context, handle);\n  }\n\n  return handle;\n}\n\nexport function compilableBlock(\n  block: SerializedInlineBlock | SerializedBlock,\n  containing: ContainingMetadata\n): CompilableBlock {\n  return new CompilableTemplateImpl<BlockSymbolTable>(block[0], containing, {\n    parameters: block[1] || (EMPTY_ARRAY as number[]),\n  });\n}\n","export class StdLib {\n  constructor(\n    public main: number,\n    private trustingGuardedAppend: number,\n    private cautiousGuardedAppend: number,\n    private trustingNonDynamicAppend: number,\n    private cautiousNonDynamicAppend: number\n  ) {}\n\n  get 'trusting-append'() {\n    return this.trustingGuardedAppend;\n  }\n\n  get 'cautious-append'() {\n    return this.cautiousGuardedAppend;\n  }\n\n  get 'trusting-non-dynamic-append'() {\n    return this.trustingNonDynamicAppend;\n  }\n\n  get 'cautious-non-dynamic-append'() {\n    return this.cautiousNonDynamicAppend;\n  }\n\n  getAppend(trusting: boolean) {\n    return trusting ? this.trustingGuardedAppend : this.cautiousGuardedAppend;\n  }\n}\n","import type { NamedBlocks, Nullable, SerializedInlineBlock, WireFormat } from '@glimmer/interfaces';\nimport { assign, dict, enumerate, unwrap } from '@glimmer/util';\n\ninterface NamedBlocksDict {\n  [key: string]: Nullable<WireFormat.SerializedInlineBlock>;\n}\n\nexport class NamedBlocksImpl implements NamedBlocks {\n  public names: string[];\n\n  constructor(private blocks: Nullable<NamedBlocksDict>) {\n    this.names = blocks ? Object.keys(blocks) : [];\n  }\n\n  get(name: string): Nullable<SerializedInlineBlock> {\n    if (!this.blocks) return null;\n\n    return this.blocks[name] || null;\n  }\n\n  has(name: string): boolean {\n    let { blocks } = this;\n    return blocks !== null && name in blocks;\n  }\n\n  with(name: string, block: Nullable<SerializedInlineBlock>): NamedBlocks {\n    let { blocks } = this;\n\n    if (blocks) {\n      return new NamedBlocksImpl(assign({}, blocks, { [name]: block }));\n    } else {\n      return new NamedBlocksImpl({ [name]: block });\n    }\n  }\n\n  get hasAny(): boolean {\n    return this.blocks !== null;\n  }\n}\n\nexport const EMPTY_BLOCKS = new NamedBlocksImpl(null);\n\nexport function namedBlocks(blocks: WireFormat.Core.Blocks): NamedBlocks {\n  if (blocks === null) {\n    return EMPTY_BLOCKS;\n  }\n\n  let out: NamedBlocksDict = dict();\n\n  let [keys, values] = blocks;\n\n  for (const [i, key] of enumerate(keys)) {\n    out[key] = unwrap(values[i]);\n  }\n\n  return new NamedBlocksImpl(out);\n}\n","import type { CurriedType, NonSmallIntOperand, Nullable, WireFormat } from '@glimmer/interfaces';\nimport { encodeImmediate, isSmallInt } from '@glimmer/util';\nimport { $fp, $v0, MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { isStrictMode, nonSmallIntOperand } from '../operands';\nimport { expr } from './expr';\nimport { SimpleArgs } from './shared';\n\nexport type Primitive = undefined | null | boolean | number | string;\n\nexport interface CompileHelper {\n  handle: number;\n  positional: Nullable<WireFormat.Core.Params>;\n  named: WireFormat.Core.Hash;\n}\n\n/**\n * Push a reference onto the stack corresponding to a statically known primitive\n * @param value A JavaScript primitive (undefined, null, boolean, number or string)\n */\nexport function PushPrimitiveReference(op: PushExpressionOp, value: Primitive): void {\n  PushPrimitive(op, value);\n  op(Op.PrimitiveReference);\n}\n\n/**\n * Push an encoded representation of a JavaScript primitive on the stack\n *\n * @param value A JavaScript primitive (undefined, null, boolean, number or string)\n */\nexport function PushPrimitive(op: PushExpressionOp, primitive: Primitive): void {\n  let p: Primitive | NonSmallIntOperand = primitive;\n\n  if (typeof p === 'number') {\n    p = isSmallInt(p) ? encodeImmediate(p) : nonSmallIntOperand(p);\n  }\n\n  op(Op.Primitive, p);\n}\n\n/**\n * Invoke a foreign function (a \"helper\") based on a statically known handle\n *\n * @param op The op creation function\n * @param handle A handle\n * @param positional An optional list of expressions to compile\n * @param named An optional list of named arguments (name + expression) to compile\n */\nexport function Call(\n  op: PushExpressionOp,\n  handle: number,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash\n): void {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, named, false);\n  op(Op.Helper, handle);\n  op(MachineOp.PopFrame);\n  op(Op.Fetch, $v0);\n}\n\n/**\n * Invoke a foreign function (a \"helper\") based on a dynamically loaded definition\n *\n * @param op The op creation function\n * @param positional An optional list of expressions to compile\n * @param named An optional list of named arguments (name + expression) to compile\n */\nexport function CallDynamic(\n  op: PushExpressionOp,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  append?: () => void\n): void {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, named, false);\n  op(Op.Dup, $fp, 1);\n  op(Op.DynamicHelper);\n  if (append) {\n    op(Op.Fetch, $v0);\n    append();\n    op(MachineOp.PopFrame);\n    op(Op.Pop, 1);\n  } else {\n    op(MachineOp.PopFrame);\n    op(Op.Pop, 1);\n    op(Op.Fetch, $v0);\n  }\n}\n\n/**\n * Evaluate statements in the context of new dynamic scope entries. Move entries from the\n * stack into named entries in the dynamic scope, then evaluate the statements, then pop\n * the dynamic scope\n *\n * @param names a list of dynamic scope names\n * @param block a function that returns a list of statements to evaluate\n */\nexport function DynamicScope(op: PushStatementOp, names: string[], block: () => void): void {\n  op(Op.PushDynamicScope);\n  op(Op.BindDynamicScope, names);\n  block();\n  op(Op.PopDynamicScope);\n}\n\nexport function Curry(\n  op: PushExpressionOp,\n  type: CurriedType,\n  definition: WireFormat.Expression,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash\n): void {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, named, false);\n  op(Op.CaptureArgs);\n  expr(op, definition);\n  op(Op.Curry, type, isStrictMode());\n  op(MachineOp.PopFrame);\n  op(Op.Fetch, $v0);\n}\n","import type { BuilderOp, HighLevelOp, SexpOpcode, SexpOpcodeMap } from '@glimmer/interfaces';\nimport { assert, unwrap } from '@glimmer/util';\n\nexport type PushExpressionOp = (...op: BuilderOp | HighLevelOp) => void;\n\ndeclare const STATEMENT: unique symbol;\n\nexport type HighLevelStatementOp = [{ [STATEMENT]: undefined }];\n\nexport type PushStatementOp = (...op: BuilderOp | HighLevelOp | HighLevelStatementOp) => void;\n\nexport type CompilerFunction<PushOp extends PushExpressionOp, TSexp> = (\n  op: PushOp,\n  sexp: TSexp\n) => void;\n\nexport class Compilers<PushOp extends PushExpressionOp, TSexpOpcodes extends SexpOpcode> {\n  private names: {\n    [name: number]: number;\n  } = {};\n\n  private funcs: CompilerFunction<PushOp, any>[] = [];\n\n  add<TSexpOpcode extends TSexpOpcodes>(\n    name: TSexpOpcode,\n    func: CompilerFunction<PushOp, SexpOpcodeMap[TSexpOpcode]>\n  ): void {\n    this.names[name] = this.funcs.push(func) - 1;\n  }\n\n  compile(op: PushOp, sexp: SexpOpcodeMap[TSexpOpcodes]): void {\n    let name = sexp[0];\n    let index = unwrap(this.names[name]);\n    let func = this.funcs[index];\n    assert(!!func, `expected an implementation for ${sexp[0]}`);\n\n    func(op, sexp);\n  }\n}\n","import type { ExpressionSexpOpcode } from '@glimmer/interfaces';\nimport { $v0, MachineOp, Op } from '@glimmer/vm';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { PushExpressionOp } from './compilers';\n\nimport { expr } from '../opcode-builder/helpers/expr';\nimport { isGetFreeHelper } from '../opcode-builder/helpers/resolution';\nimport { SimpleArgs } from '../opcode-builder/helpers/shared';\nimport { Call, CallDynamic, Curry, PushPrimitiveReference } from '../opcode-builder/helpers/vm';\nimport { HighLevelResolutionOpcodes } from '../opcode-builder/opcodes';\nimport { Compilers } from './compilers';\n\nexport const EXPRESSIONS = new Compilers<PushExpressionOp, ExpressionSexpOpcode>();\n\nEXPRESSIONS.add(SexpOpcodes.Concat, (op, [, parts]) => {\n  for (let part of parts) {\n    expr(op, part);\n  }\n\n  op(Op.Concat, parts.length);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Call, (op, [, expression, positional, named]) => {\n  if (isGetFreeHelper(expression)) {\n    op(HighLevelResolutionOpcodes.Helper, expression, (handle: number) => {\n      Call(op, handle, positional, named);\n    });\n  } else {\n    expr(op, expression);\n    CallDynamic(op, positional, named);\n  }\n});\n\nEXPRESSIONS.add(SexpOpcodes.Curry, (op, [, expr, type, positional, named]) => {\n  Curry(op, type, expr, positional, named);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetSymbol, (op, [, sym, path]) => {\n  op(Op.GetVariable, sym);\n  withPath(op, path);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetLexicalSymbol, (op, [, sym, path]) => {\n  op(HighLevelResolutionOpcodes.TemplateLocal, sym, (handle: number) => {\n    op(Op.ConstantReference, handle);\n    withPath(op, path);\n  });\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetStrictKeyword, (op, expr) => {\n  op(HighLevelResolutionOpcodes.Local, expr[1], (_name: string) => {\n    op(HighLevelResolutionOpcodes.Helper, expr, (handle: number) => {\n      Call(op, handle, null, null);\n    });\n  });\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetFreeAsHelperHead, (op, expr) => {\n  op(HighLevelResolutionOpcodes.Local, expr[1], (_name: string) => {\n    op(HighLevelResolutionOpcodes.Helper, expr, (handle: number) => {\n      Call(op, handle, null, null);\n    });\n  });\n});\n\nfunction withPath(op: PushExpressionOp, path?: string[]) {\n  if (path === undefined || path.length === 0) return;\n\n  for (let i = 0; i < path.length; i++) {\n    op(Op.GetProperty, path[i]);\n  }\n}\n\nEXPRESSIONS.add(SexpOpcodes.Undefined, (op) => PushPrimitiveReference(op, undefined));\nEXPRESSIONS.add(SexpOpcodes.HasBlock, (op, [, block]) => {\n  expr(op, block);\n  op(Op.HasBlock);\n});\n\nEXPRESSIONS.add(SexpOpcodes.HasBlockParams, (op, [, block]) => {\n  expr(op, block);\n  op(Op.SpreadBlock);\n  op(Op.CompileBlock);\n  op(Op.HasBlockParams);\n});\n\nEXPRESSIONS.add(SexpOpcodes.IfInline, (op, [, condition, truthy, falsy]) => {\n  // Push in reverse order\n  expr(op, falsy);\n  expr(op, truthy);\n  expr(op, condition);\n  op(Op.IfInline);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Not, (op, [, value]) => {\n  expr(op, value);\n  op(Op.Not);\n});\n\nEXPRESSIONS.add(SexpOpcodes.GetDynamicVar, (op, [, expression]) => {\n  expr(op, expression);\n  op(Op.GetDynamicVar);\n});\n\nEXPRESSIONS.add(SexpOpcodes.Log, (op, [, positional]) => {\n  op(MachineOp.PushFrame);\n  SimpleArgs(op, positional, null, false);\n  op(Op.Log);\n  op(MachineOp.PopFrame);\n  op(Op.Fetch, $v0);\n});\n","import type { WireFormat } from '@glimmer/interfaces';\nimport { Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp } from '../../syntax/compilers';\n\nimport { EXPRESSIONS } from '../../syntax/expressions';\nimport { PushPrimitive } from './vm';\n\nexport function expr(op: PushExpressionOp, expression: WireFormat.Expression): void {\n  if (Array.isArray(expression)) {\n    EXPRESSIONS.compile(op, expression);\n  } else {\n    PushPrimitive(op, expression);\n    op(Op.PrimitiveReference);\n  }\n}\n","import type {\n  ContainingMetadata,\n  LayoutWithContext,\n  NamedBlocks,\n  Nullable,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { EMPTY_ARRAY, EMPTY_STRING_ARRAY } from '@glimmer/util';\nimport { Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { PushYieldableBlock } from './blocks';\nimport { expr } from './expr';\n\n/**\n * Compile arguments, pushing an Arguments object onto the stack.\n *\n * @param args.params\n * @param args.hash\n * @param args.blocks\n * @param args.atNames\n */\nexport function CompileArgs(\n  op: PushStatementOp,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  blocks: NamedBlocks,\n  atNames: boolean\n): void {\n  let blockNames: string[] = blocks.names;\n  for (const name of blockNames) {\n    PushYieldableBlock(op, blocks.get(name));\n  }\n\n  let count = CompilePositional(op, positional);\n\n  let flags = count << 4;\n\n  if (atNames) flags |= 0b1000;\n\n  if (blocks) {\n    flags |= 0b111;\n  }\n\n  let names = EMPTY_ARRAY as readonly string[];\n\n  if (named) {\n    names = named[0];\n    let val = named[1];\n    for (let i = 0; i < val.length; i++) {\n      expr(op, val[i]);\n    }\n  }\n\n  op(Op.PushArgs, names as string[], blockNames, flags);\n}\n\nexport function SimpleArgs(\n  op: PushExpressionOp,\n  positional: Nullable<WireFormat.Core.Params>,\n  named: Nullable<WireFormat.Core.Hash>,\n  atNames: boolean\n): void {\n  if (positional === null && named === null) {\n    op(Op.PushEmptyArgs);\n    return;\n  }\n\n  let count = CompilePositional(op, positional);\n\n  let flags = count << 4;\n\n  if (atNames) flags |= 0b1000;\n\n  let names = EMPTY_STRING_ARRAY;\n\n  if (named) {\n    names = named[0];\n    let val = named[1];\n    for (let i = 0; i < val.length; i++) {\n      expr(op, val[i]);\n    }\n  }\n\n  op(Op.PushArgs, names, EMPTY_STRING_ARRAY, flags);\n}\n\n/**\n * Compile an optional list of positional arguments, which pushes each argument\n * onto the stack and returns the number of parameters compiled\n *\n * @param positional an optional list of positional arguments\n */\nexport function CompilePositional(\n  op: PushExpressionOp,\n  positional: Nullable<WireFormat.Core.Params>\n): number {\n  if (positional === null) return 0;\n\n  for (let i = 0; i < positional.length; i++) {\n    expr(op, positional[i]);\n  }\n\n  return positional.length;\n}\n\nexport function meta(layout: LayoutWithContext): ContainingMetadata {\n  let [, symbols, , upvars] = layout.block;\n\n  return {\n    evalSymbols: evalSymbols(layout),\n    upvars: upvars,\n    scopeValues: layout.scope?.() ?? null,\n    isStrictMode: layout.isStrictMode,\n    moduleName: layout.moduleName,\n    owner: layout.owner,\n    size: symbols.length,\n  };\n}\n\nexport function evalSymbols(layout: LayoutWithContext): Nullable<string[]> {\n  let { block } = layout;\n  let [, symbols, hasEval] = block;\n\n  return hasEval ? symbols : null;\n}\n","import type { Nullable, WireFormat } from '@glimmer/interfaces';\nimport { $fp, MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { blockOperand, symbolTableOperand } from '../operands';\nimport { SimpleArgs } from './shared';\nimport { PushPrimitive } from './vm';\n\n/**\n * Yield to a block located at a particular symbol location.\n *\n * @param to the symbol containing the block to yield to\n * @param params optional block parameters to yield to the block\n */\nexport function YieldBlock(\n  op: PushStatementOp,\n  to: number,\n  positional: Nullable<WireFormat.Core.Params>\n): void {\n  SimpleArgs(op, positional, null, true);\n  op(Op.GetBlock, to);\n  op(Op.SpreadBlock);\n  op(Op.CompileBlock);\n  op(Op.InvokeYield);\n  op(Op.PopScope);\n  op(MachineOp.PopFrame);\n}\n\n/**\n * Push an (optional) yieldable block onto the stack. The yieldable block must be known\n * statically at compile time.\n *\n * @param block An optional Compilable block\n */\nexport function PushYieldableBlock(\n  op: PushStatementOp,\n  block: Nullable<WireFormat.SerializedInlineBlock>\n): void {\n  PushSymbolTable(op, block && block[1]);\n  op(Op.PushBlockScope);\n  PushCompilable(op, block);\n}\n\n/**\n * Invoke a block that is known statically at compile time.\n *\n * @param block a Compilable block\n */\nexport function InvokeStaticBlock(\n  op: PushStatementOp,\n  block: WireFormat.SerializedInlineBlock\n): void {\n  op(MachineOp.PushFrame);\n  PushCompilable(op, block);\n  op(Op.CompileBlock);\n  op(MachineOp.InvokeVirtual);\n  op(MachineOp.PopFrame);\n}\n\n/**\n * Invoke a static block, preserving some number of stack entries for use in\n * updating.\n *\n * @param block A compilable block\n * @param callerCount A number of stack entries to preserve\n */\nexport function InvokeStaticBlockWithStack(\n  op: PushStatementOp,\n  block: WireFormat.SerializedInlineBlock,\n  callerCount: number\n): void {\n  let parameters = block[1];\n  let calleeCount = parameters.length;\n  let count = Math.min(callerCount, calleeCount);\n\n  if (count === 0) {\n    InvokeStaticBlock(op, block);\n    return;\n  }\n\n  op(MachineOp.PushFrame);\n\n  if (count) {\n    op(Op.ChildScope);\n\n    for (let i = 0; i < count; i++) {\n      op(Op.Dup, $fp, callerCount - i);\n      op(Op.SetVariable, parameters[i]);\n    }\n  }\n\n  PushCompilable(op, block);\n  op(Op.CompileBlock);\n  op(MachineOp.InvokeVirtual);\n\n  if (count) {\n    op(Op.PopScope);\n  }\n\n  op(MachineOp.PopFrame);\n}\n\nexport function PushSymbolTable(op: PushExpressionOp, parameters: number[] | null): void {\n  if (parameters !== null) {\n    op(Op.PushSymbolTable, symbolTableOperand({ parameters }));\n  } else {\n    PushPrimitive(op, null);\n  }\n}\n\nexport function PushCompilable(\n  op: PushExpressionOp,\n  _block: Nullable<WireFormat.SerializedInlineBlock>\n): void {\n  if (_block === null) {\n    PushPrimitive(op, null);\n  } else {\n    op(Op.Constant, blockOperand(_block));\n  }\n}\n","import { unwrap } from '@glimmer/util';\nimport { MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushStatementOp } from '../../syntax/compilers';\n\nimport { HighLevelBuilderOpcodes } from '../opcodes';\nimport { labelOperand } from '../operands';\n\nexport type When = (match: number, callback: () => void) => void;\n\nexport function SwitchCases(\n  op: PushStatementOp,\n  bootstrap: () => void,\n  matcher: (when: When) => void\n): void {\n  // Setup the switch DSL\n  let clauses: Array<{ match: number; label: string; callback: () => void }> = [];\n\n  let count = 0;\n\n  function when(match: number, callback: () => void): void {\n    clauses.push({ match, callback, label: `CLAUSE${count++}` });\n  }\n\n  // Call the callback\n  matcher(when);\n\n  // Emit the opcodes for the switch\n  op(Op.Enter, 1);\n  bootstrap();\n  op(HighLevelBuilderOpcodes.StartLabels);\n\n  // First, emit the jump opcodes. We don't need a jump for the last\n  // opcode, since it bleeds directly into its clause.\n  for (let clause of clauses.slice(0, -1)) {\n    op(Op.JumpEq, labelOperand(clause.label), clause.match);\n  }\n\n  // Enumerate the clauses in reverse order. Earlier matches will\n  // require fewer checks.\n  for (let i = clauses.length - 1; i >= 0; i--) {\n    let clause = unwrap(clauses[i]);\n\n    op(HighLevelBuilderOpcodes.Label, clause.label);\n    op(Op.Pop, 1);\n    clause.callback();\n\n    // The first match is special: it is placed directly before the END\n    // label, so no additional jump is needed at the end of it.\n    if (i !== 0) {\n      op(MachineOp.Jump, labelOperand('END'));\n    }\n  }\n\n  op(HighLevelBuilderOpcodes.Label, 'END');\n  op(HighLevelBuilderOpcodes.StopLabels);\n  op(Op.Exit);\n}\n\n/**\n * A convenience for pushing some arguments on the stack and\n * running some code if the code needs to be re-executed during\n * updating execution if some of the arguments have changed.\n *\n * # Initial Execution\n *\n * The `args` function should push zero or more arguments onto\n * the stack and return the number of arguments pushed.\n *\n * The `body` function provides the instructions to execute both\n * during initial execution and during updating execution.\n *\n * Internally, this function starts by pushing a new frame, so\n * that the body can return and sets the return point ($ra) to\n * the ENDINITIAL label.\n *\n * It then executes the `args` function, which adds instructions\n * responsible for pushing the arguments for the block to the\n * stack. These arguments will be restored to the stack before\n * updating execution.\n *\n * Next, it adds the Enter opcode, which marks the current position\n * in the DOM, and remembers the current $pc (the next instruction)\n * as the first instruction to execute during updating execution.\n *\n * Next, it runs `body`, which adds the opcodes that should\n * execute both during initial execution and during updating execution.\n * If the `body` wishes to finish early, it should Jump to the\n * `FINALLY` label.\n *\n * Next, it adds the FINALLY label, followed by:\n *\n * - the Exit opcode, which finalizes the marked DOM started by the\n *   Enter opcode.\n * - the Return opcode, which returns to the current return point\n *   ($ra).\n *\n * Finally, it adds the ENDINITIAL label followed by the PopFrame\n * instruction, which restores $fp, $sp and $ra.\n *\n * # Updating Execution\n *\n * Updating execution for this `replayable` occurs if the `body` added an\n * assertion, via one of the `JumpIf`, `JumpUnless` or `AssertSame` opcodes.\n *\n * If, during updating executon, the assertion fails, the initial VM is\n * restored, and the stored arguments are pushed onto the stack. The DOM\n * between the starting and ending markers is cleared, and the VM's cursor\n * is set to the area just cleared.\n *\n * The return point ($ra) is set to -1, the exit instruction.\n *\n * Finally, the $pc is set to to the instruction saved off by the\n * Enter opcode during initial execution, and execution proceeds as\n * usual.\n *\n * The only difference is that when a `Return` instruction is\n * encountered, the program jumps to -1 rather than the END label,\n * and the PopFrame opcode is not needed.\n */\nexport function Replayable(op: PushStatementOp, args: () => number, body: () => void): void {\n  // Start a new label frame, to give END and RETURN\n  // a unique meaning.\n\n  op(HighLevelBuilderOpcodes.StartLabels);\n  op(MachineOp.PushFrame);\n\n  // If the body invokes a block, its return will return to\n  // END. Otherwise, the return in RETURN will return to END.\n  op(MachineOp.ReturnTo, labelOperand('ENDINITIAL'));\n\n  // Push the arguments onto the stack. The args() function\n  // tells us how many stack elements to retain for re-execution\n  // when updating.\n  let count = args();\n\n  // Start a new updating closure, remembering `count` elements\n  // from the stack. Everything after this point, and before END,\n  // will execute both initially and to update the block.\n  //\n  // The enter and exit opcodes also track the area of the DOM\n  // associated with this block. If an assertion inside the block\n  // fails (for example, the test value changes from true to false\n  // in an #if), the DOM is cleared and the program is re-executed,\n  // restoring `count` elements to the stack and executing the\n  // instructions between the enter and exit.\n  op(Op.Enter, count);\n\n  // Evaluate the body of the block. The body of the block may\n  // return, which will jump execution to END during initial\n  // execution, and exit the updating routine.\n  body();\n\n  // All execution paths in the body should run the FINALLY once\n  // they are done. It is executed both during initial execution\n  // and during updating execution.\n  op(HighLevelBuilderOpcodes.Label, 'FINALLY');\n\n  // Finalize the DOM.\n  op(Op.Exit);\n\n  // In initial execution, this is a noop: it returns to the\n  // immediately following opcode. In updating execution, this\n  // exits the updating routine.\n  op(MachineOp.Return);\n\n  // Cleanup code for the block. Runs on initial execution\n  // but not on updating.\n  op(HighLevelBuilderOpcodes.Label, 'ENDINITIAL');\n  op(MachineOp.PopFrame);\n  op(HighLevelBuilderOpcodes.StopLabels);\n}\n\n/**\n * A specialized version of the `replayable` convenience that allows the\n * caller to provide different code based upon whether the item at\n * the top of the stack is true or false.\n *\n * As in `replayable`, the `ifTrue` and `ifFalse` code can invoke `return`.\n *\n * During the initial execution, a `return` will continue execution\n * in the cleanup code, which finalizes the current DOM block and pops\n * the current frame.\n *\n * During the updating execution, a `return` will exit the updating\n * routine, as it can reuse the DOM block and is always only a single\n * frame deep.\n */\nexport function ReplayableIf(\n  op: PushStatementOp,\n  args: () => number,\n  ifTrue: () => void,\n  ifFalse?: () => void\n): void {\n  return Replayable(op, args, () => {\n    // If the conditional is false, jump to the ELSE label.\n    op(Op.JumpUnless, labelOperand('ELSE'));\n    // Otherwise, execute the code associated with the true branch.\n    ifTrue();\n    // We're done, so return. In the initial execution, this runs\n    // the cleanup code. In the updating VM, it exits the updating\n    // routine.\n    op(MachineOp.Jump, labelOperand('FINALLY'));\n    op(HighLevelBuilderOpcodes.Label, 'ELSE');\n\n    // If the conditional is false, and code associatied ith the\n    // false branch was provided, execute it. If there was no code\n    // associated with the false branch, jumping to the else statement\n    // has no other behavior.\n    if (ifFalse !== undefined) {\n      ifFalse();\n    }\n  });\n}\n","import type {\n  CapabilityMask,\n  CompilableProgram,\n  CompileTimeComponent,\n  LayoutWithContext,\n  NamedBlocks,\n  Nullable,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport type { SavedRegister } from '@glimmer/vm';\nimport { hasCapability } from '@glimmer/manager';\nimport { EMPTY_STRING_ARRAY, reverse, unwrap } from '@glimmer/util';\nimport { $s0, $s1, $sp, InternalComponentCapabilities, MachineOp, Op } from '@glimmer/vm';\n\nimport type { PushExpressionOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { namedBlocks } from '../../utils';\nimport { HighLevelBuilderOpcodes } from '../opcodes';\nimport { isStrictMode, labelOperand, layoutOperand, symbolTableOperand } from '../operands';\nimport { InvokeStaticBlock, PushYieldableBlock, YieldBlock } from './blocks';\nimport { Replayable } from './conditional';\nimport { expr } from './expr';\nimport { CompileArgs, CompilePositional } from './shared';\n\nexport const ATTRS_BLOCK = '&attrs';\n\ninterface AnyComponent {\n  elementBlock: Nullable<WireFormat.SerializedInlineBlock>;\n  positional: WireFormat.Core.Params;\n  named: WireFormat.Core.Hash;\n  blocks: NamedBlocks;\n}\n\n// {{component}}\nexport interface DynamicComponent extends AnyComponent {\n  definition: WireFormat.Expression;\n  atNames: boolean;\n  curried: boolean;\n}\n\n// <Component>\nexport interface StaticComponent extends AnyComponent {\n  capabilities: CapabilityMask;\n  layout: CompilableProgram;\n}\n\n// chokepoint\nexport interface Component extends AnyComponent {\n  // either we know the capabilities statically or we need to be conservative and assume\n  // that the component requires all capabilities\n  capabilities: CapabilityMask | true;\n\n  // are the arguments supplied as atNames?\n  atNames: boolean;\n\n  // do we have the layout statically or will we need to look it up at runtime?\n  layout?: CompilableProgram;\n}\n\nexport function InvokeComponent(\n  op: PushStatementOp,\n  component: CompileTimeComponent,\n  _elementBlock: WireFormat.Core.ElementParameters,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  _blocks: WireFormat.Core.Blocks\n): void {\n  let { compilable, capabilities, handle } = component;\n\n  let elementBlock = _elementBlock\n    ? ([_elementBlock, []] as WireFormat.SerializedInlineBlock)\n    : null;\n  let blocks = Array.isArray(_blocks) || _blocks === null ? namedBlocks(_blocks) : _blocks;\n\n  if (compilable) {\n    op(Op.PushComponentDefinition, handle);\n    InvokeStaticComponent(op, {\n      capabilities: capabilities,\n      layout: compilable,\n      elementBlock,\n      positional,\n      named,\n      blocks,\n    });\n  } else {\n    op(Op.PushComponentDefinition, handle);\n    InvokeNonStaticComponent(op, {\n      capabilities: capabilities,\n      elementBlock,\n      positional,\n      named,\n      atNames: true,\n      blocks,\n    });\n  }\n}\n\nexport function InvokeDynamicComponent(\n  op: PushStatementOp,\n  definition: WireFormat.Core.Expression,\n  _elementBlock: WireFormat.Core.ElementParameters,\n  positional: WireFormat.Core.Params,\n  named: WireFormat.Core.Hash,\n  _blocks: WireFormat.Core.Blocks,\n  atNames: boolean,\n  curried: boolean\n): void {\n  let elementBlock = _elementBlock\n    ? ([_elementBlock, []] as WireFormat.SerializedInlineBlock)\n    : null;\n  let blocks = Array.isArray(_blocks) || _blocks === null ? namedBlocks(_blocks) : _blocks;\n\n  Replayable(\n    op,\n\n    () => {\n      expr(op, definition);\n      op(Op.Dup, $sp, 0);\n      return 2;\n    },\n\n    () => {\n      op(Op.JumpUnless, labelOperand('ELSE'));\n\n      if (curried) {\n        op(Op.ResolveCurriedComponent);\n      } else {\n        op(Op.ResolveDynamicComponent, isStrictMode());\n      }\n\n      op(Op.PushDynamicComponentInstance);\n      InvokeNonStaticComponent(op, {\n        capabilities: true,\n        elementBlock,\n        positional,\n        named,\n        atNames,\n        blocks,\n      });\n      op(HighLevelBuilderOpcodes.Label, 'ELSE');\n    }\n  );\n}\n\nfunction InvokeStaticComponent(\n  op: PushStatementOp,\n  { capabilities, layout, elementBlock, positional, named, blocks }: StaticComponent\n): void {\n  let { symbolTable } = layout;\n\n  let bailOut =\n    symbolTable.hasEval || hasCapability(capabilities, InternalComponentCapabilities.prepareArgs);\n\n  if (bailOut) {\n    InvokeNonStaticComponent(op, {\n      capabilities,\n      elementBlock,\n      positional,\n      named,\n      atNames: true,\n      blocks,\n      layout,\n    });\n\n    return;\n  }\n\n  op(Op.Fetch, $s0);\n  op(Op.Dup, $sp, 1);\n  op(Op.Load, $s0);\n  op(MachineOp.PushFrame);\n\n  // Setup arguments\n  let { symbols } = symbolTable;\n\n  // As we push values onto the stack, we store the symbols associated  with them\n  // so that we can set them on the scope later on with SetVariable and SetBlock\n  let blockSymbols: number[] = [];\n  let argSymbols: number[] = [];\n  let argNames: string[] = [];\n\n  // First we push the blocks onto the stack\n  let blockNames = blocks.names;\n\n  // Starting with the attrs block, if it exists and is referenced in the component\n  if (elementBlock !== null) {\n    let symbol = symbols.indexOf(ATTRS_BLOCK);\n\n    if (symbol !== -1) {\n      PushYieldableBlock(op, elementBlock);\n      blockSymbols.push(symbol);\n    }\n  }\n\n  // Followed by the other blocks, if they exist and are referenced in the component.\n  // Also store the index of the associated symbol.\n  for (const name of blockNames) {\n    let symbol = symbols.indexOf(`&${name}`);\n\n    if (symbol !== -1) {\n      PushYieldableBlock(op, blocks.get(name));\n      blockSymbols.push(symbol);\n    }\n  }\n\n  // Next up we have arguments. If the component has the `createArgs` capability,\n  // then it wants access to the arguments in JavaScript. We can't know whether\n  // or not an argument is used, so we have to give access to all of them.\n  if (hasCapability(capabilities, InternalComponentCapabilities.createArgs)) {\n    // First we push positional arguments\n    let count = CompilePositional(op, positional);\n\n    // setup the flags with the count of positionals, and to indicate that atNames\n    // are used\n    let flags = count << 4;\n    flags |= 0b1000;\n\n    let names: string[] = EMPTY_STRING_ARRAY;\n\n    // Next, if named args exist, push them all. If they have an associated symbol\n    // in the invoked component (e.g. they are used within its template), we push\n    // that symbol. If not, we still push the expression as it may be used, and\n    // we store the symbol as -1 (this is used later).\n    if (named !== null) {\n      names = named[0];\n      let val = named[1];\n\n      for (let i = 0; i < val.length; i++) {\n        let symbol = symbols.indexOf(unwrap(names[i]));\n\n        expr(op, val[i]);\n        argSymbols.push(symbol);\n      }\n    }\n\n    // Finally, push the VM arguments themselves. These args won't need access\n    // to blocks (they aren't accessible from userland anyways), so we push an\n    // empty array instead of the actual block names.\n    op(Op.PushArgs, names, EMPTY_STRING_ARRAY, flags);\n\n    // And push an extra pop operation to remove the args before we begin setting\n    // variables on the local context\n    argSymbols.push(-1);\n  } else if (named !== null) {\n    // If the component does not have the `createArgs` capability, then the only\n    // expressions we need to push onto the stack are those that are actually\n    // referenced in the template of the invoked component (e.g. have symbols).\n    let names = named[0];\n    let val = named[1];\n\n    for (let i = 0; i < val.length; i++) {\n      let name = unwrap(names[i]);\n      let symbol = symbols.indexOf(name);\n\n      if (symbol !== -1) {\n        expr(op, val[i]);\n        argSymbols.push(symbol);\n        argNames.push(name);\n      }\n    }\n  }\n\n  op(Op.BeginComponentTransaction, $s0);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.dynamicScope)) {\n    op(Op.PushDynamicScope);\n  }\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.createInstance)) {\n    op(Op.CreateComponent, (blocks.has('default') as any) | 0, $s0);\n  }\n\n  op(Op.RegisterComponentDestructor, $s0);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.createArgs)) {\n    op(Op.GetComponentSelf, $s0);\n  } else {\n    op(Op.GetComponentSelf, $s0, argNames);\n  }\n\n  // Setup the new root scope for the component\n  op(Op.RootScope, symbols.length + 1, Object.keys(blocks).length > 0 ? 1 : 0);\n\n  // Pop the self reference off the stack and set it to the symbol for `this`\n  // in the new scope. This is why all subsequent symbols are increased by one.\n  op(Op.SetVariable, 0);\n\n  // Going in reverse, now we pop the args/blocks off the stack, starting with\n  // arguments, and assign them to their symbols in the new scope.\n  for (const symbol of reverse(argSymbols)) {\n    // for (let i = argSymbols.length - 1; i >= 0; i--) {\n    //   let symbol = argSymbols[i];\n\n    if (symbol === -1) {\n      // The expression was not bound to a local symbol, it was only pushed to be\n      // used with VM args in the javascript side\n      op(Op.Pop, 1);\n    } else {\n      op(Op.SetVariable, symbol + 1);\n    }\n  }\n\n  // if any positional params exist, pop them off the stack as well\n  if (positional !== null) {\n    op(Op.Pop, positional.length);\n  }\n\n  // Finish up by popping off and assigning blocks\n  for (const symbol of reverse(blockSymbols)) {\n    op(Op.SetBlock, symbol + 1);\n  }\n\n  op(Op.Constant, layoutOperand(layout));\n  op(Op.CompileBlock);\n  op(MachineOp.InvokeVirtual);\n  op(Op.DidRenderLayout, $s0);\n\n  op(MachineOp.PopFrame);\n  op(Op.PopScope);\n\n  if (hasCapability(capabilities, InternalComponentCapabilities.dynamicScope)) {\n    op(Op.PopDynamicScope);\n  }\n\n  op(Op.CommitComponentTransaction);\n  op(Op.Load, $s0);\n}\n\nexport function InvokeNonStaticComponent(\n  op: PushStatementOp,\n  { capabilities, elementBlock, positional, named, atNames, blocks: namedBlocks, layout }: Component\n): void {\n  let bindableBlocks = !!namedBlocks;\n  let bindableAtNames =\n    capabilities === true ||\n    hasCapability(capabilities, InternalComponentCapabilities.prepareArgs) ||\n    !!(named && named[0].length !== 0);\n\n  let blocks = namedBlocks.with('attrs', elementBlock);\n\n  op(Op.Fetch, $s0);\n  op(Op.Dup, $sp, 1);\n  op(Op.Load, $s0);\n\n  op(MachineOp.PushFrame);\n  CompileArgs(op, positional, named, blocks, atNames);\n  op(Op.PrepareArgs, $s0);\n\n  invokePreparedComponent(op, blocks.has('default'), bindableBlocks, bindableAtNames, () => {\n    if (layout) {\n      op(Op.PushSymbolTable, symbolTableOperand(layout.symbolTable));\n      op(Op.Constant, layoutOperand(layout));\n      op(Op.CompileBlock);\n    } else {\n      op(Op.GetComponentLayout, $s0);\n    }\n\n    op(Op.PopulateLayout, $s0);\n  });\n\n  op(Op.Load, $s0);\n}\n\nexport function WrappedComponent(\n  op: PushStatementOp,\n  layout: LayoutWithContext,\n  attrsBlockNumber: number\n): void {\n  op(HighLevelBuilderOpcodes.StartLabels);\n  WithSavedRegister(op, $s1, () => {\n    op(Op.GetComponentTagName, $s0);\n    op(Op.PrimitiveReference);\n    op(Op.Dup, $sp, 0);\n  });\n  op(Op.JumpUnless, labelOperand('BODY'));\n  op(Op.Fetch, $s1);\n  op(Op.PutComponentOperations);\n  op(Op.OpenDynamicElement);\n  op(Op.DidCreateElement, $s0);\n  YieldBlock(op, attrsBlockNumber, null);\n  op(Op.FlushElement);\n  op(HighLevelBuilderOpcodes.Label, 'BODY');\n  InvokeStaticBlock(op, [layout.block[0], []]);\n  op(Op.Fetch, $s1);\n  op(Op.JumpUnless, labelOperand('END'));\n  op(Op.CloseElement);\n  op(HighLevelBuilderOpcodes.Label, 'END');\n  op(Op.Load, $s1);\n  op(HighLevelBuilderOpcodes.StopLabels);\n}\n\nexport function invokePreparedComponent(\n  op: PushStatementOp,\n  hasBlock: boolean,\n  bindableBlocks: boolean,\n  bindableAtNames: boolean,\n  populateLayout: Nullable<() => void> = null\n): void {\n  op(Op.BeginComponentTransaction, $s0);\n  op(Op.PushDynamicScope);\n\n  op(Op.CreateComponent, (hasBlock as any) | 0, $s0);\n\n  // this has to run after createComponent to allow\n  // for late-bound layouts, but a caller is free\n  // to populate the layout earlier if it wants to\n  // and do nothing here.\n  if (populateLayout) {\n    populateLayout();\n  }\n\n  op(Op.RegisterComponentDestructor, $s0);\n  op(Op.GetComponentSelf, $s0);\n\n  op(Op.VirtualRootScope, $s0);\n  op(Op.SetVariable, 0);\n  op(Op.SetupForEval, $s0);\n\n  if (bindableAtNames) op(Op.SetNamedVariables, $s0);\n  if (bindableBlocks) op(Op.SetBlocks, $s0);\n\n  op(Op.Pop, 1);\n  op(Op.InvokeComponentLayout, $s0);\n  op(Op.DidRenderLayout, $s0);\n  op(MachineOp.PopFrame);\n\n  op(Op.PopScope);\n  op(Op.PopDynamicScope);\n  op(Op.CommitComponentTransaction);\n}\n\nexport function InvokeBareComponent(op: PushStatementOp): void {\n  op(Op.Fetch, $s0);\n  op(Op.Dup, $sp, 1);\n  op(Op.Load, $s0);\n\n  op(MachineOp.PushFrame);\n  op(Op.PushEmptyArgs);\n  op(Op.PrepareArgs, $s0);\n  invokePreparedComponent(op, false, false, true, () => {\n    op(Op.GetComponentLayout, $s0);\n    op(Op.PopulateLayout, $s0);\n  });\n  op(Op.Load, $s0);\n}\n\nexport function WithSavedRegister(\n  op: PushExpressionOp,\n  register: SavedRegister,\n  block: () => void\n): void {\n  op(Op.Fetch, register);\n  block();\n  op(Op.Load, register);\n}\n","import type {\n  BuilderOp,\n  CompileTimeCompilationContext,\n  ContainingMetadata,\n  HighLevelOp,\n} from '@glimmer/interfaces';\nimport { $s0, ContentType, MachineOp, Op } from '@glimmer/vm';\n\nimport type { HighLevelStatementOp, PushStatementOp } from '../../syntax/compilers';\n\nimport { encodeOp, EncoderImpl } from '../encoder';\nimport { StdLib } from '../stdlib';\nimport { InvokeBareComponent, invokePreparedComponent } from './components';\nimport { SwitchCases } from './conditional';\nimport { CallDynamic } from './vm';\n\nexport function main(op: PushStatementOp): void {\n  op(Op.Main, $s0);\n  invokePreparedComponent(op, false, false, true);\n}\n\n/**\n * Append content to the DOM. This standard function triages content and does the\n * right thing based upon whether it's a string, safe string, component, fragment\n * or node.\n *\n * @param trusting whether to interpolate a string as raw HTML (corresponds to\n * triple curlies)\n */\nexport function StdAppend(\n  op: PushStatementOp,\n  trusting: boolean,\n  nonDynamicAppend: number | null\n): void {\n  SwitchCases(\n    op,\n    () => op(Op.ContentType),\n    (when) => {\n      when(ContentType.String, () => {\n        if (trusting) {\n          op(Op.AssertSame);\n          op(Op.AppendHTML);\n        } else {\n          op(Op.AppendText);\n        }\n      });\n\n      if (typeof nonDynamicAppend === 'number') {\n        when(ContentType.Component, () => {\n          op(Op.ResolveCurriedComponent);\n          op(Op.PushDynamicComponentInstance);\n          InvokeBareComponent(op);\n        });\n\n        when(ContentType.Helper, () => {\n          CallDynamic(op, null, null, () => {\n            op(MachineOp.InvokeStatic, nonDynamicAppend);\n          });\n        });\n      } else {\n        // when non-dynamic, we can no longer call the value (potentially because we've already called it)\n        // this prevents infinite loops. We instead coerce the value, whatever it is, into the DOM.\n        when(ContentType.Component, () => {\n          op(Op.AppendText);\n        });\n\n        when(ContentType.Helper, () => {\n          op(Op.AppendText);\n        });\n      }\n\n      when(ContentType.SafeString, () => {\n        op(Op.AssertSame);\n        op(Op.AppendSafeHTML);\n      });\n\n      when(ContentType.Fragment, () => {\n        op(Op.AssertSame);\n        op(Op.AppendDocumentFragment);\n      });\n\n      when(ContentType.Node, () => {\n        op(Op.AssertSame);\n        op(Op.AppendNode);\n      });\n    }\n  );\n}\n\nexport function compileStd(context: CompileTimeCompilationContext): StdLib {\n  let mainHandle = build(context, (op) => main(op));\n  let trustingGuardedNonDynamicAppend = build(context, (op) => StdAppend(op, true, null));\n  let cautiousGuardedNonDynamicAppend = build(context, (op) => StdAppend(op, false, null));\n\n  let trustingGuardedDynamicAppend = build(context, (op) =>\n    StdAppend(op, true, trustingGuardedNonDynamicAppend)\n  );\n  let cautiousGuardedDynamicAppend = build(context, (op) =>\n    StdAppend(op, false, cautiousGuardedNonDynamicAppend)\n  );\n\n  return new StdLib(\n    mainHandle,\n    trustingGuardedDynamicAppend,\n    cautiousGuardedDynamicAppend,\n    trustingGuardedNonDynamicAppend,\n    cautiousGuardedNonDynamicAppend\n  );\n}\n\nexport const STDLIB_META: ContainingMetadata = {\n  evalSymbols: null,\n  upvars: null,\n  moduleName: 'stdlib',\n\n  // TODO: ??\n  scopeValues: null,\n  isStrictMode: true,\n  owner: null,\n  size: 0,\n};\n\nfunction build(\n  program: CompileTimeCompilationContext,\n  builder: (op: PushStatementOp) => void\n): number {\n  let { constants, heap, resolver } = program;\n  let encoder = new EncoderImpl(heap, STDLIB_META);\n\n  function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n    encodeOp(encoder, constants, resolver, STDLIB_META, op as BuilderOp | HighLevelOp);\n  }\n\n  builder(pushOp);\n\n  let result = encoder.commit(0);\n\n  if (typeof result !== 'number') {\n    // This shouldn't be possible\n    throw new Error(`Unexpected errors compiling std`);\n  } else {\n    return result;\n  }\n}\n","import type {\n  CompileTimeArtifacts,\n  CompileTimeCompilationContext,\n  CompileTimeConstants,\n  CompileTimeHeap,\n  CompileTimeResolver,\n  CreateRuntimeOp,\n  ResolutionTimeConstants,\n  STDLib,\n} from '@glimmer/interfaces';\n\nimport { compileStd } from './opcode-builder/helpers/stdlib';\n\nexport class CompileTimeCompilationContextImpl implements CompileTimeCompilationContext {\n  readonly constants: CompileTimeConstants & ResolutionTimeConstants;\n  readonly heap: CompileTimeHeap;\n  readonly stdlib: STDLib;\n\n  constructor(\n    { constants, heap }: CompileTimeArtifacts,\n    readonly resolver: CompileTimeResolver,\n    readonly createOp: CreateRuntimeOp\n  ) {\n    this.constants = constants;\n    this.heap = heap;\n    this.stdlib = compileStd(this);\n  }\n}\n","import type {\n  CompileTimeArtifacts,\n  CompileTimeCompilationContext,\n  CompileTimeResolver,\n  ContainingMetadata,\n  CreateRuntimeOp,\n  TemplateCompilationContext,\n} from '@glimmer/interfaces';\n\nimport { CompileTimeCompilationContextImpl } from '../program-context';\nimport { EncoderImpl } from './encoder';\n\nexport function programCompilationContext(\n  artifacts: CompileTimeArtifacts,\n  resolver: CompileTimeResolver,\n  createOp: CreateRuntimeOp\n): CompileTimeCompilationContext {\n  return new CompileTimeCompilationContextImpl(artifacts, resolver, createOp);\n}\n\nexport function templateCompilationContext(\n  program: CompileTimeCompilationContext,\n  meta: ContainingMetadata\n): TemplateCompilationContext {\n  let encoder = new EncoderImpl(program.heap, meta, program.stdlib);\n\n  return {\n    program,\n    encoder,\n    meta,\n  };\n}\n","import type {\n  CompileTimeComponent,\n  StatementSexpOpcode,\n  WellKnownAttrName,\n  WellKnownTagName,\n  WireFormat,\n} from '@glimmer/interfaces';\nimport { $fp, $sp, ContentType, MachineOp, Op } from '@glimmer/vm';\nimport { SexpOpcodes } from '@glimmer/wire-format';\n\nimport type { PushStatementOp } from './compilers';\n\nimport {\n  InvokeStaticBlock,\n  InvokeStaticBlockWithStack,\n  YieldBlock,\n} from '../opcode-builder/helpers/blocks';\nimport {\n  InvokeComponent,\n  InvokeDynamicComponent,\n  InvokeNonStaticComponent,\n} from '../opcode-builder/helpers/components';\nimport { Replayable, ReplayableIf, SwitchCases } from '../opcode-builder/helpers/conditional';\nimport { expr } from '../opcode-builder/helpers/expr';\nimport {\n  isGetFreeComponent,\n  isGetFreeComponentOrHelper,\n  isGetFreeModifier,\n} from '../opcode-builder/helpers/resolution';\nimport { CompilePositional, SimpleArgs } from '../opcode-builder/helpers/shared';\nimport {\n  Call,\n  CallDynamic,\n  DynamicScope,\n  PushPrimitiveReference,\n} from '../opcode-builder/helpers/vm';\nimport { HighLevelBuilderOpcodes, HighLevelResolutionOpcodes } from '../opcode-builder/opcodes';\nimport { debugSymbolsOperand, labelOperand, stdlibOperand } from '../opcode-builder/operands';\nimport { namedBlocks } from '../utils';\nimport { Compilers } from './compilers';\n\nexport const STATEMENTS = new Compilers<PushStatementOp, StatementSexpOpcode>();\n\nconst INFLATE_ATTR_TABLE: {\n  [I in WellKnownAttrName]: string;\n} = ['class', 'id', 'value', 'name', 'type', 'style', 'href'];\nconst INFLATE_TAG_TABLE: {\n  [I in WellKnownTagName]: string;\n} = ['div', 'span', 'p', 'a'];\n\nexport function inflateTagName(tagName: string | WellKnownTagName): string {\n  return typeof tagName === 'string' ? tagName : INFLATE_TAG_TABLE[tagName];\n}\n\nexport function inflateAttrName(attrName: string | WellKnownAttrName): string {\n  return typeof attrName === 'string' ? attrName : INFLATE_ATTR_TABLE[attrName];\n}\n\nSTATEMENTS.add(SexpOpcodes.Comment, (op, sexp) => op(Op.Comment, sexp[1]));\nSTATEMENTS.add(SexpOpcodes.CloseElement, (op) => op(Op.CloseElement));\nSTATEMENTS.add(SexpOpcodes.FlushElement, (op) => op(Op.FlushElement));\n\nSTATEMENTS.add(SexpOpcodes.Modifier, (op, [, expression, positional, named]) => {\n  if (isGetFreeModifier(expression)) {\n    op(HighLevelResolutionOpcodes.Modifier, expression, (handle: number) => {\n      op(MachineOp.PushFrame);\n      SimpleArgs(op, positional, named, false);\n      op(Op.Modifier, handle);\n      op(MachineOp.PopFrame);\n    });\n  } else {\n    expr(op, expression);\n    op(MachineOp.PushFrame);\n    SimpleArgs(op, positional, named, false);\n    op(Op.Dup, $fp, 1);\n    op(Op.DynamicModifier);\n    op(MachineOp.PopFrame);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.StaticAttr, (op, [, name, value, namespace]) => {\n  op(Op.StaticAttr, inflateAttrName(name), value as string, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.StaticComponentAttr, (op, [, name, value, namespace]) => {\n  op(Op.StaticComponentAttr, inflateAttrName(name), value as string, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.DynamicAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.DynamicAttr, inflateAttrName(name), false, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingDynamicAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.DynamicAttr, inflateAttrName(name), true, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.ComponentAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.ComponentAttr, inflateAttrName(name), false, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingComponentAttr, (op, [, name, value, namespace]) => {\n  expr(op, value);\n  op(Op.ComponentAttr, inflateAttrName(name), true, namespace ?? null);\n});\n\nSTATEMENTS.add(SexpOpcodes.OpenElement, (op, [, tag]) => {\n  op(Op.OpenElement, inflateTagName(tag));\n});\n\nSTATEMENTS.add(SexpOpcodes.OpenElementWithSplat, (op, [, tag]) => {\n  op(Op.PutComponentOperations);\n  op(Op.OpenElement, inflateTagName(tag));\n});\n\nSTATEMENTS.add(SexpOpcodes.Component, (op, [, expr, elementBlock, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, elementBlock, null, named, blocks);\n    });\n  } else {\n    // otherwise, the component name was an expression, so resolve the expression\n    // and invoke it as a dynamic component\n    InvokeDynamicComponent(op, expr, elementBlock, null, named, blocks, true, true);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.Yield, (op, [, to, params]) => YieldBlock(op, to, params));\n\nSTATEMENTS.add(SexpOpcodes.AttrSplat, (op, [, to]) => YieldBlock(op, to, null));\n\nSTATEMENTS.add(SexpOpcodes.Debugger, (op, [, debugInfo]) =>\n  op(Op.Debugger, debugSymbolsOperand(), debugInfo)\n);\n\nSTATEMENTS.add(SexpOpcodes.Append, (op, [, value]) => {\n  // Special case for static values\n  if (!Array.isArray(value)) {\n    op(Op.Text, value === null || value === undefined ? '' : String(value));\n  } else if (isGetFreeComponentOrHelper(value)) {\n    op(HighLevelResolutionOpcodes.OptionalComponentOrHelper, value, {\n      ifComponent(component: CompileTimeComponent) {\n        InvokeComponent(op, component, null, null, null, null);\n      },\n\n      ifHelper(handle: number) {\n        op(MachineOp.PushFrame);\n        Call(op, handle, null, null);\n        op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n        op(MachineOp.PopFrame);\n      },\n\n      ifValue(handle: number) {\n        op(MachineOp.PushFrame);\n        op(Op.ConstantReference, handle);\n        op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n        op(MachineOp.PopFrame);\n      },\n    });\n  } else if (value[0] === SexpOpcodes.Call) {\n    let [, expression, positional, named] = value;\n\n    if (isGetFreeComponentOrHelper(expression)) {\n      op(HighLevelResolutionOpcodes.ComponentOrHelper, expression, {\n        ifComponent(component: CompileTimeComponent) {\n          InvokeComponent(op, component, null, positional, hashToArgs(named), null);\n        },\n        ifHelper(handle: number) {\n          op(MachineOp.PushFrame);\n          Call(op, handle, positional, named);\n          op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n          op(MachineOp.PopFrame);\n        },\n      });\n    } else {\n      SwitchCases(\n        op,\n        () => {\n          expr(op, expression);\n          op(Op.DynamicContentType);\n        },\n        (when) => {\n          when(ContentType.Component, () => {\n            op(Op.ResolveCurriedComponent);\n            op(Op.PushDynamicComponentInstance);\n            InvokeNonStaticComponent(op, {\n              capabilities: true,\n              elementBlock: null,\n              positional,\n              named,\n              atNames: false,\n              blocks: namedBlocks(null),\n            });\n          });\n\n          when(ContentType.Helper, () => {\n            CallDynamic(op, positional, named, () => {\n              op(MachineOp.InvokeStatic, stdlibOperand('cautious-non-dynamic-append'));\n            });\n          });\n        }\n      );\n    }\n  } else {\n    op(MachineOp.PushFrame);\n    expr(op, value);\n    op(MachineOp.InvokeStatic, stdlibOperand('cautious-append'));\n    op(MachineOp.PopFrame);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.TrustingAppend, (op, [, value]) => {\n  if (!Array.isArray(value)) {\n    op(Op.Text, value === null || value === undefined ? '' : String(value));\n  } else {\n    op(MachineOp.PushFrame);\n    expr(op, value);\n    op(MachineOp.InvokeStatic, stdlibOperand('trusting-append'));\n    op(MachineOp.PopFrame);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.Block, (op, [, expr, positional, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);\n    });\n  } else {\n    InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.InElement, (op, [, block, guid, destination, insertBefore]) => {\n  ReplayableIf(\n    op,\n\n    () => {\n      expr(op, guid);\n\n      if (insertBefore === undefined) {\n        PushPrimitiveReference(op, undefined);\n      } else {\n        expr(op, insertBefore);\n      }\n\n      expr(op, destination);\n      op(Op.Dup, $sp, 0);\n\n      return 4;\n    },\n\n    () => {\n      op(Op.PushRemoteElement);\n      InvokeStaticBlock(op, block);\n      op(Op.PopRemoteElement);\n    }\n  );\n});\n\nSTATEMENTS.add(SexpOpcodes.If, (op, [, condition, block, inverse]) =>\n  ReplayableIf(\n    op,\n    () => {\n      expr(op, condition);\n      op(Op.ToBoolean);\n\n      return 1;\n    },\n\n    () => {\n      InvokeStaticBlock(op, block);\n    },\n\n    inverse\n      ? () => {\n          InvokeStaticBlock(op, inverse);\n        }\n      : undefined\n  )\n);\n\nSTATEMENTS.add(SexpOpcodes.Each, (op, [, value, key, block, inverse]) =>\n  Replayable(\n    op,\n\n    () => {\n      if (key) {\n        expr(op, key);\n      } else {\n        PushPrimitiveReference(op, null);\n      }\n\n      expr(op, value);\n\n      return 2;\n    },\n\n    () => {\n      op(Op.EnterList, labelOperand('BODY'), labelOperand('ELSE'));\n      op(MachineOp.PushFrame);\n      op(Op.Dup, $fp, 1);\n      op(MachineOp.ReturnTo, labelOperand('ITER'));\n      op(HighLevelBuilderOpcodes.Label, 'ITER');\n      op(Op.Iterate, labelOperand('BREAK'));\n      op(HighLevelBuilderOpcodes.Label, 'BODY');\n      InvokeStaticBlockWithStack(op, block, 2);\n      op(Op.Pop, 2);\n      op(MachineOp.Jump, labelOperand('FINALLY'));\n      op(HighLevelBuilderOpcodes.Label, 'BREAK');\n      op(MachineOp.PopFrame);\n      op(Op.ExitList);\n      op(MachineOp.Jump, labelOperand('FINALLY'));\n      op(HighLevelBuilderOpcodes.Label, 'ELSE');\n\n      if (inverse) {\n        InvokeStaticBlock(op, inverse);\n      }\n    }\n  )\n);\n\nSTATEMENTS.add(SexpOpcodes.Let, (op, [, positional, block]) => {\n  let count = CompilePositional(op, positional);\n  InvokeStaticBlockWithStack(op, block, count);\n});\n\nSTATEMENTS.add(SexpOpcodes.WithDynamicVars, (op, [, named, block]) => {\n  if (named) {\n    let [names, expressions] = named;\n\n    CompilePositional(op, expressions);\n    DynamicScope(op, names, () => {\n      InvokeStaticBlock(op, block);\n    });\n  } else {\n    InvokeStaticBlock(op, block);\n  }\n});\n\nSTATEMENTS.add(SexpOpcodes.InvokeComponent, (op, [, expr, positional, named, blocks]) => {\n  if (isGetFreeComponent(expr)) {\n    op(HighLevelResolutionOpcodes.Component, expr, (component: CompileTimeComponent) => {\n      InvokeComponent(op, component, null, positional, hashToArgs(named), blocks);\n    });\n  } else {\n    InvokeDynamicComponent(op, expr, null, positional, named, blocks, false, false);\n  }\n});\n\nfunction hashToArgs(hash: WireFormat.Core.Hash | null): WireFormat.Core.Hash | null {\n  if (hash === null) return null;\n  let names = hash[0].map((key) => `@${key}`);\n  return [names as [string, ...string[]], hash[1]];\n}\n","import type {\n  CompileTimeComponent,\n  InternalComponentCapabilities,\n  Nullable,\n} from '@glimmer/interfaces';\n\nexport const DEFAULT_CAPABILITIES: InternalComponentCapabilities = {\n  dynamicLayout: true,\n  dynamicTag: true,\n  prepareArgs: true,\n  createArgs: true,\n  attributeHook: false,\n  elementHook: false,\n  dynamicScope: true,\n  createCaller: false,\n  updateHook: true,\n  createInstance: true,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport const MINIMAL_CAPABILITIES: InternalComponentCapabilities = {\n  dynamicLayout: false,\n  dynamicTag: false,\n  prepareArgs: false,\n  createArgs: false,\n  attributeHook: false,\n  elementHook: false,\n  dynamicScope: false,\n  createCaller: false,\n  updateHook: false,\n  createInstance: false,\n  wrapped: false,\n  willDestroy: false,\n  hasSubOwner: false,\n};\n\nexport interface ResolverDelegate<R = unknown> {\n  lookupHelper?(name: string, referrer: R): Nullable<number> | void;\n  lookupModifier?(name: string, referrer: R): Nullable<number> | void;\n  lookupComponent?(name: string, referrer: R): Nullable<CompileTimeComponent> | void;\n\n  // For debugging\n  resolve?(handle: number): R;\n}\n","import type {\n  BuilderOp,\n  CompilableProgram,\n  CompileTimeCompilationContext,\n  HandleResult,\n  HighLevelOp,\n  LayoutWithContext,\n  Nullable,\n  ProgramSymbolTable,\n} from '@glimmer/interfaces';\nimport { LOCAL_SHOULD_LOG } from '@glimmer/local-debug-flags';\n\nimport type { HighLevelStatementOp } from './syntax/compilers';\n\nimport { debugCompiler } from './compiler';\nimport { templateCompilationContext } from './opcode-builder/context';\nimport { encodeOp } from './opcode-builder/encoder';\nimport { ATTRS_BLOCK, WrappedComponent } from './opcode-builder/helpers/components';\nimport { meta } from './opcode-builder/helpers/shared';\n\nexport class WrappedBuilder implements CompilableProgram {\n  public symbolTable: ProgramSymbolTable;\n  private compiled: Nullable<number> = null;\n  private attrsBlockNumber: number;\n\n  constructor(\n    private layout: LayoutWithContext,\n    public moduleName: string\n  ) {\n    let { block } = layout;\n    let [, symbols, hasEval] = block;\n\n    symbols = symbols.slice();\n\n    // ensure ATTRS_BLOCK is always included (only once) in the list of symbols\n    let attrsBlockIndex = symbols.indexOf(ATTRS_BLOCK);\n    if (attrsBlockIndex === -1) {\n      this.attrsBlockNumber = symbols.push(ATTRS_BLOCK);\n    } else {\n      this.attrsBlockNumber = attrsBlockIndex + 1;\n    }\n\n    this.symbolTable = {\n      hasEval,\n      symbols,\n    };\n  }\n\n  compile(syntax: CompileTimeCompilationContext): HandleResult {\n    if (this.compiled !== null) return this.compiled;\n\n    let m = meta(this.layout);\n    let context = templateCompilationContext(syntax, m);\n\n    let {\n      encoder,\n      program: { constants, resolver },\n    } = context;\n\n    function pushOp(...op: BuilderOp | HighLevelOp | HighLevelStatementOp) {\n      encodeOp(encoder, constants, resolver, m, op as BuilderOp | HighLevelOp);\n    }\n\n    WrappedComponent(pushOp, this.layout, this.attrsBlockNumber);\n\n    let handle = context.encoder.commit(m.size);\n\n    if (typeof handle !== 'number') {\n      return handle;\n    }\n\n    this.compiled = handle;\n\n    if (LOCAL_SHOULD_LOG) {\n      debugCompiler(context, handle);\n    }\n\n    return handle;\n  }\n}\n","import type {\n  CompilableProgram,\n  LayoutWithContext,\n  Nullable,\n  Owner,\n  SerializedTemplateBlock,\n  SerializedTemplateWithLazyBlock,\n  Template,\n  TemplateFactory,\n  TemplateOk,\n} from '@glimmer/interfaces';\nimport { assign } from '@glimmer/util';\n\nimport { compilable } from './compilable-template';\nimport { WrappedBuilder } from './wrapped-component';\n\nlet clientId = 0;\n\nexport let templateCacheCounters = {\n  cacheHit: 0,\n  cacheMiss: 0,\n};\n\n// These interfaces are for backwards compatibility, some addons use these intimate APIs\nexport interface TemplateFactoryWithIdAndMeta extends TemplateFactory {\n  __id?: string;\n  __meta?: { moduleName: string };\n}\n\nexport interface TemplateWithIdAndReferrer extends TemplateOk {\n  id: string;\n  referrer: {\n    moduleName: string;\n    owner: Owner | null;\n  };\n}\n\n/**\n * Wraps a template js in a template module to change it into a factory\n * that handles lazy parsing the template and to create per env singletons\n * of the template.\n */\nexport default function templateFactory({\n  id: templateId,\n  moduleName,\n  block,\n  scope,\n  isStrictMode,\n}: SerializedTemplateWithLazyBlock): TemplateFactory {\n  // TODO(template-refactors): This should be removed in the near future, as it\n  // appears that id is unused. It is currently kept for backwards compat reasons.\n  let id = templateId || `client-${clientId++}`;\n\n  // TODO: This caches JSON serialized output once in case a template is\n  // compiled by multiple owners, but we haven't verified if this is actually\n  // helpful. We should benchmark this in the future.\n  let parsedBlock: SerializedTemplateBlock;\n\n  let ownerlessTemplate: Template | null = null;\n  let templateCache = new WeakMap<object, Template>();\n\n  let factory: TemplateFactoryWithIdAndMeta = (owner?: Owner) => {\n    if (parsedBlock === undefined) {\n      parsedBlock = JSON.parse(block);\n    }\n\n    if (owner === undefined) {\n      if (ownerlessTemplate === null) {\n        templateCacheCounters.cacheMiss++;\n        ownerlessTemplate = new TemplateImpl({\n          id,\n          block: parsedBlock,\n          moduleName,\n          owner: null,\n          scope,\n          isStrictMode,\n        });\n      } else {\n        templateCacheCounters.cacheHit++;\n      }\n\n      return ownerlessTemplate;\n    }\n\n    let result = templateCache.get(owner) as Template;\n\n    if (result === undefined) {\n      templateCacheCounters.cacheMiss++;\n      result = new TemplateImpl({ id, block: parsedBlock, moduleName, owner, scope, isStrictMode });\n      templateCache.set(owner, result);\n    } else {\n      templateCacheCounters.cacheHit++;\n    }\n\n    return result;\n  };\n\n  factory.__id = id;\n  factory.__meta = { moduleName };\n\n  return factory;\n}\n\nclass TemplateImpl implements TemplateWithIdAndReferrer {\n  readonly result = 'ok';\n\n  private layout: Nullable<CompilableProgram> = null;\n  private wrappedLayout: Nullable<CompilableProgram> = null;\n\n  constructor(private parsedLayout: LayoutWithContext) {}\n\n  get moduleName() {\n    return this.parsedLayout.moduleName;\n  }\n\n  get id() {\n    return this.parsedLayout.id;\n  }\n\n  // TODO(template-refactors): This should be removed in the near future, it is\n  // only being exposed for backwards compatibility\n  get referrer() {\n    return {\n      moduleName: this.parsedLayout.moduleName,\n      owner: this.parsedLayout.owner,\n    };\n  }\n\n  asLayout(): CompilableProgram {\n    if (this.layout) return this.layout;\n    return (this.layout = compilable(assign({}, this.parsedLayout), this.moduleName));\n  }\n\n  asWrappedLayout(): CompilableProgram {\n    if (this.wrappedLayout) return this.wrappedLayout;\n    return (this.wrappedLayout = new WrappedBuilder(\n      assign({}, this.parsedLayout),\n      this.moduleName\n    ));\n  }\n}\n"],"names":["debugCompiler","makeResolutionTypeVerifier","typeToVerify","opcode","Array","isArray","length","isGetLikeTuple","type","SexpOpcodes","GetStrictKeyword","GetLexicalSymbol","Op","Size","fill","isGetFreeComponent","GetFreeAsComponentHead","isGetFreeModifier","GetFreeAsModifierHead","isGetFreeHelper","GetFreeAsHelperHead","isGetFreeComponentOrHelper","GetFreeAsComponentOrHelperHead","lookupBuiltInHelper","expr","resolver","meta","constants","upvars","name","unwrap","helper","HighLevelResolutionOpcodes","Modifier","Component","Helper","ComponentOrHelper","OptionalComponentOrHelper","Local","TemplateLocal","HighLevelBuilderOpcodes","Label","StartLabels","StopLabels","Start","End","HighLevelOperands","IsStrictMode","DebugSymbols","Block","StdLib","NonSmallInt","SymbolTable","Layout","labelOperand","value","isStrictMode","undefined","stdlibOperand","symbolTableOperand","layoutOperand","Labels","labels","dict","targets","label","index","this","target","at","push","patch","heap","address","assert","getbyaddr","setbyaddr","encodeOp","encoder","op","isBuilderOpcode","operands","startLabels","stopLabels","then","scopeValues","owner","definition","expect","component","lookupComponent","resolvedComponent","resolveComponent","modifier","lookupBuiltInModifier","lookupModifier","resolveModifier","lookupHelper","resolveHelper","ifComponent","ifHelper","resolveComponentOrHelper","ifValue","resolveOptionalComponentOrHelper","freeVar","andThen","moduleName","valueIndex","Error","EncoderImpl","labelsStack","Stack","InstructionEncoderImpl","errors","handle","constructor","stdlib","malloc","error","encode","Primitive","commit","size","pushMachine","MachineOp","Return","finishMalloc","isPresentArray","args","first","isMachineOp","MACHINE_MASK","ARG_SHIFT","pushRaw","i","operand","encodeHandle","array","currentLabels","offset","evalSymbols","EMPTY_STRING_ARRAY","block","containing","CompilableTemplateImpl","parameters","EMPTY_ARRAY","current","pop","main","trustingGuardedAppend","cautiousGuardedAppend","trustingNonDynamicAppend","cautiousNonDynamicAppend","getAppend","trusting","NamedBlocksImpl","names","blocks","Object","keys","get","has","with","assign","hasAny","EMPTY_BLOCKS","namedBlocks","out","values","key","enumerate","PushPrimitiveReference","PushPrimitive","PrimitiveReference","primitive","p","isSmallInt","encodeImmediate","Call","positional","named","PushFrame","SimpleArgs","PopFrame","Fetch","$v0","CallDynamic","append","Dup","$fp","DynamicHelper","Pop","Curry","CaptureArgs","Compilers","funcs","add","func","compile","sexp","EXPRESSIONS","withPath","path","GetProperty","expression","atNames","PushEmptyArgs","flags","CompilePositional","val","PushArgs","layout","symbols","scope","hasEval","YieldBlock","to","GetBlock","SpreadBlock","CompileBlock","InvokeYield","PopScope","PushYieldableBlock","PushSymbolTable","PushBlockScope","PushCompilable","InvokeStaticBlock","InvokeVirtual","InvokeStaticBlockWithStack","callerCount","calleeCount","count","Math","min","ChildScope","SetVariable","_block","Constant","SwitchCases","bootstrap","matcher","clauses","match","callback","Enter","clause","slice","JumpEq","Jump","Exit","Replayable","body","ReturnTo","ReplayableIf","ifTrue","ifFalse","JumpUnless","Concat","parts","part","GetSymbol","sym","GetVariable","ConstantReference","_name","Undefined","HasBlock","HasBlockParams","IfInline","condition","truthy","falsy","Not","GetDynamicVar","Log","ATTRS_BLOCK","InvokeComponent","_elementBlock","_blocks","compilable","capabilities","elementBlock","PushComponentDefinition","symbolTable","hasCapability","InternalComponentCapabilities","prepareArgs","InvokeNonStaticComponent","$s0","$sp","Load","blockSymbols","argSymbols","argNames","blockNames","symbol","indexOf","createArgs","BeginComponentTransaction","dynamicScope","PushDynamicScope","createInstance","CreateComponent","RegisterComponentDestructor","GetComponentSelf","RootScope","reverse","SetBlock","DidRenderLayout","PopDynamicScope","CommitComponentTransaction","InvokeStaticComponent","InvokeDynamicComponent","curried","ResolveCurriedComponent","ResolveDynamicComponent","PushDynamicComponentInstance","bindableBlocks","bindableAtNames","CompileArgs","PrepareArgs","invokePreparedComponent","GetComponentLayout","PopulateLayout","hasBlock","populateLayout","VirtualRootScope","SetupForEval","SetNamedVariables","SetBlocks","InvokeComponentLayout","StdAppend","nonDynamicAppend","ContentType","when","String","AssertSame","AppendHTML","AppendText","InvokeBareComponent","InvokeStatic","SafeString","AppendSafeHTML","Fragment","AppendDocumentFragment","Node","AppendNode","compileStd","context","mainHandle","build","Main","trustingGuardedNonDynamicAppend","cautiousGuardedNonDynamicAppend","trustingGuardedDynamicAppend","cautiousGuardedDynamicAppend","STDLIB_META","program","builder","result","CompileTimeCompilationContextImpl","createOp","programCompilationContext","artifacts","templateCompilationContext","STATEMENTS","INFLATE_ATTR_TABLE","INFLATE_TAG_TABLE","inflateTagName","tagName","inflateAttrName","attrName","hashToArgs","hash","map","Comment","CloseElement","FlushElement","DynamicModifier","StaticAttr","namespace","StaticComponentAttr","DynamicAttr","TrustingDynamicAttr","ComponentAttr","TrustingComponentAttr","OpenElement","tag","OpenElementWithSplat","PutComponentOperations","Yield","params","AttrSplat","Debugger","debugInfo","Append","DynamicContentType","Text","TrustingAppend","InElement","guid","destination","insertBefore","PushRemoteElement","PopRemoteElement","If","inverse","ToBoolean","Each","EnterList","Iterate","ExitList","Let","WithDynamicVars","expressions","BindDynamicScope","DynamicScope","compiled","statements","compileStatements","maybeCompile","syntaxContext","sCompiler","pushOp","statement","DEFAULT_CAPABILITIES","dynamicLayout","dynamicTag","attributeHook","elementHook","createCaller","updateHook","wrapped","willDestroy","hasSubOwner","MINIMAL_CAPABILITIES","WrappedBuilder","attrsBlockNumber","attrsBlockIndex","syntax","m","register","WithSavedRegister","$s1","GetComponentTagName","OpenDynamicElement","DidCreateElement","clientId","templateCacheCounters","cacheHit","cacheMiss","templateFactory","id","templateId","parsedBlock","ownerlessTemplate","templateCache","WeakMap","factory","JSON","parse","TemplateImpl","set","__id","__meta","wrappedLayout","parsedLayout","referrer","asLayout","asWrappedLayout"],"mappings":"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"}