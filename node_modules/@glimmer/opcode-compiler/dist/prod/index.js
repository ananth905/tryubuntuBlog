import{assert as e,expect as t,unwrap as n,isSmallInt as o,Stack as l,isPresentArray as a,encodeHandle as r,EMPTY_STRING_ARRAY as i,dict as s,assign as u,enumerate as p,encodeImmediate as c,EMPTY_ARRAY as m,reverse as d}from"@glimmer/util";import{Op as h,MachineOp as f,isMachineOp as b,MACHINE_MASK as y,ARG_SHIFT as S,$v0 as g,$fp as L,$sp as v,InternalComponentCapabilities as k,$s0 as C,$s1 as A,ContentType as P}from"@glimmer/vm";import{InstructionEncoderImpl as w}from"@glimmer/encoder";import{SexpOpcodes as F}from"@glimmer/wire-format";import{hasCapability as D}from"@glimmer/manager";let E;function B(e){return t=>{if(!function(e){return Array.isArray(e)&&2===e.length}(t))return!1;let n=t[0];return n===F.GetStrictKeyword||n===F.GetLexicalSymbol||n===e}}new Array(h.Size).fill(null),new Array(h.Size).fill(null);const N=B(F.GetFreeAsComponentHead),G=B(F.GetFreeAsModifierHead),H=B(F.GetFreeAsHelperHead),I=B(F.GetFreeAsComponentOrHelperHead);function T(e,t,o,l,a){let{upvars:r}=o,i=n(r[e[1]]),s=t.lookupBuiltInHelper(i);return l.helper(s,i)}const x={Modifier:1003,Component:1004,Helper:1005,ComponentOrHelper:1007,OptionalComponentOrHelper:1008,Local:1010,TemplateLocal:1011},O={Label:1e3,StartLabels:1001,StopLabels:1002,Start:1e3,End:1002},M={Label:1,IsStrictMode:2,DebugSymbols:3,Block:4,StdLib:5,NonSmallInt:6,SymbolTable:7,Layout:8};function V(e){return{type:M.Label,value:e}}function R(){return{type:M.IsStrictMode,value:void 0}}function U(e){return{type:M.StdLib,value:e}}function J(e){return{type:M.SymbolTable,value:e}}function Y(e){return{type:M.Layout,value:e}}class K{labels=s();targets=[];label(e,t){this.labels[e]=t}target(e,t){this.targets.push({at:e,target:t})}patch(t){let{targets:n,labels:o}=this;for(const{at:l,target:a}of n){let n=o[a]-l;e(-1===t.getbyaddr(l),"Expected heap to contain a placeholder, but it did not"),t.setbyaddr(l,n)}}}function z(o,l,a,r,i){if(function(e){return e<O.Start}(i[0])){let[e,...t]=i;o.push(l,e,...t)}else switch(i[0]){case O.Label:return o.label(i[1]);case O.StartLabels:return o.startLabels();case O.StopLabels:return o.stopLabels();case x.Component:return function(o,l,a,[,r,i]){if(e(N(r),"Attempted to resolve a component with incorrect opcode"),r[0]===F.GetLexicalSymbol){let{scopeValues:e,owner:n}=a,o=t(e,"BUG: scopeValues must exist if template symbol is used")[r[1]];i(l.component(o,t(n,"BUG: expected owner when resolving component definition")))}else{let{upvars:e,owner:t}=a,s=n(e[r[1]]),u=o.lookupComponent(s,t);i(l.resolvedComponent(u,s))}}(a,l,r,i);case x.Modifier:return function(o,l,a,[,r,i]){e(G(r),"Attempted to resolve a modifier with incorrect opcode");let s=r[0];if(s===F.GetLexicalSymbol){let{scopeValues:e}=a,n=t(e,"BUG: scopeValues must exist if template symbol is used")[r[1]];i(l.modifier(n))}else if(s===F.GetStrictKeyword){let{upvars:e}=a,t=n(e[r[1]]),s=o.lookupBuiltInModifier(t);i(l.modifier(s,t))}else{let{upvars:e,owner:t}=a,s=n(e[r[1]]),u=o.lookupModifier(s,t);i(l.modifier(u,s))}}(a,l,r,i);case x.Helper:return function(o,l,a,[,r,i]){e(H(r),"Attempted to resolve a helper with incorrect opcode");let s=r[0];if(s===F.GetLexicalSymbol){let{scopeValues:e}=a,n=t(e,"BUG: scopeValues must exist if template symbol is used")[r[1]];i(l.helper(n))}else if(s===F.GetStrictKeyword)i(T(r,o,a,l));else{let{upvars:e,owner:t}=a,s=n(e[r[1]]),u=o.lookupHelper(s,t);i(l.helper(u,s))}}(a,l,r,i);case x.ComponentOrHelper:return function(o,l,a,[,r,{ifComponent:i,ifHelper:s}]){e(I(r),"Attempted to resolve a component or helper with incorrect opcode");let u=r[0];if(u===F.GetLexicalSymbol){let{scopeValues:e,owner:n}=a,o=t(e,"BUG: scopeValues must exist if template symbol is used")[r[1]],u=l.component(o,t(n,"BUG: expected owner when resolving component definition"),!0);if(null!==u)return void i(u);let p=l.helper(o,null,!0);s(t(p,"BUG: helper must exist"))}else if(u===F.GetStrictKeyword)s(T(r,o,a,l));else{let{upvars:e,owner:t}=a,u=n(e[r[1]]),p=o.lookupComponent(u,t);if(null!==p)i(l.resolvedComponent(p,u));else{let e=o.lookupHelper(u,t);s(l.helper(e,u))}}}(a,l,r,i);case x.OptionalComponentOrHelper:return function(o,l,a,[,r,{ifComponent:i,ifHelper:s,ifValue:u}]){e(I(r),"Attempted to resolve an optional component or helper with incorrect opcode");let p=r[0];if(p===F.GetLexicalSymbol){let{scopeValues:e,owner:n}=a,o=t(e,"BUG: scopeValues must exist if template symbol is used")[r[1]];if("function"!=typeof o&&("object"!=typeof o||null===o))return void u(l.value(o));let p=l.component(o,t(n,"BUG: expected owner when resolving component definition"),!0);if(null!==p)return void i(p);let c=l.helper(o,null,!0);if(null!==c)return void s(c);u(l.value(o))}else if(p===F.GetStrictKeyword)s(T(r,o,a,l));else{let{upvars:e,owner:t}=a,u=n(e[r[1]]),p=o.lookupComponent(u,t);if(null!==p)return void i(l.resolvedComponent(p,u));let c=o.lookupHelper(u,t);null!==c&&s(l.helper(c,u))}}(a,l,r,i);case x.Local:{let e=i[1],n=t(r.upvars,"BUG: attempted to resolve value but no upvars found")[e];(0,i[2])(n,r.moduleName);break}case x.TemplateLocal:{let[,e,n]=i,o=t(r.scopeValues,"BUG: Attempted to get a template local, but template does not have any")[e];n(l.value(o));break}default:throw new Error(`Unexpected high level opcode ${i[0]}`)}}class W{labelsStack=new l;encoder=new w([]);errors=[];handle;constructor(e,t,n){this.heap=e,this.meta=t,this.stdlib=n,this.handle=e.malloc()}error(e){this.encoder.encode(h.Primitive,0),this.errors.push(e)}commit(e){let t=this.handle;return this.heap.pushMachine(f.Return),this.heap.finishMalloc(t,e),a(this.errors)?{errors:this.errors,handle:t}:t}push(e,t,...n){let{heap:o}=this,l=t|(b(t)?y:0)|n.length<<S;o.pushRaw(l);for(let t=0;t<n.length;t++){let l=n[t];o.pushRaw(this.operand(e,l))}}operand(e,n){if("number"==typeof n)return n;if("object"==typeof n&&null!==n){if(Array.isArray(n))return r(e.array(n));switch(n.type){case M.Label:return this.currentLabels.target(this.heap.offset,n.value),-1;case M.IsStrictMode:return r(e.value(this.meta.isStrictMode));case M.DebugSymbols:return r(e.array(this.meta.evalSymbols||i));case M.Block:return r(e.value((o=n.value,l=this.meta,new xe(o[0],l,{parameters:o[1]||m}))));case M.StdLib:return t(this.stdlib,"attempted to encode a stdlib operand, but the encoder did not have a stdlib. Are you currently building the stdlib?")[n.value];case M.NonSmallInt:case M.SymbolTable:case M.Layout:return e.value(n.value)}}var o,l;return r(e.value(n))}get currentLabels(){return t(this.labelsStack.current,"bug: not in a label stack")}label(e){this.currentLabels.label(e,this.heap.offset+1)}startLabels(){this.labelsStack.push(new K)}stopLabels(){t(this.labelsStack.pop(),"unbalanced push and pop labels").patch(this.heap)}}class j{constructor(e,t,n,o,l){this.main=e,this.trustingGuardedAppend=t,this.cautiousGuardedAppend=n,this.trustingNonDynamicAppend=o,this.cautiousNonDynamicAppend=l}get"trusting-append"(){return this.trustingGuardedAppend}get"cautious-append"(){return this.cautiousGuardedAppend}get"trusting-non-dynamic-append"(){return this.trustingNonDynamicAppend}get"cautious-non-dynamic-append"(){return this.cautiousNonDynamicAppend}getAppend(e){return e?this.trustingGuardedAppend:this.cautiousGuardedAppend}}class ${names;constructor(e){this.blocks=e,this.names=e?Object.keys(e):[]}get(e){return this.blocks&&this.blocks[e]||null}has(e){let{blocks:t}=this;return null!==t&&e in t}with(e,t){let{blocks:n}=this;return new $(n?u({},n,{[e]:t}):{[e]:t})}get hasAny(){return null!==this.blocks}}const _=new $(null);function q(e){if(null===e)return _;let t=s(),[o,l]=e;for(const[e,a]of p(o))t[a]=n(l[e]);return new $(t)}function Q(e,t){X(e,t),e(h.PrimitiveReference)}function X(t,n){let l=n;var a;"number"==typeof l&&(l=o(l)?c(l):(e(!o(a=l),"Attempted to make a operand for an int that was not a small int, you should encode this as an immediate"),{type:M.NonSmallInt,value:a})),t(h.Primitive,l)}function Z(e,t,n,o){e(f.PushFrame),re(e,n,o,!1),e(h.Helper,t),e(f.PopFrame),e(h.Fetch,g)}function ee(e,t,n,o){e(f.PushFrame),re(e,t,n,!1),e(h.Dup,L,1),e(h.DynamicHelper),o?(e(h.Fetch,g),o(),e(f.PopFrame),e(h.Pop,1)):(e(f.PopFrame),e(h.Pop,1),e(h.Fetch,g))}function te(e,t,n,o,l){e(f.PushFrame),re(e,o,l,!1),e(h.CaptureArgs),ae(e,n),e(h.Curry,t,R()),e(f.PopFrame),e(h.Fetch,g)}class ne{names={};funcs=[];add(e,t){this.names[e]=this.funcs.push(t)-1}compile(t,o){let l=o[0],a=n(this.names[l]),r=this.funcs[a];e(!!r,`expected an implementation for ${o[0]}`),r(t,o)}}const oe=new ne;function le(e,t){if(void 0!==t&&0!==t.length)for(let n=0;n<t.length;n++)e(h.GetProperty,t[n])}function ae(e,t){Array.isArray(t)?oe.compile(e,t):(X(e,t),e(h.PrimitiveReference))}function re(e,t,n,o){if(null===t&&null===n)return void e(h.PushEmptyArgs);let l=ie(e,t)<<4;o&&(l|=8);let a=i;if(n){a=n[0];let t=n[1];for(let n=0;n<t.length;n++)ae(e,t[n])}e(h.PushArgs,a,i,l)}function ie(e,t){if(null===t)return 0;for(let n=0;n<t.length;n++)ae(e,t[n]);return t.length}function se(e){let[,t,,n]=e.block;return{evalSymbols:ue(e),upvars:n,scopeValues:e.scope?.()??null,isStrictMode:e.isStrictMode,moduleName:e.moduleName,owner:e.owner,size:t.length}}function ue(e){let{block:t}=e,[,n,o]=t;return o?n:null}function pe(e,t,n){re(e,n,null,!0),e(h.GetBlock,t),e(h.SpreadBlock),e(h.CompileBlock),e(h.InvokeYield),e(h.PopScope),e(f.PopFrame)}function ce(e,t){!function(e,t){null!==t?e(h.PushSymbolTable,J({parameters:t})):X(e,null)}(e,t&&t[1]),e(h.PushBlockScope),he(e,t)}function me(e,t){e(f.PushFrame),he(e,t),e(h.CompileBlock),e(f.InvokeVirtual),e(f.PopFrame)}function de(e,t,n){let o=t[1],l=o.length,a=Math.min(n,l);if(0!==a){if(e(f.PushFrame),a){e(h.ChildScope);for(let t=0;t<a;t++)e(h.Dup,L,n-t),e(h.SetVariable,o[t])}he(e,t),e(h.CompileBlock),e(f.InvokeVirtual),a&&e(h.PopScope),e(f.PopFrame)}else me(e,t)}function he(e,t){var n;null===t?X(e,null):e(h.Constant,(n=t,{type:M.Block,value:n}))}function fe(e,t,o){let l=[],a=0;o((function(e,t){l.push({match:e,callback:t,label:"CLAUSE"+a++})})),e(h.Enter,1),t(),e(O.StartLabels);for(let t of l.slice(0,-1))e(h.JumpEq,V(t.label),t.match);for(let t=l.length-1;t>=0;t--){let o=n(l[t]);e(O.Label,o.label),e(h.Pop,1),o.callback(),0!==t&&e(f.Jump,V("END"))}e(O.Label,"END"),e(O.StopLabels),e(h.Exit)}function be(e,t,n){e(O.StartLabels),e(f.PushFrame),e(f.ReturnTo,V("ENDINITIAL"));let o=t();e(h.Enter,o),n(),e(O.Label,"FINALLY"),e(h.Exit),e(f.Return),e(O.Label,"ENDINITIAL"),e(f.PopFrame),e(O.StopLabels)}function ye(e,t,n,o){return be(e,t,(()=>{e(h.JumpUnless,V("ELSE")),n(),e(f.Jump,V("FINALLY")),e(O.Label,"ELSE"),void 0!==o&&o()}))}oe.add(F.Concat,((e,[,t])=>{for(let n of t)ae(e,n);e(h.Concat,t.length)})),oe.add(F.Call,((e,[,t,n,o])=>{H(t)?e(x.Helper,t,(t=>{Z(e,t,n,o)})):(ae(e,t),ee(e,n,o))})),oe.add(F.Curry,((e,[,t,n,o,l])=>{te(e,n,t,o,l)})),oe.add(F.GetSymbol,((e,[,t,n])=>{e(h.GetVariable,t),le(e,n)})),oe.add(F.GetLexicalSymbol,((e,[,t,n])=>{e(x.TemplateLocal,t,(t=>{e(h.ConstantReference,t),le(e,n)}))})),oe.add(F.GetStrictKeyword,((e,t)=>{e(x.Local,t[1],(n=>{e(x.Helper,t,(t=>{Z(e,t,null,null)}))}))})),oe.add(F.GetFreeAsHelperHead,((e,t)=>{e(x.Local,t[1],(n=>{e(x.Helper,t,(t=>{Z(e,t,null,null)}))}))})),oe.add(F.Undefined,(e=>Q(e,void 0))),oe.add(F.HasBlock,((e,[,t])=>{ae(e,t),e(h.HasBlock)})),oe.add(F.HasBlockParams,((e,[,t])=>{ae(e,t),e(h.SpreadBlock),e(h.CompileBlock),e(h.HasBlockParams)})),oe.add(F.IfInline,((e,[,t,n,o])=>{ae(e,o),ae(e,n),ae(e,t),e(h.IfInline)})),oe.add(F.Not,((e,[,t])=>{ae(e,t),e(h.Not)})),oe.add(F.GetDynamicVar,((e,[,t])=>{ae(e,t),e(h.GetDynamicVar)})),oe.add(F.Log,((e,[,t])=>{e(f.PushFrame),re(e,t,null,!1),e(h.Log),e(f.PopFrame),e(h.Fetch,g)}));const Se="&attrs";function ge(e,t,o,l,a,r){let{compilable:s,capabilities:u,handle:p}=t,c=o?[o,[]]:null,m=Array.isArray(r)||null===r?q(r):r;s?(e(h.PushComponentDefinition,p),function(e,{capabilities:t,layout:o,elementBlock:l,positional:a,named:r,blocks:s}){let{symbolTable:u}=o;if(u.hasEval||D(t,k.prepareArgs))return void ve(e,{capabilities:t,elementBlock:l,positional:a,named:r,atNames:!0,blocks:s,layout:o});e(h.Fetch,C),e(h.Dup,v,1),e(h.Load,C),e(f.PushFrame);let{symbols:p}=u,c=[],m=[],b=[],y=s.names;if(null!==l){let t=p.indexOf(Se);-1!==t&&(ce(e,l),c.push(t))}for(const t of y){let n=p.indexOf(`&${t}`);-1!==n&&(ce(e,s.get(t)),c.push(n))}if(D(t,k.createArgs)){let t=ie(e,a)<<4;t|=8;let o=i;if(null!==r){o=r[0];let t=r[1];for(let l=0;l<t.length;l++){let a=p.indexOf(n(o[l]));ae(e,t[l]),m.push(a)}}e(h.PushArgs,o,i,t),m.push(-1)}else if(null!==r){let t=r[0],o=r[1];for(let l=0;l<o.length;l++){let a=n(t[l]),r=p.indexOf(a);-1!==r&&(ae(e,o[l]),m.push(r),b.push(a))}}e(h.BeginComponentTransaction,C),D(t,k.dynamicScope)&&e(h.PushDynamicScope),D(t,k.createInstance)&&e(h.CreateComponent,0|s.has("default"),C),e(h.RegisterComponentDestructor,C),D(t,k.createArgs)?e(h.GetComponentSelf,C):e(h.GetComponentSelf,C,b),e(h.RootScope,p.length+1,Object.keys(s).length>0?1:0),e(h.SetVariable,0);for(const t of d(m))-1===t?e(h.Pop,1):e(h.SetVariable,t+1);null!==a&&e(h.Pop,a.length);for(const t of d(c))e(h.SetBlock,t+1);e(h.Constant,Y(o)),e(h.CompileBlock),e(f.InvokeVirtual),e(h.DidRenderLayout,C),e(f.PopFrame),e(h.PopScope),D(t,k.dynamicScope)&&e(h.PopDynamicScope),e(h.CommitComponentTransaction),e(h.Load,C)}(e,{capabilities:u,layout:s,elementBlock:c,positional:l,named:a,blocks:m})):(e(h.PushComponentDefinition,p),ve(e,{capabilities:u,elementBlock:c,positional:l,named:a,atNames:!0,blocks:m}))}function Le(e,t,n,o,l,a,r,i){let s=n?[n,[]]:null,u=Array.isArray(a)||null===a?q(a):a;be(e,(()=>(ae(e,t),e(h.Dup,v,0),2)),(()=>{e(h.JumpUnless,V("ELSE")),i?e(h.ResolveCurriedComponent):e(h.ResolveDynamicComponent,R()),e(h.PushDynamicComponentInstance),ve(e,{capabilities:!0,elementBlock:s,positional:o,named:l,atNames:r,blocks:u}),e(O.Label,"ELSE")}))}function ve(e,{capabilities:t,elementBlock:n,positional:o,named:l,atNames:a,blocks:r,layout:i}){let s=!!r,u=!0===t||D(t,k.prepareArgs)||!(!l||0===l[0].length),p=r.with("attrs",n);e(h.Fetch,C),e(h.Dup,v,1),e(h.Load,C),e(f.PushFrame),function(e,t,n,o,l){let a=o.names;for(const t of a)ce(e,o.get(t));let r=ie(e,t)<<4;l&&(r|=8),o&&(r|=7);let i=m;if(n){i=n[0];let t=n[1];for(let n=0;n<t.length;n++)ae(e,t[n])}e(h.PushArgs,i,a,r)}(e,o,l,p,a),e(h.PrepareArgs,C),ke(e,p.has("default"),s,u,(()=>{i?(e(h.PushSymbolTable,J(i.symbolTable)),e(h.Constant,Y(i)),e(h.CompileBlock)):e(h.GetComponentLayout,C),e(h.PopulateLayout,C)})),e(h.Load,C)}function ke(e,t,n,o,l=null){e(h.BeginComponentTransaction,C),e(h.PushDynamicScope),e(h.CreateComponent,0|t,C),l&&l(),e(h.RegisterComponentDestructor,C),e(h.GetComponentSelf,C),e(h.VirtualRootScope,C),e(h.SetVariable,0),e(h.SetupForEval,C),o&&e(h.SetNamedVariables,C),n&&e(h.SetBlocks,C),e(h.Pop,1),e(h.InvokeComponentLayout,C),e(h.DidRenderLayout,C),e(f.PopFrame),e(h.PopScope),e(h.PopDynamicScope),e(h.CommitComponentTransaction)}function Ce(e,t,n){fe(e,(()=>e(h.ContentType)),(o=>{o(P.String,(()=>{t?(e(h.AssertSame),e(h.AppendHTML)):e(h.AppendText)})),"number"==typeof n?(o(P.Component,(()=>{e(h.ResolveCurriedComponent),e(h.PushDynamicComponentInstance),function(e){e(h.Fetch,C),e(h.Dup,v,1),e(h.Load,C),e(f.PushFrame),e(h.PushEmptyArgs),e(h.PrepareArgs,C),ke(e,!1,!1,!0,(()=>{e(h.GetComponentLayout,C),e(h.PopulateLayout,C)})),e(h.Load,C)}(e)})),o(P.Helper,(()=>{ee(e,null,null,(()=>{e(f.InvokeStatic,n)}))}))):(o(P.Component,(()=>{e(h.AppendText)})),o(P.Helper,(()=>{e(h.AppendText)}))),o(P.SafeString,(()=>{e(h.AssertSame),e(h.AppendSafeHTML)})),o(P.Fragment,(()=>{e(h.AssertSame),e(h.AppendDocumentFragment)})),o(P.Node,(()=>{e(h.AssertSame),e(h.AppendNode)}))}))}function Ae(e){let t=we(e,(e=>function(e){e(h.Main,C),ke(e,!1,!1,!0)}(e))),n=we(e,(e=>Ce(e,!0,null))),o=we(e,(e=>Ce(e,!1,null))),l=we(e,(e=>Ce(e,!0,n))),a=we(e,(e=>Ce(e,!1,o)));return new j(t,l,a,n,o)}const Pe={evalSymbols:null,upvars:null,moduleName:"stdlib",scopeValues:null,isStrictMode:!0,owner:null,size:0};function we(e,t){let{constants:n,heap:o,resolver:l}=e,a=new W(o,Pe);t((function(...e){z(a,n,l,Pe,e)}));let r=a.commit(0);if("number"!=typeof r)throw new Error("Unexpected errors compiling std");return r}class Fe{constants;heap;stdlib;constructor({constants:e,heap:t},n,o){this.resolver=n,this.createOp=o,this.constants=e,this.heap=t,this.stdlib=Ae(this)}}function De(e,t,n){return new Fe(e,t,n)}function Ee(e,t){return{program:e,encoder:new W(e.heap,t,e.stdlib),meta:t}}const Be=new ne,Ne=["class","id","value","name","type","style","href"],Ge=["div","span","p","a"];function He(e){return"string"==typeof e?e:Ge[e]}function Ie(e){return"string"==typeof e?e:Ne[e]}function Te(e){return null===e?null:[e[0].map((e=>`@${e}`)),e[1]]}Be.add(F.Comment,((e,t)=>e(h.Comment,t[1]))),Be.add(F.CloseElement,(e=>e(h.CloseElement))),Be.add(F.FlushElement,(e=>e(h.FlushElement))),Be.add(F.Modifier,((e,[,t,n,o])=>{G(t)?e(x.Modifier,t,(t=>{e(f.PushFrame),re(e,n,o,!1),e(h.Modifier,t),e(f.PopFrame)})):(ae(e,t),e(f.PushFrame),re(e,n,o,!1),e(h.Dup,L,1),e(h.DynamicModifier),e(f.PopFrame))})),Be.add(F.StaticAttr,((e,[,t,n,o])=>{e(h.StaticAttr,Ie(t),n,o??null)})),Be.add(F.StaticComponentAttr,((e,[,t,n,o])=>{e(h.StaticComponentAttr,Ie(t),n,o??null)})),Be.add(F.DynamicAttr,((e,[,t,n,o])=>{ae(e,n),e(h.DynamicAttr,Ie(t),!1,o??null)})),Be.add(F.TrustingDynamicAttr,((e,[,t,n,o])=>{ae(e,n),e(h.DynamicAttr,Ie(t),!0,o??null)})),Be.add(F.ComponentAttr,((e,[,t,n,o])=>{ae(e,n),e(h.ComponentAttr,Ie(t),!1,o??null)})),Be.add(F.TrustingComponentAttr,((e,[,t,n,o])=>{ae(e,n),e(h.ComponentAttr,Ie(t),!0,o??null)})),Be.add(F.OpenElement,((e,[,t])=>{e(h.OpenElement,He(t))})),Be.add(F.OpenElementWithSplat,((e,[,t])=>{e(h.PutComponentOperations),e(h.OpenElement,He(t))})),Be.add(F.Component,((e,[,t,n,o,l])=>{N(t)?e(x.Component,t,(t=>{ge(e,t,n,null,o,l)})):Le(e,t,n,null,o,l,!0,!0)})),Be.add(F.Yield,((e,[,t,n])=>pe(e,t,n))),Be.add(F.AttrSplat,((e,[,t])=>pe(e,t,null))),Be.add(F.Debugger,((e,[,t])=>e(h.Debugger,{type:M.DebugSymbols,value:void 0},t))),Be.add(F.Append,((e,[,t])=>{if(Array.isArray(t))if(I(t))e(x.OptionalComponentOrHelper,t,{ifComponent(t){ge(e,t,null,null,null,null)},ifHelper(t){e(f.PushFrame),Z(e,t,null,null),e(f.InvokeStatic,U("cautious-non-dynamic-append")),e(f.PopFrame)},ifValue(t){e(f.PushFrame),e(h.ConstantReference,t),e(f.InvokeStatic,U("cautious-non-dynamic-append")),e(f.PopFrame)}});else if(t[0]===F.Call){let[,n,o,l]=t;I(n)?e(x.ComponentOrHelper,n,{ifComponent(t){ge(e,t,null,o,Te(l),null)},ifHelper(t){e(f.PushFrame),Z(e,t,o,l),e(f.InvokeStatic,U("cautious-non-dynamic-append")),e(f.PopFrame)}}):fe(e,(()=>{ae(e,n),e(h.DynamicContentType)}),(t=>{t(P.Component,(()=>{e(h.ResolveCurriedComponent),e(h.PushDynamicComponentInstance),ve(e,{capabilities:!0,elementBlock:null,positional:o,named:l,atNames:!1,blocks:q(null)})})),t(P.Helper,(()=>{ee(e,o,l,(()=>{e(f.InvokeStatic,U("cautious-non-dynamic-append"))}))}))}))}else e(f.PushFrame),ae(e,t),e(f.InvokeStatic,U("cautious-append")),e(f.PopFrame);else e(h.Text,null==t?"":String(t))})),Be.add(F.TrustingAppend,((e,[,t])=>{Array.isArray(t)?(e(f.PushFrame),ae(e,t),e(f.InvokeStatic,U("trusting-append")),e(f.PopFrame)):e(h.Text,null==t?"":String(t))})),Be.add(F.Block,((e,[,t,n,o,l])=>{N(t)?e(x.Component,t,(t=>{ge(e,t,null,n,Te(o),l)})):Le(e,t,null,n,o,l,!1,!1)})),Be.add(F.InElement,((e,[,t,n,o,l])=>{ye(e,(()=>(ae(e,n),void 0===l?Q(e,void 0):ae(e,l),ae(e,o),e(h.Dup,v,0),4)),(()=>{e(h.PushRemoteElement),me(e,t),e(h.PopRemoteElement)}))})),Be.add(F.If,((e,[,t,n,o])=>ye(e,(()=>(ae(e,t),e(h.ToBoolean),1)),(()=>{me(e,n)}),o?()=>{me(e,o)}:void 0))),Be.add(F.Each,((e,[,t,n,o,l])=>be(e,(()=>(n?ae(e,n):Q(e,null),ae(e,t),2)),(()=>{e(h.EnterList,V("BODY"),V("ELSE")),e(f.PushFrame),e(h.Dup,L,1),e(f.ReturnTo,V("ITER")),e(O.Label,"ITER"),e(h.Iterate,V("BREAK")),e(O.Label,"BODY"),de(e,o,2),e(h.Pop,2),e(f.Jump,V("FINALLY")),e(O.Label,"BREAK"),e(f.PopFrame),e(h.ExitList),e(f.Jump,V("FINALLY")),e(O.Label,"ELSE"),l&&me(e,l)})))),Be.add(F.Let,((e,[,t,n])=>{de(e,n,ie(e,t))})),Be.add(F.WithDynamicVars,((e,[,t,n])=>{if(t){let[o,l]=t;ie(e,l),function(e,t,n){e(h.PushDynamicScope),e(h.BindDynamicScope,t),n(),e(h.PopDynamicScope)}(e,o,(()=>{me(e,n)}))}else me(e,n)})),Be.add(F.InvokeComponent,((e,[,t,n,o,l])=>{N(t)?e(x.Component,t,(t=>{ge(e,t,null,n,Te(o),l)})):Le(e,t,null,n,o,l,!1,!1)}));class xe{compiled=null;constructor(e,t,n,o="plain block"){this.statements=e,this.meta=t,this.symbolTable=n,this.moduleName=o}compile(e){return function(e,t){if(null!==e.compiled)return e.compiled;e.compiled=-1;let{statements:n,meta:o}=e,l=Me(n,o,t);return e.compiled=l,l}(this,e)}}function Oe(e,t){let[n,o,l]=e.block;return new xe(n,se(e),{symbols:o,hasEval:l},t)}function Me(e,t,n){let o=Be,l=Ee(n,t),{encoder:a,program:{constants:r,resolver:i}}=l;function s(...e){z(a,r,i,t,e)}for(const t of e)o.compile(s,t);return l.encoder.commit(t.size)}const Ve={dynamicLayout:!0,dynamicTag:!0,prepareArgs:!0,createArgs:!0,attributeHook:!1,elementHook:!1,dynamicScope:!0,createCaller:!1,updateHook:!0,createInstance:!0,wrapped:!1,willDestroy:!1,hasSubOwner:!1},Re={dynamicLayout:!1,dynamicTag:!1,prepareArgs:!1,createArgs:!1,attributeHook:!1,elementHook:!1,dynamicScope:!1,createCaller:!1,updateHook:!1,createInstance:!1,wrapped:!1,willDestroy:!1,hasSubOwner:!1};class Ue{symbolTable;compiled=null;attrsBlockNumber;constructor(e,t){this.layout=e,this.moduleName=t;let{block:n}=e,[,o,l]=n;o=o.slice();let a=o.indexOf(Se);this.attrsBlockNumber=-1===a?o.push(Se):a+1,this.symbolTable={hasEval:l,symbols:o}}compile(e){if(null!==this.compiled)return this.compiled;let t=se(this.layout),n=Ee(e,t),{encoder:o,program:{constants:l,resolver:a}}=n;var r,i,s;r=function(...e){z(o,l,a,t,e)},i=this.layout,s=this.attrsBlockNumber,r(O.StartLabels),function(e,t,n){e(h.Fetch,t),n(),e(h.Load,t)}(r,A,(()=>{r(h.GetComponentTagName,C),r(h.PrimitiveReference),r(h.Dup,v,0)})),r(h.JumpUnless,V("BODY")),r(h.Fetch,A),r(h.PutComponentOperations),r(h.OpenDynamicElement),r(h.DidCreateElement,C),pe(r,s,null),r(h.FlushElement),r(O.Label,"BODY"),me(r,[i.block[0],[]]),r(h.Fetch,A),r(h.JumpUnless,V("END")),r(h.CloseElement),r(O.Label,"END"),r(h.Load,A),r(O.StopLabels);let u=n.encoder.commit(t.size);return"number"!=typeof u||(this.compiled=u),u}}let Je=0,Ye={cacheHit:0,cacheMiss:0};function Ke({id:e,moduleName:t,block:n,scope:o,isStrictMode:l}){let a,r=e||"client-"+Je++,i=null,s=new WeakMap,u=e=>{if(void 0===a&&(a=JSON.parse(n)),void 0===e)return null===i?(Ye.cacheMiss++,i=new ze({id:r,block:a,moduleName:t,owner:null,scope:o,isStrictMode:l})):Ye.cacheHit++,i;let u=s.get(e);return void 0===u?(Ye.cacheMiss++,u=new ze({id:r,block:a,moduleName:t,owner:e,scope:o,isStrictMode:l}),s.set(e,u)):Ye.cacheHit++,u};return u.__id=r,u.__meta={moduleName:t},u}class ze{result="ok";layout=null;wrappedLayout=null;constructor(e){this.parsedLayout=e}get moduleName(){return this.parsedLayout.moduleName}get id(){return this.parsedLayout.id}get referrer(){return{moduleName:this.parsedLayout.moduleName,owner:this.parsedLayout.owner}}asLayout(){return this.layout?this.layout:this.layout=Oe(u({},this.parsedLayout),this.moduleName)}asWrappedLayout(){return this.wrappedLayout?this.wrappedLayout:this.wrappedLayout=new Ue(u({},this.parsedLayout),this.moduleName)}}export{Fe as CompileTimeCompilationContextImpl,Ve as DEFAULT_CAPABILITIES,_ as EMPTY_BLOCKS,Re as MINIMAL_CAPABILITIES,j as StdLib,Ue as WrappedBuilder,Oe as compilable,Me as compileStatements,Ae as compileStd,E as debugCompiler,me as invokeStaticBlock,de as invokeStaticBlockWithStack,se as meta,De as programCompilationContext,Ye as templateCacheCounters,Ee as templateCompilationContext,Ke as templateFactory};
//# sourceMappingURL=index.js.map
