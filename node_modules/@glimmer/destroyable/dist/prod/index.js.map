{"version":3,"file":"index.js","sources":["../../index.ts"],"sourcesContent":["import type { Destroyable, Destructor } from '@glimmer/interfaces';\nimport { scheduleDestroy, scheduleDestroyed } from '@glimmer/global-context';\nimport { debugToString } from '@glimmer/util';\n\nconst enum DestroyingState {\n  Live = 0,\n  Destroying = 1,\n  Destroyed = 2,\n}\n\ntype OneOrMany<T> = null | T | T[];\n\ninterface DestroyableMeta<T extends Destroyable> {\n  source?: T;\n  parents: OneOrMany<Destroyable>;\n  children: OneOrMany<Destroyable>;\n  eagerDestructors: OneOrMany<Destructor<T>>;\n  destructors: OneOrMany<Destructor<T>>;\n  state: DestroyingState;\n}\n\ninterface UndestroyedDestroyablesError extends Error {\n  destroyables: object[];\n}\n\nlet DESTROYABLE_META:\n  | Map<Destroyable, DestroyableMeta<Destroyable>>\n  | WeakMap<Destroyable, DestroyableMeta<Destroyable>> = new WeakMap();\n\nfunction push<T extends object>(collection: OneOrMany<T>, newItem: T): OneOrMany<T> {\n  if (collection === null) {\n    return newItem;\n  } else if (Array.isArray(collection)) {\n    collection.push(newItem);\n    return collection;\n  } else {\n    return [collection, newItem];\n  }\n}\n\nfunction iterate<T extends object>(collection: OneOrMany<T>, fn: (item: T) => void) {\n  if (Array.isArray(collection)) {\n    collection.forEach(fn);\n  } else if (collection !== null) {\n    fn(collection);\n  }\n}\n\nfunction remove<T extends object>(collection: OneOrMany<T>, item: T, message: string | false) {\n  if (import.meta.env.DEV) {\n    let collectionIsItem = collection === item;\n    let collectionContainsItem = Array.isArray(collection) && collection.indexOf(item) !== -1;\n\n    if (!collectionIsItem && !collectionContainsItem) {\n      throw new Error(String(message));\n    }\n  }\n\n  if (Array.isArray(collection) && collection.length > 1) {\n    let index = collection.indexOf(item);\n    collection.splice(index, 1);\n    return collection;\n  } else {\n    return null;\n  }\n}\n\nfunction getDestroyableMeta<T extends Destroyable>(destroyable: T): DestroyableMeta<T> {\n  let meta = DESTROYABLE_META.get(destroyable);\n\n  if (meta === undefined) {\n    meta = {\n      parents: null,\n      children: null,\n      eagerDestructors: null,\n      destructors: null,\n      state: DestroyingState.Live,\n    };\n\n    if (import.meta.env.DEV) {\n      meta.source = destroyable as object;\n    }\n\n    DESTROYABLE_META.set(destroyable, meta);\n  }\n\n  return meta as unknown as DestroyableMeta<T>;\n}\n\nexport function associateDestroyableChild<T extends Destroyable>(parent: Destroyable, child: T): T {\n  if (import.meta.env.DEV && isDestroying(parent)) {\n    throw new Error(\n      'Attempted to associate a destroyable child with an object that is already destroying or destroyed'\n    );\n  }\n\n  let parentMeta = getDestroyableMeta(parent);\n  let childMeta = getDestroyableMeta(child);\n\n  parentMeta.children = push(parentMeta.children, child);\n  childMeta.parents = push(childMeta.parents, parent);\n\n  return child;\n}\n\nexport function registerDestructor<T extends Destroyable>(\n  destroyable: T,\n  destructor: Destructor<T>,\n  eager = false\n): Destructor<T> {\n  if (import.meta.env.DEV && isDestroying(destroyable)) {\n    throw new Error(\n      'Attempted to register a destructor with an object that is already destroying or destroyed'\n    );\n  }\n\n  let meta = getDestroyableMeta(destroyable);\n\n  let destructorsKey: 'eagerDestructors' | 'destructors' =\n    eager === true ? 'eagerDestructors' : 'destructors';\n\n  meta[destructorsKey] = push(meta[destructorsKey], destructor);\n\n  return destructor;\n}\n\nexport function unregisterDestructor<T extends Destroyable>(\n  destroyable: T,\n  destructor: Destructor<T>,\n  eager = false\n): void {\n  if (import.meta.env.DEV && isDestroying(destroyable)) {\n    throw new Error(\n      'Attempted to unregister a destructor with an object that is already destroying or destroyed'\n    );\n  }\n\n  let meta = getDestroyableMeta(destroyable);\n\n  let destructorsKey: 'eagerDestructors' | 'destructors' =\n    eager === true ? 'eagerDestructors' : 'destructors';\n\n  meta[destructorsKey] = remove(\n    meta[destructorsKey],\n    destructor,\n    import.meta.env.DEV &&\n      'attempted to remove a destructor that was not registered with the destroyable'\n  );\n}\n\n////////////\n\nexport function destroy(destroyable: Destroyable) {\n  let meta = getDestroyableMeta(destroyable);\n\n  if (meta.state >= DestroyingState.Destroying) return;\n\n  let { parents, children, eagerDestructors, destructors } = meta;\n\n  meta.state = DestroyingState.Destroying;\n\n  iterate(children, destroy);\n  iterate(eagerDestructors, (destructor) => destructor(destroyable));\n  iterate(destructors, (destructor) => scheduleDestroy(destroyable, destructor));\n\n  scheduleDestroyed(() => {\n    iterate(parents, (parent) => removeChildFromParent(destroyable, parent));\n\n    meta.state = DestroyingState.Destroyed;\n  });\n}\n\nfunction removeChildFromParent(child: Destroyable, parent: Destroyable) {\n  let parentMeta = getDestroyableMeta(parent);\n\n  if (parentMeta.state === DestroyingState.Live) {\n    parentMeta.children = remove(\n      parentMeta.children,\n      child,\n      import.meta.env.DEV &&\n        \"attempted to remove child from parent, but the parent's children did not contain the child. This is likely a bug with destructors.\"\n    );\n  }\n}\n\nexport function destroyChildren(destroyable: Destroyable) {\n  let { children } = getDestroyableMeta(destroyable);\n\n  iterate(children, destroy);\n}\n\nexport function _hasDestroyableChildren(destroyable: Destroyable) {\n  let meta = DESTROYABLE_META.get(destroyable);\n\n  return meta === undefined ? false : meta.children !== null;\n}\n\nexport function isDestroying(destroyable: Destroyable) {\n  let meta = DESTROYABLE_META.get(destroyable);\n\n  return meta === undefined ? false : meta.state >= DestroyingState.Destroying;\n}\n\nexport function isDestroyed(destroyable: Destroyable) {\n  let meta = DESTROYABLE_META.get(destroyable);\n\n  return meta === undefined ? false : meta.state >= DestroyingState.Destroyed;\n}\n\n////////////\n\nexport let enableDestroyableTracking: undefined | (() => void);\nexport let assertDestroyablesDestroyed: undefined | (() => void);\n\nif (import.meta.env.DEV) {\n  let isTesting = false;\n\n  enableDestroyableTracking = () => {\n    if (isTesting) {\n      // Reset destroyable meta just in case, before throwing the error\n      DESTROYABLE_META = new WeakMap();\n      throw new Error(\n        'Attempted to start destroyable testing, but you did not end the previous destroyable test. Did you forget to call `assertDestroyablesDestroyed()`'\n      );\n    }\n\n    isTesting = true;\n    DESTROYABLE_META = new Map();\n  };\n\n  assertDestroyablesDestroyed = () => {\n    if (!isTesting) {\n      throw new Error(\n        'Attempted to assert destroyables destroyed, but you did not start a destroyable test. Did you forget to call `enableDestroyableTracking()`'\n      );\n    }\n\n    isTesting = false;\n\n    let map = DESTROYABLE_META as Map<Destroyable, DestroyableMeta<Destroyable>>;\n    DESTROYABLE_META = new WeakMap();\n\n    let undestroyed: object[] = [];\n\n    map.forEach((meta) => {\n      if (meta.state !== DestroyingState.Destroyed) {\n        undestroyed.push(meta.source!);\n      }\n    });\n\n    if (undestroyed.length > 0) {\n      let objectsToString = undestroyed.map(debugToString!).join('\\n    ');\n      let error = new Error(\n        `Some destroyables were not destroyed during this test:\\n    ${objectsToString}`\n      ) as UndestroyedDestroyablesError;\n\n      error.destroyables = undestroyed;\n\n      throw error;\n    }\n  };\n}\n"],"names":["DestroyingState","enableDestroyableTracking","assertDestroyablesDestroyed","DESTROYABLE_META","WeakMap","push","collection","newItem","Array","isArray","iterate","fn","forEach","remove","item","message","length","index","indexOf","splice","getDestroyableMeta","destroyable","meta","get","undefined","parents","children","eagerDestructors","destructors","state","Live","set","associateDestroyableChild","parent","child","parentMeta","childMeta","registerDestructor","destructor","eager","destructorsKey","unregisterDestructor","destroy","Destroying","scheduleDestroy","scheduleDestroyed","removeChildFromParent","Destroyed","destroyChildren","_hasDestroyableChildren","isDestroying","isDestroyed"],"mappings":"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"}