import{assertNever as e,dict as t,expect as r,isPresentArray as n,values as s,assert as a,NS_XMLNS as l,NS_XML as o,NS_XLINK as i,exhausted as c,mapPresentArray as u,getLast as p,assertPresentArray as m}from"@glimmer/util";import{VariableResolutionContext as d,SexpOpcodes as h,WellKnownTagNames as f,WellKnownAttrNames as k}from"@glimmer/wire-format";import{node as y,KEYWORDS_TYPES as g,ASTv2 as A,isKeyword as v,generateSyntaxError as w,SourceSlice as x,src as b,maybeLoc as E,loc as C,normalize as B}from"@glimmer/syntax";import{CurriedTypes as S}from"@glimmer/vm";let O=function(e){return e.Block="Block",e.Call="Call",e.Element="Element",e.AppendPath="AppendPath",e.AppendExpr="AppendExpr",e.Literal="Literal",e.Modifier="Modifier",e.DynamicComponent="DynamicComponent",e.Comment="Comment",e.Splat="Splat",e.Keyword="Keyword",e}({}),H=function(e){return e.Local="Local",e.Free="Free",e.Arg="Arg",e.Block="Block",e.This="This",e}({});function P(n){if(Array.isArray(n))return function(e){if(!Array.isArray(e))return!1;const t=e[0];if("number"==typeof t)switch(t){case j.Literal:case j.Get:case j.Concat:case j.HasBlock:case j.HasBlockParams:return!0;default:return!1}return"("===t[0]}(n)?U(n):function(e){if(Array.isArray(e)&&"string"==typeof e[0])switch(e[0][0]){case"(":case"#":case"<":case"!":return!0;default:return!1}return!1}(n)?function(e){const n=e[0];switch(n[0]){case"(":{let t=null,r=null;return 3===e.length?(t=Y(e[1]),r=J(e[2])):2===e.length&&(Array.isArray(e[1])?t=Y(e[1]):r=J(e[1])),{kind:O.Call,head:L(n),params:t,hash:r,trusted:!1}}case"#":{const{head:t,params:r,hash:n,blocks:s,blockParams:a}=M(e);return{kind:O.Block,head:t,params:r,hash:n,blocks:s,blockParams:a}}case"!":{const t=e[0].slice(1),{params:r,hash:n,blocks:s,blockParams:a}=M(e);return{kind:O.Keyword,name:t,params:r,hash:n,blocks:s,blockParams:a}}case"<":{let s=t(),a=[];return 3===e.length?(s=_(e[1]),a=F(e[2])):2===e.length&&(Array.isArray(e[1])?a=F(e[1]):s=_(e[1])),{kind:O.Element,name:r(K(n),`BUG: expected ${n} to look like a tag name`),attrs:s,block:a}}default:throw new Error(`Unreachable ${JSON.stringify(e)} in normalizeSugaryArrayStatement`)}}(n):function(e){switch(e[0]){case j.Literal:return{kind:O.Literal,value:e[1]};case j.Append:return U(e[1],e[2]);case j.Modifier:return{kind:O.Modifier,params:Y(e[1]),hash:J(e[2])};case j.DynamicComponent:return{kind:O.DynamicComponent,expr:W(e[1]),hash:J(e[2]),block:F(e[3])};case j.Comment:return{kind:O.Comment,value:e[1]}}}(n);if("string"==typeof n)return T($(n),!1);throw e(n)}function T(e,t){return e.type===z.GetPath?{kind:O.AppendPath,path:e,trusted:t}:{kind:O.AppendExpr,expr:e,trusted:t}}function N(e){const t=/^(#|!)(.*)$/u.exec(e);if(null===t)throw new Error("Unexpected missing # in block head");return $(t[2])}function L(e){const t=/^\((.*)\)$/u.exec(e);if(null===t)throw new Error("Unexpected missing () in call head");return $(t[1])}function I(e,t=[]){const r=G(e);return n(t)?{type:z.GetPath,path:{head:r,tail:t}}:{type:z.GetVar,variable:r}}function $(e){const{kind:t,name:r}=G(e),[s,...a]=r.split("."),l={kind:t,name:s,mode:"loose"};return n(a)?{type:z.GetPath,path:{head:l,tail:a}}:{type:z.GetVar,variable:l}}function G(e){let t,r;if(/^this(?:\.|$)/u.test(e))return{kind:H.This,name:e,mode:"loose"};switch(e[0]){case"^":t=H.Free,r=e.slice(1);break;case"@":t=H.Arg,r=e.slice(1);break;case"&":t=H.Block,r=e.slice(1);break;default:t=H.Local,r=e}return{kind:t,name:r,mode:"loose"}}function M(e){const r=e[0];let n=t(),s=null,a=null,l=null;return 2===e.length?n=V(e[1]):3===e.length?(Array.isArray(e[1])?s=Y(e[1]):({hash:a,blockParams:l}=D(e[1])),n=V(e[2])):4===e.length&&(s=Y(e[1]),({hash:a,blockParams:l}=D(e[2])),n=V(e[3])),{head:N(r),params:s,hash:a,blockParams:l,blocks:n}}function D(e){if(null===e)return{hash:null,blockParams:null};let r=null,n=null;return function(e,t){Object.keys(e).forEach((r=>{const n=e[r];t(r,n)}))}(e,((e,s)=>{"as"===e?n=Array.isArray(s)?s:[s]:(r=r||t(),r[e]=W(s))})),{hash:r,blockParams:n}}function V(e){return Array.isArray(e)?{default:F(e)}:q(e,F)}function F(e){return e.map((e=>P(e)))}function _(e){return q(e,(e=>{return(t=e,"splat"===t?{expr:O.Splat,trusted:!1}:{expr:W(t),trusted:!1}).expr;var t}))}function q(e,r){const n=t();return Object.keys(e).forEach((t=>{n[t]=r(e[t],t)})),n}function K(e){const t=/^<([\d\-a-z][\d\-A-Za-z]*)>$/u.exec(e);return t?.[1]??null}let j=function(e){return e[e.Literal=0]="Literal",e[e.Comment=1]="Comment",e[e.Append=2]="Append",e[e.Modifier=3]="Modifier",e[e.DynamicComponent=4]="DynamicComponent",e[e.Get=5]="Get",e[e.Concat=6]="Concat",e[e.HasBlock=7]="HasBlock",e[e.HasBlockParams=8]="HasBlockParams",e}({}),z=function(e){return e.Literal="Literal",e.Call="Call",e.GetPath="GetPath",e.GetVar="GetVar",e.Concat="Concat",e.HasBlock="HasBlock",e.HasBlockParams="HasBlockParams",e}({});function U(t,r=!1){if(null==t)return{expr:{type:z.Literal,value:t},kind:O.AppendExpr,trusted:!1};if(Array.isArray(t))switch(t[0]){case j.Literal:return{expr:{type:z.Literal,value:t[1]},kind:O.AppendExpr,trusted:!1};case j.Get:return T(I(t[1],t[2]),r);case j.Concat:return{expr:{type:z.Concat,params:Y(t.slice(1))},kind:O.AppendExpr,trusted:r};case j.HasBlock:return{expr:{type:z.HasBlock,name:t[1]},kind:O.AppendExpr,trusted:r};case j.HasBlockParams:return{expr:{type:z.HasBlockParams,name:t[1]},kind:O.AppendExpr,trusted:r};default:if(R(t))return{expr:X(t),kind:O.AppendExpr,trusted:r};throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if("object"==typeof t)throw e(t);switch(typeof t){case"string":return T($(t),r);case"boolean":case"number":return{expr:{type:z.Literal,value:t},kind:O.AppendExpr,trusted:!0};default:throw e(t)}}}function W(t){if(null==t)return{type:z.Literal,value:t};if(Array.isArray(t))switch(t[0]){case j.Literal:return{type:z.Literal,value:t[1]};case j.Get:return I(t[1],t[2]);case j.Concat:return{type:z.Concat,params:Y(t.slice(1))};case j.HasBlock:return{type:z.HasBlock,name:t[1]};case j.HasBlockParams:return{type:z.HasBlockParams,name:t[1]};default:if(R(t))return X(t);throw new Error(`Unexpected array in expression position (wasn't a tuple expression and ${t[0]} isn't wrapped in parens, so it isn't a call): ${JSON.stringify(t)}`)}else{if("object"==typeof t)throw e(t);switch(typeof t){case"string":return $(t);case"boolean":case"number":return{type:z.Literal,value:t};default:throw e(t)}}}function R(e){return"string"==typeof e[0]&&"("===e[0][0]}function Y(e){return e.map(W)}function J(e){return null===e?null:q(e,W)}function X(e){switch(e.length){case 1:return{type:z.Call,head:L(e[0]),params:null,hash:null};case 2:return Array.isArray(e[1])?{type:z.Call,head:L(e[0]),params:Y(e[1]),hash:null}:{type:z.Call,head:L(e[0]),params:null,hash:J(e[1])};case 3:return{type:z.Call,head:L(e[0]),params:Y(e[1]),hash:J(e[2])}}}class Z{_freeVariables=[];_symbols=["this"];top=this;toSymbols(){return this._symbols.slice(1)}toUpvars(){return this._freeVariables}freeVar(e){return ee(this._freeVariables,e)}block(e){return this.symbol(e)}arg(e){return ee(this._symbols,e)}local(e){throw new Error(`No local ${e} was found. Maybe you meant ^${e} for upvar, or !${e} for keyword?`)}this(){return 0}hasLocal(e){return!1}symbol(e){return ee(this._symbols,e)}child(e){return new Q(this,e)}}class Q{locals=t();constructor(e,t){this.parent=e;for(let r of t)this.locals[r]=e.top.symbol(r)}get paramSymbols(){return s(this.locals)}get top(){return this.parent.top}freeVar(e){return this.parent.freeVar(e)}arg(e){return this.parent.arg(e)}block(e){return this.parent.block(e)}local(e){return e in this.locals?this.locals[e]:this.parent.local(e)}this(){return this.parent.this()}hasLocal(e){return e in this.locals||this.parent.hasLocal(e)}child(e){return new Q(this,e)}}function ee(e,t){let r=e.indexOf(t);return-1===r?(r=e.length,e.push(t),r):r}function te(e){return new Error(`unimplemented ${e}`)}function re(e,t){let r=[];return e.forEach((e=>r.push(...se(P(e),t)))),r}function ne(e,t){let r=[];return e.forEach((e=>r.push(...se(e,t)))),r}function se(t,r=new Z){switch(t.kind){case O.AppendPath:return[[t.trusted?h.TrustingAppend:h.Append,ke(t.path,r)]];case O.AppendExpr:return[[t.trusted?h.TrustingAppend:h.Append,he(t.expr,t.trusted?"TrustedAppend":"Append",r)]];case O.Call:{let{head:e,params:n,hash:s,trusted:a}=t,l=n?ge(n,r):null,o=s?ve(s,r):null,i=fe(e,a?d.ResolveAsHelperHead:d.ResolveAsComponentOrHelperHead,r);return[[a?h.TrustingAppend:h.Append,[h.Call,i,l,o]]]}case O.Literal:return[[h.Append,t.value]];case O.Comment:return[[h.Comment,t.value]];case O.Block:{let e=function(e,t,r){let n=[],s=[];for(const[a,l]of Object.entries(e))if(n.push(a),"default"===a){let e=r.child(t||[]);s.push(we(l,e,e.paramSymbols))}else s.push(we(l,r,[]));return[n,s]}(t.blocks,t.blockParams,r),n=ve(t.hash,r),s=ge(t.params,r),a=fe(t.head,d.ResolveAsComponentHead,r);return[[h.Block,a,s,n,e]]}case O.Keyword:return[ce(t,r)];case O.Element:return function({name:t,attrs:r,block:s},l){let o=[ue(r)?[h.OpenElementWithSplat,t]:[h.OpenElement,t]];if(r){let{params:e,args:t}=function(e,t){let r=[],s=[],a=[];for(const[n,l]of Object.entries(e))l===O.Splat?r.push([h.AttrSplat,t.block("&attrs")]):"@"===n[0]?(s.push(n),a.push(he(l,"Strict",t))):r.push(...me(n,l,pe(n),t));return{params:r,args:n(s)&&n(a)?[s,a]:null}}(r,l);o.push(...e),a(null===t,"Can't pass args to a simple element")}if(o.push([h.FlushElement]),Array.isArray(s))s.forEach((e=>o.push(...se(e,l))));else if(null!==s)throw e(s);return o.push([h.CloseElement]),o}(t,r);case O.Modifier:throw te("modifier");case O.DynamicComponent:throw te("dynamic component");default:throw e(t)}}function ae(e,...t){let r=e.reduce(((e,r,n)=>e+`${r}${t[n]?String(t[n]):""}`),"");return[j.Literal,r]}function le(e,...t){let r=e.reduce(((e,r,n)=>e+`${r}${t[n]?String(t[n]):""}`),"");return[j.Comment,r]}function oe(e){return String.fromCharCode(parseInt(e,16))}const ie="\n";function ce(e,t){let{name:n}=e,s=ge(e.params,t),a=t.child(e.blockParams||[]),l=we(e.blocks.default,a,a.paramSymbols),o=e.blocks.else?we(e.blocks.else,t,[]):null;switch(n){case"let":return[h.Let,r(s,"let requires params"),l];case"if":return[h.If,r(s,"if requires params")[0],l,o];case"each":{let n=e.hash?e.hash.key:null,a=n?he(n,"Strict",t):null;return[h.Each,r(s,"if requires params")[0],a,l,o]}default:throw new Error("unimplemented keyword")}}function ue(e){return null!==e&&Object.keys(e).some((t=>e[t]===O.Splat))}function pe(e){if("xmlns"===e)return l;let t=/^([^:]*):([^:]*)$/u.exec(e);if(null===t)return null;switch(t[1]){case"xlink":return i;case"xml":return o;case"xmlns":return l}return null}function me(e,t,r,n){if(t.type===z.Literal){let n=t.value;if(!1===n)return[];if(!0===n)return[[h.StaticAttr,e,"",r??void 0]];if("string"==typeof n)return[[h.StaticAttr,e,n,r??void 0]];throw new Error(`Unexpected/unimplemented literal attribute ${JSON.stringify(n)}`)}return[[h.DynamicAttr,e,he(t,"AttrValue",n),r??void 0]]}function de(e,t){switch(e){case"Append":return t?"AppendBare":"AppendInvoke";case"TrustedAppend":return t?"TrustedAppendBare":"TrustedAppendInvoke";case"AttrValue":return t?"AttrValueBare":"AttrValueInvoke";default:return e}}function he(t,r,n){switch(t.type){case z.GetPath:return ke(t,n);case z.GetVar:return ye(t.variable,de(r,!0),n);case z.Concat:return[h.Concat,Ae(t.params,n)];case z.Call:{let e=ge(t.params,n),s=ve(t.hash,n),a=fe(t.head,"Strict"===r?"SubExpression":de(r,!1),n);return[h.Call,a,e,s]}case z.HasBlock:return[h.HasBlock,ye({kind:H.Block,name:t.name,mode:"loose"},d.Strict,n)];case z.HasBlockParams:return[h.HasBlockParams,ye({kind:H.Block,name:t.name,mode:"loose"},d.Strict,n)];case z.Literal:return void 0===t.value?[h.Undefined]:t.value;default:e(t)}}function fe(e,t,r){return e.type===z.GetVar?ye(e.variable,t,r):ke(e,r)}function ke(e,t){return ye(e.path.head,d.Strict,t,e.path.tail)}function ye(e,t,r,n){let s,l=h.GetSymbol;return e.kind===H.Free?(l="Strict"===t?h.GetStrictKeyword:"AppendBare"===t||"AppendInvoke"===t?h.GetFreeAsComponentOrHelperHead:"TrustedAppendBare"===t||"TrustedAppendInvoke"===t||"AttrValueBare"===t||"AttrValueInvoke"===t||"SubExpression"===t?h.GetFreeAsHelperHead:function(e){switch(e){case d.Strict:return h.GetStrictKeyword;case d.ResolveAsComponentOrHelperHead:return h.GetFreeAsComponentOrHelperHead;case d.ResolveAsHelperHead:return h.GetFreeAsHelperHead;case d.ResolveAsModifierHead:return h.GetFreeAsModifierHead;case d.ResolveAsComponentHead:return h.GetFreeAsComponentHead;default:return c(e)}}(t),s=r.freeVar(e.name)):(l=h.GetSymbol,s=function(e,t,r){switch(e){case H.Arg:return t.arg(r);case H.Block:return t.block(r);case H.Local:return t.local(r);case H.This:return t.this();default:return c(e)}}(e.kind,r,e.name)),void 0===n||0===n.length?[l,s]:(a(l!==h.GetStrictKeyword,"[BUG] keyword with a path"),[l,s,n])}function ge(e,t){return null!==e&&n(e)?e.map((e=>he(e,"Strict",t))):null}function Ae(e,t){return e.map((e=>he(e,"AttrValue",t)))}function ve(e,t){if(null===e)return null;let r=[[],[]];for(const[n,s]of Object.entries(e))r[0].push(n),r[1].push(he(s,"Strict",t));return r}function we(e,t,r=[]){return[ne(e,t),r]}class xe extends(y("Template").fields()){}class be extends(y("InElement").fields()){}class Ee extends(y("Not").fields()){}class Ce extends(y("If").fields()){}class Be extends(y("IfInline").fields()){}class Se extends(y("Each").fields()){}class Oe extends(y("Let").fields()){}class He extends(y("WithDynamicVars").fields()){}class Pe extends(y("GetDynamicVar").fields()){}class Te extends(y("Log").fields()){}class Ne extends(y("InvokeComponent").fields()){}class Le extends(y("NamedBlocks").fields()){}class Ie extends(y("NamedBlock").fields()){}class $e extends(y("AppendTrustedHTML").fields()){}class Ge extends(y("AppendTextNode").fields()){}class Me extends(y("AppendComment").fields()){}class De extends(y("Component").fields()){}class Ve extends(y("StaticAttr").fields()){}class Fe extends(y("DynamicAttr").fields()){}class _e extends(y("SimpleElement").fields()){}class qe extends(y("ElementParameters").fields()){}class Ke extends(y("Yield").fields()){}class je extends(y("Debugger").fields()){}class ze extends(y("CallExpression").fields()){}class Ue extends(y("Modifier").fields()){}class We extends(y("InvokeBlock").fields()){}class Re extends(y("SplatAttr").fields()){}class Ye extends(y("PathExpression").fields()){}class Je extends(y("Missing").fields()){}class Xe extends(y("InterpolateExpression").fields()){}class Ze extends(y("HasBlock").fields()){}class Qe extends(y("HasBlockParams").fields()){}class et extends(y("Curry").fields()){}class tt extends(y("Positional").fields()){}class rt extends(y("NamedArguments").fields()){}class nt extends(y("NamedArgument").fields()){}class st extends(y("Args").fields()){}class at extends(y("Tail").fields()){}class lt{constructor(e){this.list=e}toArray(){return this.list}map(e){let t=u(this.list,e);return new lt(t)}filter(e){let t=[];for(let r of this.list)e(r)&&t.push(r);return it(t)}toPresentArray(){return this.list}into({ifPresent:e}){return e(this)}}class ot{list=[];map(e){return new ot}filter(e){return new ot}toArray(){return this.list}toPresentArray(){return null}into({ifEmpty:e}){return e()}}function it(e){return n(e)?new lt(e):new ot}class ct{static all(...e){let t=[];for(let r of e){if(r.isErr)return r.cast();t.push(r.value)}return dt(t)}}const ut=ct;class pt extends ct{isOk=!0;isErr=!1;constructor(e){super(),this.value=e}expect(e){return this.value}ifOk(e){return e(this.value),this}andThen(e){return e(this.value)}mapOk(e){return dt(e(this.value))}ifErr(e){return this}mapErr(e){return this}}class mt extends ct{isOk=!1;isErr=!0;constructor(e){super(),this.reason=e}expect(e){throw new Error(e||"expected an Ok, got Err")}andThen(e){return this.cast()}mapOk(e){return this.cast()}ifOk(e){return this}mapErr(e){return ht(e(this.reason))}ifErr(e){return e(this.reason),this}cast(){return this}}function dt(e){return new pt(e)}function ht(e){return new mt(e)}class ft{constructor(e=[]){this.items=e}add(e){this.items.push(e)}toArray(){let e=this.items.filter((e=>e instanceof mt))[0];return void 0!==e?e.cast():dt(this.items.map((e=>e.value)))}toOptionalList(){return this.toArray().mapOk((e=>it(e)))}}function kt(e){return"Path"===e.type&&"Free"===e.ref.type&&e.ref.name in g?new A.CallExpression({callee:e,args:A.Args.empty(e.loc),loc:e.loc}):e}const yt=new class{visit(e,t){switch(e.type){case"Literal":return dt(this.Literal(e));case"Keyword":return dt(this.Keyword(e));case"Interpolate":return this.Interpolate(e,t);case"Path":return this.PathExpression(e);case"Call":{let r=Vt.translate(e,t);return null!==r?r:this.CallExpression(e,t)}}}visitList(e,t){return new ft(e.map((e=>yt.visit(e,t)))).toOptionalList()}PathExpression(e){let t=this.VariableReference(e.ref),{tail:r}=e;if(n(r)){let n=r[0].loc.extend(p(r).loc);return dt(new Ye({loc:e.loc,head:t,tail:new at({loc:n,members:r})}))}return dt(t)}VariableReference(e){return e}Literal(e){return e}Keyword(e){return e}Interpolate(e,t){let r=e.parts.map(kt);return yt.visitList(r,t).mapOk((t=>new Xe({loc:e.loc,parts:t})))}CallExpression(e,t){if("Call"===e.callee.type)throw new Error("unimplemented: subexpression at the head of a subexpression");return ut.all(yt.visit(e.callee,t),yt.Args(e.args,t)).mapOk((([t,r])=>new ze({loc:e.loc,callee:t,args:r})))}Args({positional:e,named:t,loc:r},n){return ut.all(this.Positional(e,n),this.NamedArguments(t,n)).mapOk((([e,t])=>new st({loc:r,positional:e,named:t})))}Positional(e,t){return yt.visitList(e.exprs,t).mapOk((t=>new tt({loc:e.loc,list:t})))}NamedArguments(e,t){let r=e.entries.map((e=>{let r=kt(e.value);return yt.visit(r,t).mapOk((t=>new nt({loc:e.loc,key:e.name,value:t})))}));return new ft(r).toOptionalList().mapOk((t=>new rt({loc:e.loc,entries:t})))}};class gt{types;constructor(e,t,r){this.keyword=e,this.delegate=r;let n=new Set;for(let e of At[t])n.add(e);this.types=n}match(e){if(!this.types.has(e.type))return!1;let t=vt(e);return null!==t&&"Path"===t.type&&"Free"===t.ref.type&&t.ref.name===this.keyword}translate(e,t){if(this.match(e)){let r=vt(e);return null!==r&&"Path"===r.type&&r.tail.length>0?ht(w(`The \`${this.keyword}\` keyword was used incorrectly. It was used as \`${r.loc.asString()}\`, but it cannot be used with additional path segments. \n\nError caused by`,e.loc)):this.delegate.assert(e,t).andThen((r=>this.delegate.translate({node:e,state:t},r)))}return null}}const At={Call:["Call"],Block:["InvokeBlock"],Append:["AppendContent"],Modifier:["ElementModifier"]};function vt(e){switch(e.type){case"Path":return e;case"AppendContent":return vt(e.value);case"Call":case"InvokeBlock":case"ElementModifier":return e.callee;default:return null}}class wt{_keywords=[];_type;constructor(e){this._type=e}kw(e,t){return this._keywords.push(function(e,t,r){return new gt(e,t,r)}(e,this._type,t)),this}translate(e,t){for(let r of this._keywords){let n=r.translate(e,t);if(null!==n)return n}let r=vt(e);if(r&&"Path"===r.type&&"Free"===r.ref.type&&v(r.ref.name)){let{name:t}=r.ref,n=this._type,s=g[t];if(!s.includes(n))return ht(w(`The \`${t}\` keyword was used incorrectly. It was used as ${xt[n]}, but its valid usages are:\n\n${function(e,t){return t.map((t=>{switch(t){case"Append":return`- As an append statement, as in: {{${e}}}`;case"Block":return`- As a block statement, as in: {{#${e}}}{{/${e}}}`;case"Call":return`- As an expression, as in: (${e})`;case"Modifier":return`- As a modifier, as in: <div {{${e}}}></div>`;default:return c(t)}})).join("\n\n")}(t,s)}\n\nError caused by`,e.loc))}return null}}const xt={Append:"an append statement",Block:"a block statement",Call:"a call expression",Modifier:"a modifier"};function bt(e){return new wt(e)}function Et({assert:e,translate:t}){return{assert:e,translate:({node:e,state:r},n)=>t({node:e,state:r},n).mapOk((t=>new Ge({text:t,loc:e.loc})))}}const Ct={[S.Component]:"component",[S.Helper]:"helper",[S.Modifier]:"modifier"};function Bt(e){return(t,r)=>{let n=Ct[e],s=e===S.Component,{args:a}=t,l=a.nth(0);if(null===l)return ht(w(`(${n}) requires a ${n} definition or identifier as its first positional parameter, did not receive any parameters.`,a.loc));if("Literal"===l.type){if(s&&r.isStrict)return ht(w(`(${n}) cannot resolve string values in strict mode templates`,t.loc));if(!s)return ht(w(`(${n}) cannot resolve string values, you must pass a ${n} definition directly`,t.loc))}return a=new A.Args({positional:new A.PositionalArguments({exprs:a.positional.exprs.slice(1),loc:a.positional.loc}),named:a.named,loc:a.loc}),dt({definition:l,args:a})}}function St(e){return({node:t,state:r},{definition:n,args:s})=>{let a=yt.visit(n,r),l=yt.Args(s,r);return ut.all(a,l).mapOk((([r,n])=>new et({loc:t.loc,curriedType:e,definition:r,args:n})))}}function Ot(e){return{assert:Bt(e),translate:St(e)}}const Ht={assert:function(e){let t="AppendContent"===e.type?e.value:e,r="Call"===t.type?t.args.named:null,n="Call"===t.type?t.args.positional:null;if(r&&!r.isEmpty())return ht(w("(-get-dynamic-vars) does not take any named arguments",e.loc));let s=n?.nth(0);return s?n&&n.size>1?ht(w("(-get-dynamic-vars) only receives one positional arg",e.loc)):dt(s):ht(w("(-get-dynamic-vars) requires a var name to get",e.loc))},translate:function({node:e,state:t},r){return yt.visit(r,t).mapOk((t=>new Pe({name:t,loc:e.loc})))}};function Pt(e){return t=>{let r="AppendContent"===t.type?t.value:t,n="Call"===r.type?r.args.named:null,s="Call"===r.type?r.args.positional:null;if(n&&!n.isEmpty())return ht(w(`(${e}) does not take any named arguments`,r.loc));if(!s||s.isEmpty())return dt(x.synthetic("default"));if(1===s.exprs.length){let t=s.exprs[0];return A.isLiteral(t,"string")?dt(t.toSlice()):ht(w(`(${e}) can only receive a string literal as its first argument`,r.loc))}return ht(w(`(${e}) only takes a single positional argument`,r.loc))}}function Tt(e){return({node:t,state:{scope:r}},n)=>dt("has-block"===e?new Ze({loc:t.loc,target:n,symbol:r.allocateBlock(n.chars)}):new Qe({loc:t.loc,target:n,symbol:r.allocateBlock(n.chars)}))}function Nt(e){return{assert:Pt(e),translate:Tt(e)}}function Lt(e){return t=>{let r="unless"===e,n="AppendContent"===t.type?t.value:t,s="Call"===n.type?n.args.named:null,a="Call"===n.type?n.args.positional:null;if(s&&!s.isEmpty())return ht(w(`(${e}) cannot receive named parameters, received ${s.entries.map((e=>e.name.chars)).join(", ")}`,t.loc));let l=a?.nth(0);if(!a||!l)return ht(w(`When used inline, (${e}) requires at least two parameters 1. the condition that determines the state of the (${e}), and 2. the value to return if the condition is ${r?"false":"true"}. Did not receive any parameters`,t.loc));let o=a.nth(1),i=a.nth(2);return null===o?ht(w(`When used inline, (${e}) requires at least two parameters 1. the condition that determines the state of the (${e}), and 2. the value to return if the condition is ${r?"false":"true"}. Received only one parameter, the condition`,t.loc)):a.size>3?ht(w(`When used inline, (${e}) can receive a maximum of three positional parameters 1. the condition that determines the state of the (${e}), 2. the value to return if the condition is ${r?"false":"true"}, and 3. the value to return if the condition is ${r?"true":"false"}. Received ${a?.size??0} parameters`,t.loc)):dt({condition:l,truthy:o,falsy:i})}}function It(e){let t="unless"===e;return({node:e,state:r},{condition:n,truthy:s,falsy:a})=>{let l=yt.visit(n,r),o=yt.visit(s,r),i=a?yt.visit(a,r):dt(null);return ut.all(l,o,i).mapOk((([r,n,s])=>(t&&(r=new Ee({value:r,loc:e.loc})),new Be({loc:e.loc,condition:r,truthy:n,falsy:s}))))}}function $t(e){return{assert:Lt(e),translate:It(e)}}const Gt={assert:function(e){let{args:{named:t,positional:r}}=e;return t&&!t.isEmpty()?ht(w("(log) does not take any named arguments",e.loc)):dt(r)},translate:function({node:e,state:t},r){return yt.Positional(r,t).mapOk((t=>new Te({positional:t,loc:e.loc})))}},Mt=bt("Append").kw("has-block",Et(Nt("has-block"))).kw("has-block-params",Et(Nt("has-block-params"))).kw("-get-dynamic-var",Et(Ht)).kw("log",Et(Gt)).kw("if",Et($t("if"))).kw("unless",Et($t("unless"))).kw("yield",{assert(e){let{args:t}=e;if(t.named.isEmpty())return dt({target:b.SourceSpan.synthetic("default").toSlice(),positional:t.positional});{let e=t.named.get("to");return t.named.size>1||null===e?ht(w("yield only takes a single named argument: 'to'",t.named.loc)):A.isLiteral(e,"string")?dt({target:e.toSlice(),positional:t.positional}):ht(w("you can only yield to a literal string value",e.loc))}},translate:({node:e,state:t},{target:r,positional:n})=>yt.Positional(n,t).mapOk((n=>new Ke({loc:e.loc,target:r,to:t.scope.allocateBlock(r.chars),positional:n})))}).kw("debugger",{assert(e){let{args:t}=e,{positional:r}=t;return t.isEmpty()?dt(void 0):r.isEmpty()?ht(w("debugger does not take any named arguments",e.loc)):ht(w("debugger does not take any positional arguments",e.loc))},translate:({node:e,state:{scope:t}})=>(t.setHasDebugger(),dt(new je({loc:e.loc,scope:t})))}).kw("component",{assert:Bt(S.Component),translate({node:e,state:t},{definition:r,args:n}){let s=yt.visit(r,t),a=yt.Args(n,t);return ut.all(s,a).mapOk((([t,r])=>new Ne({loc:e.loc,definition:t,args:r,blocks:null})))}}).kw("helper",{assert:Bt(S.Helper),translate({node:e,state:t},{definition:r,args:n}){let s=yt.visit(r,t),a=yt.Args(n,t);return ut.all(s,a).mapOk((([t,r])=>{let n=new ze({callee:t,args:r,loc:e.loc});return new Ge({loc:e.loc,text:n})}))}}),Dt=bt("Block").kw("in-element",{assert(e){let{args:t}=e,r=t.get("guid");if(r)return ht(w("Cannot pass `guid` to `{{#in-element}}`",r.loc));let n=t.get("insertBefore"),s=t.nth(0);return null===s?ht(w("{{#in-element}} requires a target element as its first positional parameter",t.loc)):dt({insertBefore:n,destination:s})},translate({node:e,state:t},{insertBefore:r,destination:n}){let s=e.blocks.get("default"),a=tr.NamedBlock(s,t),l=yt.visit(n,t);return ut.all(a,l).andThen((([n,s])=>r?yt.visit(r,t).mapOk((e=>({body:n,destination:s,insertBefore:e}))):dt({body:n,destination:s,insertBefore:new Je({loc:e.callee.loc.collapse("end")})}))).mapOk((({body:r,destination:n,insertBefore:s})=>new be({loc:e.loc,block:r,insertBefore:s,guid:t.generateUniqueCursor(),destination:n})))}}).kw("if",{assert(e){let{args:t}=e;if(!t.named.isEmpty())return ht(w(`{{#if}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,e.loc));if(t.positional.size>1)return ht(w(`{{#if}} can only receive one positional parameter in block form, the conditional value. Received ${t.positional.size} parameters`,e.loc));let r=t.nth(0);return null===r?ht(w("{{#if}} requires a condition as its first positional parameter, did not receive any parameters",e.loc)):dt({condition:r})},translate({node:e,state:t},{condition:r}){let n=e.blocks.get("default"),s=e.blocks.get("else"),a=yt.visit(r,t),l=tr.NamedBlock(n,t),o=s?tr.NamedBlock(s,t):dt(null);return ut.all(a,l,o).mapOk((([t,r,n])=>new Ce({loc:e.loc,condition:t,block:r,inverse:n})))}}).kw("unless",{assert(e){let{args:t}=e;if(!t.named.isEmpty())return ht(w(`{{#unless}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,e.loc));if(t.positional.size>1)return ht(w(`{{#unless}} can only receive one positional parameter in block form, the conditional value. Received ${t.positional.size} parameters`,e.loc));let r=t.nth(0);return null===r?ht(w("{{#unless}} requires a condition as its first positional parameter, did not receive any parameters",e.loc)):dt({condition:r})},translate({node:e,state:t},{condition:r}){let n=e.blocks.get("default"),s=e.blocks.get("else"),a=yt.visit(r,t),l=tr.NamedBlock(n,t),o=s?tr.NamedBlock(s,t):dt(null);return ut.all(a,l,o).mapOk((([t,r,n])=>new Ce({loc:e.loc,condition:new Ee({value:t,loc:e.loc}),block:r,inverse:n})))}}).kw("each",{assert(e){let{args:t}=e;if(!t.named.entries.every((e=>"key"===e.name.chars)))return ht(w(`{{#each}} can only receive the 'key' named parameter, received ${t.named.entries.filter((e=>"key"!==e.name.chars)).map((e=>e.name.chars)).join(", ")}`,t.named.loc));if(t.positional.size>1)return ht(w(`{{#each}} can only receive one positional parameter, the collection being iterated. Received ${t.positional.size} parameters`,t.positional.loc));let r=t.nth(0),n=t.get("key");return null===r?ht(w("{{#each}} requires an iterable value to be passed as its first positional parameter, did not receive any parameters",t.loc)):dt({value:r,key:n})},translate({node:e,state:t},{value:r,key:n}){let s=e.blocks.get("default"),a=e.blocks.get("else"),l=yt.visit(r,t),o=n?yt.visit(n,t):dt(null),i=tr.NamedBlock(s,t),c=a?tr.NamedBlock(a,t):dt(null);return ut.all(l,o,i,c).mapOk((([t,r,n,s])=>new Se({loc:e.loc,value:t,key:r,block:n,inverse:s})))}}).kw("let",{assert(e){let{args:t}=e;return t.named.isEmpty()?0===t.positional.size?ht(w("{{#let}} requires at least one value as its first positional parameter, did not receive any parameters",t.positional.loc)):e.blocks.get("else")?ht(w("{{#let}} cannot receive an {{else}} block",t.positional.loc)):dt({positional:t.positional}):ht(w(`{{#let}} cannot receive named parameters, received ${t.named.entries.map((e=>e.name.chars)).join(", ")}`,t.named.loc))},translate({node:e,state:t},{positional:r}){let n=e.blocks.get("default"),s=yt.Positional(r,t),a=tr.NamedBlock(n,t);return ut.all(s,a).mapOk((([t,r])=>new Oe({loc:e.loc,positional:t,block:r})))}}).kw("-with-dynamic-vars",{assert:e=>dt({named:e.args.named}),translate({node:e,state:t},{named:r}){let n=e.blocks.get("default"),s=yt.NamedArguments(r,t),a=tr.NamedBlock(n,t);return ut.all(s,a).mapOk((([t,r])=>new He({loc:e.loc,named:t,block:r})))}}).kw("component",{assert:Bt(S.Component),translate({node:e,state:t},{definition:r,args:n}){let s=yt.visit(r,t),a=yt.Args(n,t),l=tr.NamedBlocks(e.blocks,t);return ut.all(s,a,l).mapOk((([t,r,n])=>new Ne({loc:e.loc,definition:t,args:r,blocks:n})))}}),Vt=bt("Call").kw("has-block",Nt("has-block")).kw("has-block-params",Nt("has-block-params")).kw("-get-dynamic-var",Ht).kw("log",Gt).kw("if",$t("if")).kw("unless",$t("unless")).kw("component",Ot(S.Component)).kw("helper",Ot(S.Helper)).kw("modifier",Ot(S.Modifier)),Ft=bt("Modifier"),_t="http://www.w3.org/1999/xlink",qt="http://www.w3.org/XML/1998/namespace",Kt="http://www.w3.org/2000/xmlns/",jt={"xlink:actuate":_t,"xlink:arcrole":_t,"xlink:href":_t,"xlink:role":_t,"xlink:show":_t,"xlink:title":_t,"xlink:type":_t,"xml:base":qt,"xml:lang":qt,"xml:space":qt,xmlns:Kt,"xmlns:xlink":Kt},zt={div:f.div,span:f.span,p:f.p,a:f.a},Ut=["div","span","p","a"];function Wt(e){return"string"==typeof e?e:Ut[e]}const Rt={class:k.class,id:k.id,value:k.value,name:k.name,type:k.type,style:k.style,href:k.href},Yt=["class","id","value","name","type","style","href"];function Jt(e){return Rt[e]??e}function Xt(e){return"string"==typeof e?e:Yt[e]}class Zt{delegate;constructor(e,t,r){this.element=e,this.state=r,this.delegate=t}toStatement(){return this.prepare().andThen((e=>this.delegate.toStatement(this,e)))}attr(e){let t=e.name,r=e.value,n=(s=t.chars,jt[s]||void 0);var s;return A.isLiteral(r,"string")?dt(new Ve({loc:e.loc,name:t,value:r.toSlice(),namespace:n,kind:{component:this.delegate.dynamicFeatures}})):yt.visit(kt(r),this.state).mapOk((r=>{let s=e.trusting;return new Fe({loc:e.loc,name:t,value:r,namespace:n,kind:{trusting:s,component:this.delegate.dynamicFeatures}})}))}modifier(e){let t=Ft.translate(e,this.state);if(null!==t)return t;let r=yt.visit(e.callee,this.state),n=yt.Args(e.args,this.state);return ut.all(r,n).mapOk((([t,r])=>new Ue({loc:e.loc,callee:t,args:r})))}attrs(){let e=new ft,t=new ft,r=null,n=0===this.element.attrs.filter((e=>"SplatAttr"===e.type)).length;for(let t of this.element.attrs)"SplatAttr"===t.type?e.add(dt(new Re({loc:t.loc,symbol:this.state.scope.allocateBlock("attrs")}))):"type"===t.name.chars&&n?r=t:e.add(this.attr(t));for(let e of this.element.componentArgs)t.add(this.delegate.arg(e,this));return r&&e.add(this.attr(r)),ut.all(t.toArray(),e.toArray()).mapOk((([e,t])=>({attrs:t,args:new rt({loc:E(e,b.SourceSpan.NON_EXISTENT),entries:it(e)})})))}prepare(){let e=this.attrs(),t=new ft(this.element.modifiers.map((e=>this.modifier(e)))).toArray();return ut.all(e,t).mapOk((([e,t])=>{let{attrs:r,args:n}=e,s=[...r,...t];return{args:n,params:new qe({loc:E(s,b.SourceSpan.NON_EXISTENT),body:it(s)})}}))}}class Qt{dynamicFeatures=!0;constructor(e,t){this.tag=e,this.element=t}arg(e,{state:t}){let r=e.name;return yt.visit(kt(e.value),t).mapOk((t=>new nt({loc:e.loc,key:r,value:t})))}toStatement(e,{args:t,params:r}){let{element:n,state:s}=e;return this.blocks(s).mapOk((e=>new De({loc:n.loc,tag:this.tag,params:r,args:t,blocks:e})))}blocks(e){return tr.NamedBlocks(this.element.blocks,e)}}class er{constructor(e,t,r){this.tag=e,this.element=t,this.dynamicFeatures=r}isComponent=!1;arg(e){return ht(w(`${e.name.chars} is not a valid attribute name. @arguments are only allowed on components, but the tag for this element (\`${this.tag.chars}\`) is a regular, non-component HTML element.`,e.loc))}toStatement(e,{params:t}){let{state:r,element:n}=e;return tr.visitList(this.element.body,r).mapOk((e=>new _e({loc:n.loc,tag:this.tag,params:t,body:e.toArray(),dynamicFeatures:this.dynamicFeatures})))}}const tr=new class{visitList(e,t){return new ft(e.map((e=>tr.visit(e,t)))).toOptionalList().mapOk((e=>e.filter((e=>null!==e))))}visit(e,t){switch(e.type){case"GlimmerComment":return dt(null);case"AppendContent":return this.AppendContent(e,t);case"HtmlText":return dt(this.TextNode(e));case"HtmlComment":return dt(this.HtmlComment(e));case"InvokeBlock":return this.InvokeBlock(e,t);case"InvokeComponent":return this.Component(e,t);case"SimpleElement":return this.SimpleElement(e,t)}}InvokeBlock(e,t){let r=Dt.translate(e,t);if(null!==r)return r;let n=yt.visit(e.callee,t),s=yt.Args(e.args,t);return ut.all(n,s).andThen((([r,n])=>this.NamedBlocks(e.blocks,t).mapOk((t=>new We({loc:e.loc,head:r,args:n,blocks:t})))))}NamedBlocks(e,t){return new ft(e.blocks.map((e=>this.NamedBlock(e,t)))).toArray().mapOk((t=>new Le({loc:e.loc,blocks:it(t)})))}NamedBlock(e,t){return t.visitBlock(e.block).mapOk((t=>new Ie({loc:e.loc,name:e.name,body:t.toArray(),scope:e.block.scope})))}SimpleElement(e,t){return new Zt(e,new er(e.tag,e,function({attrs:e,modifiers:t}){return t.length>0||!!e.filter((e=>"SplatAttr"===e.type))[0]}(e)),t).toStatement()}Component(e,t){return yt.visit(e.callee,t).andThen((r=>new Zt(e,new Qt(r,e),t).toStatement()))}AppendContent(e,t){let r=Mt.translate(e,t);return null!==r?r:yt.visit(e.value,t).mapOk((t=>e.trusting?new $e({loc:e.loc,html:t}):new Ge({loc:e.loc,text:t})))}TextNode(e){return new Ge({loc:e.loc,text:new A.LiteralExpression({loc:e.loc,value:e.chars})})}HtmlComment(e){return new Me({loc:e.loc,value:e.text})}};class rr{_currentScope;_cursorCount=0;constructor(e,t){this.isStrict=t,this._currentScope=e}generateUniqueCursor(){return`%cursor:${this._cursorCount++}%`}get scope(){return this._currentScope}visitBlock(e){let t=this._currentScope;this._currentScope=e.scope;try{return tr.visitList(e.body,this)}finally{this._currentScope=t}}}var nr=function(e){return e.Value="value",e.Component="component",e.Helper="helper",e.Modifier="modifier",e.ComponentOrHelper="component or helper",e}(nr||{});class sr{static validate(e){return new this(e).validate()}constructor(e){this.template=e}validate(){return this.Statements(this.template.body).mapOk((()=>this.template))}Statements(e){let t=dt(null);for(let r of e)t=t.andThen((()=>this.Statement(r)));return t}NamedBlocks({blocks:e}){let t=dt(null);for(let r of e.toArray())t=t.andThen((()=>this.NamedBlock(r)));return t}NamedBlock(e){return this.Statements(e.body)}Statement(e){switch(e.type){case"InElement":return this.InElement(e);case"Debugger":case"AppendComment":return dt(null);case"Yield":return this.Yield(e);case"AppendTrustedHTML":return this.AppendTrustedHTML(e);case"AppendTextNode":return this.AppendTextNode(e);case"Component":return this.Component(e);case"SimpleElement":return this.SimpleElement(e);case"InvokeBlock":return this.InvokeBlock(e);case"If":return this.If(e);case"Each":return this.Each(e);case"Let":return this.Let(e);case"WithDynamicVars":return this.WithDynamicVars(e);case"InvokeComponent":return this.InvokeComponent(e)}}Expressions(e){let t=dt(null);for(let r of e)t=t.andThen((()=>this.Expression(r)));return t}Expression(e,t=e,r){switch(e.type){case"Literal":case"Keyword":case"Missing":case"This":case"Arg":case"Local":case"HasBlock":case"HasBlockParams":case"GetDynamicVar":return dt(null);case"PathExpression":return this.Expression(e.head,t,r);case"Free":return this.errorFor(e.name,t,r);case"InterpolateExpression":return this.InterpolateExpression(e,t,r);case"CallExpression":return this.CallExpression(e,t,r??nr.Helper);case"Not":return this.Expression(e.value,t,r);case"IfInline":return this.IfInline(e);case"Curry":return this.Curry(e);case"Log":return this.Log(e)}}Args(e){return this.Positional(e.positional).andThen((()=>this.NamedArguments(e.named)))}Positional(e,t){let r=dt(null),n=e.list.toArray();return r=1===n.length?this.Expression(n[0],t):this.Expressions(n),r}NamedArguments({entries:e}){let t=dt(null);for(let r of e.toArray())t=t.andThen((()=>this.NamedArgument(r)));return t}NamedArgument(e){return"CallExpression"===e.value.type?this.Expression(e.value,e,nr.Helper):this.Expression(e.value,e)}ElementParameters({body:e}){let t=dt(null);for(let r of e.toArray())t=t.andThen((()=>this.ElementParameter(r)));return t}ElementParameter(e){switch(e.type){case"StaticAttr":case"SplatAttr":return dt(null);case"DynamicAttr":return this.DynamicAttr(e);case"Modifier":return this.Modifier(e)}}DynamicAttr(e){return"CallExpression"===e.value.type?this.Expression(e.value,e,nr.Helper):this.Expression(e.value,e)}Modifier(e){return this.Expression(e.callee,e,nr.Modifier).andThen((()=>this.Args(e.args)))}InElement(e){return this.Expression(e.destination).andThen((()=>this.Expression(e.insertBefore))).andThen((()=>this.NamedBlock(e.block)))}Yield(e){return this.Positional(e.positional,e)}AppendTrustedHTML(e){return this.Expression(e.html,e)}AppendTextNode(e){return"CallExpression"===e.text.type?this.Expression(e.text,e,nr.ComponentOrHelper):this.Expression(e.text,e)}Component(e){return this.Expression(e.tag,e,nr.Component).andThen((()=>this.ElementParameters(e.params))).andThen((()=>this.NamedArguments(e.args))).andThen((()=>this.NamedBlocks(e.blocks)))}SimpleElement(e){return this.ElementParameters(e.params).andThen((()=>this.Statements(e.body)))}InvokeBlock(e){return this.Expression(e.head,e.head,nr.Component).andThen((()=>this.Args(e.args))).andThen((()=>this.NamedBlocks(e.blocks)))}If(e){return this.Expression(e.condition,e).andThen((()=>this.NamedBlock(e.block))).andThen((()=>e.inverse?this.NamedBlock(e.inverse):dt(null)))}Each(e){return this.Expression(e.value,e).andThen((()=>e.key?this.Expression(e.key,e):dt(null))).andThen((()=>this.NamedBlock(e.block))).andThen((()=>e.inverse?this.NamedBlock(e.inverse):dt(null)))}Let(e){return this.Positional(e.positional).andThen((()=>this.NamedBlock(e.block)))}WithDynamicVars(e){return this.NamedArguments(e.named).andThen((()=>this.NamedBlock(e.block)))}InvokeComponent(e){return this.Expression(e.definition,e,nr.Component).andThen((()=>this.Args(e.args))).andThen((()=>e.blocks?this.NamedBlocks(e.blocks):dt(null)))}InterpolateExpression(e,t,r){let n=e.parts.toArray();return 1===n.length?this.Expression(n[0],t,r):this.Expressions(n)}CallExpression(e,t,r){return this.Expression(e.callee,t,r).andThen((()=>this.Args(e.args)))}IfInline(e){return this.Expression(e.condition).andThen((()=>this.Expression(e.truthy))).andThen((()=>e.falsy?this.Expression(e.falsy):dt(null)))}Curry(e){let t;return t=e.curriedType===S.Component?nr.Component:e.curriedType===S.Helper?nr.Helper:nr.Modifier,this.Expression(e.definition,e,t).andThen((()=>this.Args(e.args)))}Log(e){return this.Positional(e.positional,e)}errorFor(e,t,r=nr.Value){return ht(w(`Attempted to resolve a ${r} in a strict mode template, but that value was not in scope: ${e}`,C(t)))}}class ar{upvars;symbols;constructor([e,t,r,n]){this.upvars=n,this.symbols=t}format(e){let t=[];for(let r of e[0])t.push(this.formatOpcode(r));return t}formatOpcode(e){if(!Array.isArray(e))return e;switch(e[0]){case h.Append:return["append",this.formatOpcode(e[1])];case h.TrustingAppend:return["trusting-append",this.formatOpcode(e[1])];case h.Block:return["block",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case h.InElement:return["in-element",e[1],this.formatOpcode(e[2]),e[3]?this.formatOpcode(e[3]):void 0];case h.OpenElement:return["open-element",Wt(e[1])];case h.OpenElementWithSplat:return["open-element-with-splat",Wt(e[1])];case h.CloseElement:return["close-element"];case h.FlushElement:return["flush-element"];case h.StaticAttr:return["static-attr",Xt(e[1]),e[2],e[3]];case h.StaticComponentAttr:return["static-component-attr",Xt(e[1]),e[2],e[3]];case h.DynamicAttr:return["dynamic-attr",Xt(e[1]),this.formatOpcode(e[2]),e[3]];case h.ComponentAttr:return["component-attr",Xt(e[1]),this.formatOpcode(e[2]),e[3]];case h.AttrSplat:return["attr-splat"];case h.Yield:return["yield",e[1],this.formatParams(e[2])];case h.DynamicArg:return["dynamic-arg",e[1],this.formatOpcode(e[2])];case h.StaticArg:return["static-arg",e[1],this.formatOpcode(e[2])];case h.TrustingDynamicAttr:return["trusting-dynamic-attr",Xt(e[1]),this.formatOpcode(e[2]),e[3]];case h.TrustingComponentAttr:return["trusting-component-attr",Xt(e[1]),this.formatOpcode(e[2]),e[3]];case h.Debugger:return["debugger",e[1]];case h.Comment:return["comment",e[1]];case h.Modifier:return["modifier",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case h.Component:return["component",this.formatOpcode(e[1]),this.formatElementParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])];case h.HasBlock:return["has-block",this.formatOpcode(e[1])];case h.HasBlockParams:return["has-block-params",this.formatOpcode(e[1])];case h.Curry:return["curry",this.formatOpcode(e[1]),this.formatCurryType(e[2]),this.formatParams(e[3]),this.formatHash(e[4])];case h.Undefined:return["undefined"];case h.Call:return["call",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3])];case h.Concat:return["concat",this.formatParams(e[1])];case h.GetStrictKeyword:return["get-strict-free",this.upvars[e[1]]];case h.GetFreeAsComponentOrHelperHead:return["GetFreeAsComponentOrHelperHead",this.upvars[e[1]],e[2]];case h.GetFreeAsHelperHead:return["GetFreeAsHelperHead",this.upvars[e[1]],e[2]];case h.GetFreeAsComponentHead:return["GetFreeAsComponentHead",this.upvars[e[1]],e[2]];case h.GetFreeAsModifierHead:return["GetFreeAsModifierHead",this.upvars[e[1]],e[2]];case h.GetSymbol:return 0===e[1]?["get-symbol","this",e[2]]:["get-symbol",this.symbols[e[1]-1],e[2]];case h.GetLexicalSymbol:return["get-template-symbol",e[1],e[2]];case h.If:return["if",this.formatOpcode(e[1]),this.formatBlock(e[2]),e[3]?this.formatBlock(e[3]):null];case h.IfInline:return["if-inline"];case h.Not:return["not"];case h.Each:return["each",this.formatOpcode(e[1]),e[2]?this.formatOpcode(e[2]):null,this.formatBlock(e[3]),e[4]?this.formatBlock(e[4]):null];case h.Let:return["let",this.formatParams(e[1]),this.formatBlock(e[2])];case h.Log:return["log",this.formatParams(e[1])];case h.WithDynamicVars:return["-with-dynamic-vars",this.formatHash(e[1]),this.formatBlock(e[2])];case h.GetDynamicVar:return["-get-dynamic-vars",this.formatOpcode(e[1])];case h.InvokeComponent:return["component",this.formatOpcode(e[1]),this.formatParams(e[2]),this.formatHash(e[3]),this.formatBlocks(e[4])]}}formatCurryType(e){switch(e){case S.Component:return"component";case S.Helper:return"helper";case S.Modifier:return"modifier";default:throw c(e)}}formatElementParams(e){return null===e?null:e.map((e=>this.formatOpcode(e)))}formatParams(e){return null===e?null:e.map((e=>this.formatOpcode(e)))}formatHash(e){return null===e?null:e[0].reduce(((t,r,n)=>(t[r]=this.formatOpcode(e[1][n]),t)),t())}formatBlocks(e){return null===e?null:e[0].reduce(((t,r,n)=>(t[r]=this.formatBlock(e[1][n]),t)),t())}formatBlock(e){return{statements:e[0].map((e=>this.formatOpcode(e))),parameters:e[1]}}}const lr=new class{expr(e){switch(e.type){case"Missing":return;case"Literal":return this.Literal(e);case"Keyword":return this.Keyword(e);case"CallExpression":return this.CallExpression(e);case"PathExpression":return this.PathExpression(e);case"Arg":return[h.GetSymbol,e.symbol];case"Local":return this.Local(e);case"This":return[h.GetSymbol,0];case"Free":return[e.resolution.resolution(),e.symbol];case"HasBlock":return this.HasBlock(e);case"HasBlockParams":return this.HasBlockParams(e);case"Curry":return this.Curry(e);case"Not":return this.Not(e);case"IfInline":return this.IfInline(e);case"InterpolateExpression":return this.InterpolateExpression(e);case"GetDynamicVar":return this.GetDynamicVar(e);case"Log":return this.Log(e)}}Literal({value:e}){return void 0===e?[h.Undefined]:e}Missing(){}HasBlock({symbol:e}){return[h.HasBlock,[h.GetSymbol,e]]}HasBlockParams({symbol:e}){return[h.HasBlockParams,[h.GetSymbol,e]]}Curry({definition:e,curriedType:t,args:r}){return[h.Curry,lr.expr(e),t,lr.Positional(r.positional),lr.NamedArguments(r.named)]}Local({isTemplateLocal:e,symbol:t}){return[e?h.GetLexicalSymbol:h.GetSymbol,t]}Keyword({symbol:e}){return[h.GetStrictKeyword,e]}PathExpression({head:e,tail:t}){let r=lr.expr(e);return a(r[0]!==h.GetStrictKeyword,"[BUG] keyword in a PathExpression"),[...r,lr.Tail(t)]}InterpolateExpression({parts:e}){return[h.Concat,e.map((e=>lr.expr(e))).toArray()]}CallExpression({callee:e,args:t}){return[h.Call,lr.expr(e),...lr.Args(t)]}Tail({members:e}){return u(e,(e=>e.chars))}Args({positional:e,named:t}){return[this.Positional(e),this.NamedArguments(t)]}Positional({list:e}){return e.map((e=>lr.expr(e))).toPresentArray()}NamedArgument({key:e,value:t}){return[e.chars,lr.expr(t)]}NamedArguments({entries:e}){let t=e.toArray();if(n(t)){let e=[],r=[];for(let n of t){let[t,s]=lr.NamedArgument(n);e.push(t),r.push(s)}return m(e),m(r),[e,r]}return null}Not({value:e}){return[h.Not,lr.expr(e)]}IfInline({condition:e,truthy:t,falsy:r}){let n=[h.IfInline,lr.expr(e),lr.expr(t)];return r&&n.push(lr.expr(r)),n}GetDynamicVar({name:e}){return[h.GetDynamicVar,lr.expr(e)]}Log({positional:e}){return[h.Log,this.Positional(e)]}};class or{constructor(e){this.statements=e}toArray(){return this.statements}}const ir=new class{list(e){let t=[];for(let r of e){let e=ir.content(r);e&&e instanceof or?t.push(...e.toArray()):t.push(e)}return t}content(e){return this.visitContent(e)}visitContent(e){switch(e.type){case"Debugger":return[h.Debugger,e.scope.getDebugInfo()];case"AppendComment":return this.AppendComment(e);case"AppendTextNode":return this.AppendTextNode(e);case"AppendTrustedHTML":return this.AppendTrustedHTML(e);case"Yield":return this.Yield(e);case"Component":return this.Component(e);case"SimpleElement":return this.SimpleElement(e);case"InElement":return this.InElement(e);case"InvokeBlock":return this.InvokeBlock(e);case"If":return this.If(e);case"Each":return this.Each(e);case"Let":return this.Let(e);case"WithDynamicVars":return this.WithDynamicVars(e);case"InvokeComponent":return this.InvokeComponent(e);default:return c(e)}}Yield({to:e,positional:t}){return[h.Yield,e,lr.Positional(t)]}InElement({guid:e,insertBefore:t,destination:r,block:n}){let s=ir.NamedBlock(n)[1],a=lr.expr(r),l=lr.expr(t);return void 0===l?[h.InElement,s,e,a]:[h.InElement,s,e,a,l]}InvokeBlock({head:e,args:t,blocks:r}){return[h.Block,lr.expr(e),...lr.Args(t),ir.NamedBlocks(r)]}AppendTrustedHTML({html:e}){return[h.TrustingAppend,lr.expr(e)]}AppendTextNode({text:e}){return[h.Append,lr.expr(e)]}AppendComment({value:e}){return[h.Comment,e.chars]}SimpleElement({tag:e,params:t,body:r,dynamicFeatures:n}){let s=n?h.OpenElementWithSplat:h.OpenElement;return new or([[s,(a=e.chars,zt[a]??a)],...ir.ElementParameters(t).toArray(),[h.FlushElement],...ir.list(r),[h.CloseElement]]);var a}Component({tag:e,params:t,args:r,blocks:n}){let s=lr.expr(e),a=ir.ElementParameters(t),l=lr.NamedArguments(r),o=ir.NamedBlocks(n);return[h.Component,s,a.toPresentArray(),l,o]}ElementParameters({body:e}){return e.map((e=>ir.ElementParameter(e)))}ElementParameter(e){switch(e.type){case"SplatAttr":return[h.AttrSplat,e.symbol];case"DynamicAttr":return[(t=e.kind,t.component?t.trusting?h.TrustingComponentAttr:h.ComponentAttr:t.trusting?h.TrustingDynamicAttr:h.DynamicAttr),...ur(e)];case"StaticAttr":return[pr(e.kind),...cr(e)];case"Modifier":return[h.Modifier,lr.expr(e.callee),...lr.Args(e.args)]}var t}NamedBlocks({blocks:e}){let t=[],r=[];for(let n of e.toArray()){let[e,s]=ir.NamedBlock(n);t.push(e),r.push(s)}return t.length>0?[t,r]:null}NamedBlock({name:e,body:t,scope:r}){let n=e.chars;return"inverse"===n&&(n="else"),[n,[ir.list(t),r.slots]]}If({condition:e,block:t,inverse:r}){return[h.If,lr.expr(e),ir.NamedBlock(t)[1],r?ir.NamedBlock(r)[1]:null]}Each({value:e,key:t,block:r,inverse:n}){return[h.Each,lr.expr(e),t?lr.expr(t):null,ir.NamedBlock(r)[1],n?ir.NamedBlock(n)[1]:null]}Let({positional:e,block:t}){return[h.Let,lr.Positional(e),ir.NamedBlock(t)[1]]}WithDynamicVars({named:e,block:t}){return[h.WithDynamicVars,lr.NamedArguments(e),ir.NamedBlock(t)[1]]}InvokeComponent({definition:e,args:t,blocks:r}){return[h.InvokeComponent,lr.expr(e),lr.Positional(t.positional),lr.NamedArguments(t.named),r?ir.NamedBlocks(r):null]}};function cr({name:e,value:t,namespace:r}){let n=[Jt(e.chars),t.chars];return r&&n.push(r),n}function ur({name:e,value:t,namespace:r}){let n=[Jt(e.chars),lr.expr(t)];return r&&n.push(r),n}function pr(e){return e.component?h.StaticComponentAttr:h.StaticAttr}const mr=(()=>{const e="object"==typeof module&&"function"==typeof module.require?module.require:globalThis.require;if(e)try{const t=e("crypto"),r=e=>{const r=t.createHash("sha1");return r.update(e,"utf8"),r.digest("base64").substring(0,8)};return r("test"),r}catch{}return function(){return null}})(),dr={id:mr};function hr(e,t=dr){const r=new b.Source(e??"",t.meta?.moduleName),[n,s]=B(r,{lexicalScope:()=>!1,...t}),a=function(e,t,r){let n=new rr(t.table,r),s=tr.visitList(t.body,n).mapOk((e=>new xe({loc:t.loc,scope:t.table,body:e.toArray()})));return r&&(s=s.andThen((e=>sr.validate(e)))),s}(0,n,t.strictMode??!1).mapOk((e=>function(e){let t=ir.list(e.body),r=e.scope;return[t,r.symbols,r.hasEval,r.upvars]}(e)));if(a.isOk)return[a.value,s];throw a.reason}const fr="796d24e6-2450-4fb0-8cdf-b65638b5ef70";function kr(e,t=dr){const[r,n]=hr(e,t),s=t.meta?.moduleName,a=t.id||mr,l=JSON.stringify(r),o={id:a(JSON.stringify(t.meta)+l),block:l,moduleName:s??"(unknown template module)",scope:fr,isStrictMode:t.strictMode??!1};0===n.length&&delete o.scope;let i=JSON.stringify(o);if(n.length>0){const e=`()=>[${n.join(",")}]`;i=i.replace(`"${fr}"`,e)}return i}export{j as Builder,ie as NEWLINE,Z as ProgramSymbols,ar as WireFormatDebugger,se as buildStatement,re as buildStatements,le as c,mr as defaultId,kr as precompile,hr as precompileJSON,ae as s,oe as unicode};
//# sourceMappingURL=index.js.map
