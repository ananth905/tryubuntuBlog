import{setProp as t,getProp as e,toIterator as n,getPath as r}from"@glimmer/global-context";import{expect as i,isDict as u,EMPTY_ARRAY as s,isObject as l}from"@glimmer/util";import{CONSTANT_TAG as o,validateTag as a,track as c,valueForTag as p,consumeTag as f,INITIAL as h,createTag as m,dirtyTag as d}from"@glimmer/validator";const g=Symbol("REFERENCE"),v=1,k=2;class w{[g];tag=null;lastRevision=h;lastValue;children=null;compute=null;update=null;debugLabel;constructor(t){this[g]=t}}function M(t){const e=new w(k);return e.tag=o,e.lastValue=t,e}const y=M(void 0),b=M(null),_=M(!0),E=M(!1);function V(t,e){const n=new w(0);return n.lastValue=t,n.tag=o,n}function x(t,e){const n=new w(k);return n.lastValue=t,n.tag=o,n}function F(t,e=null,n="unknown"){const r=new w(v);return r.compute=t,r.update=e,r}function R(t){return C(t)?F((()=>N(t)),null,t.debugLabel):t}function L(t){return 3===t[g]}function A(t){const e=F((()=>N(t)),(e=>W(t,e)));return e.debugLabel=t.debugLabel,e[g]=3,e}function S(t){return t.tag===o}function C(t){return null!==t.update}function N(t){const e=t;let{tag:n}=e;if(n===o)return e.lastValue;const{lastRevision:r}=e;let i;if(null!==n&&a(n,r))i=e.lastValue;else{const{compute:t}=e,r=c((()=>{i=e.lastValue=t()}),!1);n=e.tag=r,e.lastRevision=p(r)}return f(n),i}function W(t,e){i(t.update,"called update on a non-updatable reference")(e)}function j(n,r){const i=n,s=i[g];let l,o=i.children;if(null===o)o=i.children=new Map;else if(l=o.get(r),void 0!==l)return l;if(s===k){const t=N(i);l=u(t)?x(t[r]):y}else l=F((()=>{const t=N(i);if(u(t))return e(t,r)}),(e=>{const n=N(i);if(u(n))return t(n,r,e)}));return o.set(r,l),l}function q(t,e){let n=t;for(const t of e)n=j(n,t);return n}let z;const B={},D=(t,e)=>e,G=(t,e)=>String(e),H=t=>null===t?B:t;class I{_weakMap;_primitiveMap;get weakMap(){return void 0===this._weakMap&&(this._weakMap=new WeakMap),this._weakMap}get primitiveMap(){return void 0===this._primitiveMap&&(this._primitiveMap=new Map),this._primitiveMap}set(t,e){l(t)?this.weakMap.set(t,e):this.primitiveMap.set(t,e)}get(t){return l(t)?this.weakMap.get(t):this.primitiveMap.get(t)}}const J=new I;function K(t){let e=new I;return(n,r)=>{let i=t(n,r),u=e.get(i)||0;return e.set(i,u+1),0===u?i:function(t,e){let n=J.get(t);void 0===n&&(n=[],J.set(t,n));let r=n[e];return void 0===r&&(r={value:t,count:e},n[e]=r),r}(i,u)}}function O(t,e){return F((()=>{let i=N(t),u=function(t){switch(t){case"@key":return K(D);case"@index":return K(G);case"@identity":return K(H);default:return e=t,K((t=>r(t,e)))}var e}(e);if(Array.isArray(i))return new T(i,u);let l=n(i);return null===l?new T(s,(()=>null)):new Q(l,u)}))}function P(t){let e=t,n=m();return F((()=>(f(n),e)),(t=>{e!==t&&(e=t,d(n))}))}class Q{constructor(t,e){this.inner=t,this.keyFor=e}isEmpty(){return this.inner.isEmpty()}next(){let t=this.inner.next();return null!==t&&(t.key=this.keyFor(t.value,t.memo)),t}}class T{current;pos=0;constructor(t,e){this.iterator=t,this.keyFor=e,0===t.length?this.current={kind:"empty"}:this.current={kind:"first",value:t[this.pos]}}isEmpty(){return"empty"===this.current.kind}next(){let t,e=this.current;if("first"===e.kind)this.current={kind:"progress"},t=e.value;else{if(this.pos>=this.iterator.length-1)return null;t=this.iterator[++this.pos]}let{keyFor:n}=this;return{key:n(t,this.pos),value:t,memo:this.pos}}}export{E as FALSE_REFERENCE,b as NULL_REFERENCE,g as REFERENCE,_ as TRUE_REFERENCE,y as UNDEFINED_REFERENCE,j as childRefFor,q as childRefFromParts,F as createComputeRef,V as createConstRef,z as createDebugAliasRef,A as createInvokableRef,P as createIteratorItemRef,O as createIteratorRef,M as createPrimitiveRef,R as createReadOnlyRef,x as createUnboundRef,S as isConstRef,L as isInvokableRef,C as isUpdatableRef,W as updateRef,N as valueForRef};
//# sourceMappingURL=index.js.map
