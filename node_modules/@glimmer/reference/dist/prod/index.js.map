{"version":3,"file":"index.js","sources":["../../lib/reference.ts","../../lib/iterable.ts"],"sourcesContent":["import type {\n  ComputeReference,\n  ConstantReference,\n  InvokableReference,\n  Nullable,\n  Reference,\n  ReferenceSymbol,\n  ReferenceType,\n  UnboundReference,\n} from '@glimmer/interfaces';\nimport type { Revision, Tag } from '@glimmer/validator';\nimport { getProp, setProp } from '@glimmer/global-context';\nimport { expect, isDict } from '@glimmer/util';\nimport {\n  CONSTANT_TAG,\n  consumeTag,\n  INITIAL,\n  track,\n  validateTag,\n  valueForTag,\n} from '@glimmer/validator';\n\nexport const REFERENCE: ReferenceSymbol = Symbol('REFERENCE') as ReferenceSymbol;\n\nconst CONSTANT: ConstantReference = 0;\nconst COMPUTE: ComputeReference = 1;\nconst UNBOUND: UnboundReference = 2;\nconst INVOKABLE: InvokableReference = 3;\n\nexport type { Reference as default };\nexport type { Reference };\n\n//////////\n\nexport interface ReferenceEnvironment {\n  getProp(obj: unknown, path: string): unknown;\n  setProp(obj: unknown, path: string, value: unknown): unknown;\n}\n\nclass ReferenceImpl<T = unknown> implements Reference<T> {\n  [REFERENCE]: ReferenceType;\n  public tag: Nullable<Tag> = null;\n  public lastRevision: Revision = INITIAL;\n  public lastValue?: T;\n\n  public children: Nullable<Map<string | Reference, Reference>> = null;\n\n  public compute: Nullable<() => T> = null;\n  public update: Nullable<(val: T) => void> = null;\n\n  public debugLabel?: string;\n\n  constructor(type: ReferenceType) {\n    this[REFERENCE] = type;\n  }\n}\n\nexport function createPrimitiveRef<T extends string | symbol | number | boolean | null | undefined>(\n  value: T\n): Reference<T> {\n  const ref = new ReferenceImpl<T>(UNBOUND);\n\n  ref.tag = CONSTANT_TAG;\n  ref.lastValue = value;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = String(value);\n  }\n\n  return ref;\n}\n\nexport const UNDEFINED_REFERENCE = createPrimitiveRef(undefined);\nexport const NULL_REFERENCE = createPrimitiveRef(null);\nexport const TRUE_REFERENCE = createPrimitiveRef(true as const);\nexport const FALSE_REFERENCE = createPrimitiveRef(false as const);\n\nexport function createConstRef<T>(value: T, debugLabel: false | string): Reference<T> {\n  const ref = new ReferenceImpl<T>(CONSTANT);\n\n  ref.lastValue = value;\n  ref.tag = CONSTANT_TAG;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = debugLabel as string;\n  }\n\n  return ref;\n}\n\nexport function createUnboundRef<T>(value: T, debugLabel: false | string): Reference<T> {\n  const ref = new ReferenceImpl<T>(UNBOUND);\n\n  ref.lastValue = value;\n  ref.tag = CONSTANT_TAG;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = debugLabel as string;\n  }\n\n  return ref;\n}\n\nexport function createComputeRef<T = unknown>(\n  compute: () => T,\n  update: Nullable<(value: T) => void> = null,\n  debugLabel: false | string = 'unknown'\n): Reference<T> {\n  const ref = new ReferenceImpl<T>(COMPUTE);\n\n  ref.compute = compute;\n  ref.update = update;\n\n  if (import.meta.env.DEV) {\n    ref.debugLabel = `(result of a \\`${debugLabel}\\` helper)`;\n  }\n\n  return ref;\n}\n\nexport function createReadOnlyRef(ref: Reference): Reference {\n  if (!isUpdatableRef(ref)) return ref;\n\n  return createComputeRef(() => valueForRef(ref), null, ref.debugLabel);\n}\n\nexport function isInvokableRef(ref: Reference) {\n  return ref[REFERENCE] === INVOKABLE;\n}\n\nexport function createInvokableRef(inner: Reference): Reference {\n  const ref = createComputeRef(\n    () => valueForRef(inner),\n    (value) => updateRef(inner, value)\n  );\n  ref.debugLabel = inner.debugLabel;\n  ref[REFERENCE] = INVOKABLE;\n\n  return ref;\n}\n\nexport function isConstRef(_ref: Reference) {\n  const ref = _ref as ReferenceImpl;\n\n  return ref.tag === CONSTANT_TAG;\n}\n\nexport function isUpdatableRef(_ref: Reference) {\n  const ref = _ref as ReferenceImpl;\n\n  return ref.update !== null;\n}\n\nexport function valueForRef<T>(_ref: Reference<T>): T {\n  const ref = _ref as ReferenceImpl<T>;\n\n  let { tag } = ref;\n\n  if (tag === CONSTANT_TAG) {\n    return ref.lastValue as T;\n  }\n\n  const { lastRevision } = ref;\n  let lastValue;\n\n  if (tag === null || !validateTag(tag, lastRevision)) {\n    const { compute } = ref;\n\n    const newTag = track(\n      () => {\n        lastValue = ref.lastValue = compute!();\n      },\n      import.meta.env.DEV && ref.debugLabel\n    );\n\n    tag = ref.tag = newTag;\n\n    ref.lastRevision = valueForTag(newTag);\n  } else {\n    lastValue = ref.lastValue;\n  }\n\n  consumeTag(tag);\n\n  return lastValue as T;\n}\n\nexport function updateRef(_ref: Reference, value: unknown) {\n  const ref = _ref as ReferenceImpl;\n\n  const update = expect(ref.update, 'called update on a non-updatable reference');\n\n  update(value);\n}\n\nexport function childRefFor(_parentRef: Reference, path: string): Reference {\n  const parentRef = _parentRef as ReferenceImpl;\n\n  const type = parentRef[REFERENCE];\n\n  let children = parentRef.children;\n  let child: Reference;\n\n  if (children === null) {\n    children = parentRef.children = new Map();\n  } else {\n    child = children.get(path)!;\n\n    if (child !== undefined) {\n      return child;\n    }\n  }\n\n  if (type === UNBOUND) {\n    const parent = valueForRef(parentRef);\n\n    if (isDict(parent)) {\n      child = createUnboundRef(\n        (parent as Record<string, unknown>)[path],\n        import.meta.env.DEV && `${parentRef.debugLabel}.${path}`\n      );\n    } else {\n      child = UNDEFINED_REFERENCE;\n    }\n  } else {\n    child = createComputeRef(\n      () => {\n        const parent = valueForRef(parentRef);\n\n        if (isDict(parent)) {\n          return getProp(parent, path);\n        }\n      },\n      (val) => {\n        const parent = valueForRef(parentRef);\n\n        if (isDict(parent)) {\n          return setProp(parent, path, val);\n        }\n      }\n    );\n\n    if (import.meta.env.DEV) {\n      child.debugLabel = `${parentRef.debugLabel}.${path}`;\n    }\n  }\n\n  children.set(path, child);\n\n  return child;\n}\n\nexport function childRefFromParts(root: Reference, parts: string[]): Reference {\n  let reference = root;\n\n  for (const part of parts) {\n    reference = childRefFor(reference, part);\n  }\n\n  return reference;\n}\n\nexport let createDebugAliasRef: undefined | ((debugLabel: string, inner: Reference) => Reference);\n\nif (import.meta.env.DEV) {\n  createDebugAliasRef = (debugLabel: string, inner: Reference) => {\n    const update = isUpdatableRef(inner) ? (value: unknown) => updateRef(inner, value) : null;\n    const ref = createComputeRef(() => valueForRef(inner), update);\n\n    ref[REFERENCE] = inner[REFERENCE];\n\n    ref.debugLabel = debugLabel;\n\n    return ref;\n  };\n}\n","import type { Dict, Nullable } from '@glimmer/interfaces';\nimport { getPath, toIterator } from '@glimmer/global-context';\nimport { EMPTY_ARRAY, isObject } from '@glimmer/util';\nimport { consumeTag, createTag, dirtyTag } from '@glimmer/validator';\n\nimport type { Reference, ReferenceEnvironment } from './reference';\n\nimport { createComputeRef, valueForRef } from './reference';\n\nexport interface IterationItem<T, U> {\n  key: unknown;\n  value: T;\n  memo: U;\n}\n\nexport interface AbstractIterator<T, U, V extends IterationItem<T, U>> {\n  isEmpty(): boolean;\n  next(): Nullable<V>;\n}\n\nexport type OpaqueIterationItem = IterationItem<unknown, unknown>;\nexport type OpaqueIterator = AbstractIterator<unknown, unknown, OpaqueIterationItem>;\n\nexport interface IteratorDelegate {\n  isEmpty(): boolean;\n  next(): { value: unknown; memo: unknown } | null;\n}\n\nexport interface IteratorReferenceEnvironment extends ReferenceEnvironment {\n  getPath(obj: unknown, path: string): unknown;\n  toIterator(obj: unknown): Nullable<IteratorDelegate>;\n}\n\ntype KeyFor = (item: unknown, index: unknown) => unknown;\n\nconst NULL_IDENTITY = {};\n\nconst KEY: KeyFor = (_, index) => index;\nconst INDEX: KeyFor = (_, index) => String(index);\nconst IDENTITY: KeyFor = (item) => {\n  if (item === null) {\n    // Returning null as an identity will cause failures since the iterator\n    // can't tell that it's actually supposed to be null\n    return NULL_IDENTITY;\n  }\n\n  return item;\n};\n\nfunction keyForPath(path: string): KeyFor {\n  if (import.meta.env.DEV && path[0] === '@') {\n    throw new Error(`invalid keypath: '${path}', valid keys: @index, @identity, or a path`);\n  }\n  return uniqueKeyFor((item) => getPath(item as object, path));\n}\n\nfunction makeKeyFor(key: string) {\n  switch (key) {\n    case '@key':\n      return uniqueKeyFor(KEY);\n    case '@index':\n      return uniqueKeyFor(INDEX);\n    case '@identity':\n      return uniqueKeyFor(IDENTITY);\n    default:\n      return keyForPath(key);\n  }\n}\n\nclass WeakMapWithPrimitives<T> {\n  private _weakMap?: WeakMap<object, T>;\n  private _primitiveMap?: Map<unknown, T>;\n\n  private get weakMap() {\n    if (this._weakMap === undefined) {\n      this._weakMap = new WeakMap();\n    }\n\n    return this._weakMap;\n  }\n\n  private get primitiveMap() {\n    if (this._primitiveMap === undefined) {\n      this._primitiveMap = new Map();\n    }\n\n    return this._primitiveMap;\n  }\n\n  set(key: unknown, value: T) {\n    if (isObject(key)) {\n      this.weakMap.set(key, value);\n    } else {\n      this.primitiveMap.set(key, value);\n    }\n  }\n\n  get(key: unknown): T | undefined {\n    if (isObject(key)) {\n      return this.weakMap.get(key);\n    } else {\n      return this.primitiveMap.get(key);\n    }\n  }\n}\n\nconst IDENTITIES = new WeakMapWithPrimitives<object[]>();\n\nfunction identityForNthOccurence(value: any, count: number) {\n  let identities = IDENTITIES.get(value);\n\n  if (identities === undefined) {\n    identities = [];\n    IDENTITIES.set(value, identities);\n  }\n\n  let identity = identities[count];\n\n  if (identity === undefined) {\n    identity = { value, count };\n    identities[count] = identity;\n  }\n\n  return identity;\n}\n\n/**\n * When iterating over a list, it's possible that an item with the same unique\n * key could be encountered twice:\n *\n * ```js\n * let arr = ['same', 'different', 'same', 'same'];\n * ```\n *\n * In general, we want to treat these items as _unique within the list_. To do\n * this, we track the occurences of every item as we iterate the list, and when\n * an item occurs more than once, we generate a new unique key just for that\n * item, and that occurence within the list. The next time we iterate the list,\n * and encounter an item for the nth time, we can get the _same_ key, and let\n * Glimmer know that it should reuse the DOM for the previous nth occurence.\n */\nfunction uniqueKeyFor(keyFor: KeyFor) {\n  let seen = new WeakMapWithPrimitives<number>();\n\n  return (value: unknown, memo: unknown) => {\n    let key = keyFor(value, memo);\n    let count = seen.get(key) || 0;\n\n    seen.set(key, count + 1);\n\n    if (count === 0) {\n      return key;\n    }\n\n    return identityForNthOccurence(key, count);\n  };\n}\n\nexport function createIteratorRef(listRef: Reference, key: string) {\n  return createComputeRef(() => {\n    let iterable = valueForRef(listRef) as { [Symbol.iterator]: any } | null | false;\n\n    let keyFor = makeKeyFor(key);\n\n    if (Array.isArray(iterable)) {\n      return new ArrayIterator(iterable, keyFor);\n    }\n\n    let maybeIterator = toIterator(iterable);\n\n    if (maybeIterator === null) {\n      return new ArrayIterator(EMPTY_ARRAY, () => null);\n    }\n\n    return new IteratorWrapper(maybeIterator, keyFor);\n  });\n}\n\nexport function createIteratorItemRef(_value: unknown) {\n  let value = _value;\n  let tag = createTag();\n\n  return createComputeRef(\n    () => {\n      consumeTag(tag);\n      return value;\n    },\n    (newValue) => {\n      if (value !== newValue) {\n        value = newValue;\n        dirtyTag(tag);\n      }\n    }\n  );\n}\n\nclass IteratorWrapper implements OpaqueIterator {\n  constructor(\n    private inner: IteratorDelegate,\n    private keyFor: KeyFor\n  ) {}\n\n  isEmpty() {\n    return this.inner.isEmpty();\n  }\n\n  next() {\n    let nextValue = this.inner.next() as OpaqueIterationItem;\n\n    if (nextValue !== null) {\n      nextValue.key = this.keyFor(nextValue.value, nextValue.memo);\n    }\n\n    return nextValue;\n  }\n}\n\nclass ArrayIterator implements OpaqueIterator {\n  private current: { kind: 'empty' } | { kind: 'first'; value: unknown } | { kind: 'progress' };\n  private pos = 0;\n\n  constructor(\n    private iterator: unknown[] | readonly unknown[],\n    private keyFor: KeyFor\n  ) {\n    if (iterator.length === 0) {\n      this.current = { kind: 'empty' };\n    } else {\n      this.current = { kind: 'first', value: iterator[this.pos] };\n    }\n  }\n\n  isEmpty(): boolean {\n    return this.current.kind === 'empty';\n  }\n\n  next(): Nullable<IterationItem<unknown, number>> {\n    let value: unknown;\n\n    let current = this.current;\n    if (current.kind === 'first') {\n      this.current = { kind: 'progress' };\n      value = current.value;\n    } else if (this.pos >= this.iterator.length - 1) {\n      return null;\n    } else {\n      value = this.iterator[++this.pos];\n    }\n\n    let { keyFor } = this;\n\n    let key = keyFor(value as Dict, this.pos);\n    let memo = this.pos;\n\n    return { key, value, memo };\n  }\n}\n"],"names":["REFERENCE","Symbol","COMPUTE","UNBOUND","ReferenceImpl","tag","lastRevision","INITIAL","lastValue","children","compute","update","debugLabel","constructor","type","this","createPrimitiveRef","value","ref","CONSTANT_TAG","UNDEFINED_REFERENCE","undefined","NULL_REFERENCE","TRUE_REFERENCE","FALSE_REFERENCE","createConstRef","createUnboundRef","createComputeRef","createReadOnlyRef","isUpdatableRef","valueForRef","isInvokableRef","createInvokableRef","inner","updateRef","isConstRef","_ref","validateTag","newTag","track","valueForTag","consumeTag","expect","childRefFor","_parentRef","path","parentRef","child","Map","get","parent","isDict","getProp","val","setProp","set","childRefFromParts","root","parts","reference","part","createDebugAliasRef","NULL_IDENTITY","KEY","_","index","INDEX","String","IDENTITY","item","WeakMapWithPrimitives","_weakMap","_primitiveMap","weakMap","WeakMap","primitiveMap","key","isObject","IDENTITIES","uniqueKeyFor","keyFor","seen","memo","count","identities","identity","identityForNthOccurence","createIteratorRef","listRef","iterable","getPath","makeKeyFor","Array","isArray","ArrayIterator","maybeIterator","toIterator","EMPTY_ARRAY","IteratorWrapper","createIteratorItemRef","_value","createTag","newValue","dirtyTag","isEmpty","next","nextValue","current","pos","iterator","length","kind"],"mappings":"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"}