{"version":3,"file":"index.js","sources":["../../lib/debug.ts","../../lib/validators.ts","../../lib/meta.ts","../../lib/tracking.ts","../../lib/utils.ts","../../lib/tracked-data.ts","../../index.ts"],"sourcesContent":["import type { Tag } from '@glimmer/interfaces';\nimport { assert } from '@glimmer/global-context';\nimport { asPresentArray, getLast } from '@glimmer/util';\n\ninterface DebugTransaction {\n  beginTrackingTransaction?:\n    | undefined\n    | ((debuggingContext?: string | false, deprecate?: boolean) => void);\n  endTrackingTransaction?: undefined | (() => void);\n  runInTrackingTransaction?: undefined | (<T>(fn: () => T, debuggingContext?: string | false) => T);\n\n  resetTrackingTransaction?: undefined | (() => string);\n  setTrackingTransactionEnv?:\n    | undefined\n    | ((env: { debugMessage?(obj?: unknown, keyName?: string): string }) => void);\n  assertTagNotConsumed?:\n    | undefined\n    | (<T>(tag: Tag, obj?: T, keyName?: keyof T | string | symbol) => void);\n\n  markTagAsConsumed?: undefined | ((_tag: Tag) => void);\n\n  logTrackingStack?: undefined | ((transaction?: Transaction) => string);\n}\n\nexport const debug: DebugTransaction = {};\n\ninterface Transaction {\n  parent: Transaction | null;\n  debugLabel?: string | undefined;\n}\n\nif (import.meta.env.DEV) {\n  let CONSUMED_TAGS: WeakMap<Tag, Transaction> | null = null;\n\n  const TRANSACTION_STACK: Transaction[] = [];\n\n  /////////\n\n  const TRANSACTION_ENV = {\n    debugMessage(obj?: unknown, keyName?: string) {\n      let objName;\n\n      if (typeof obj === 'function') {\n        objName = obj.name;\n      } else if (typeof obj === 'object' && obj !== null) {\n        let className = (obj.constructor && obj.constructor.name) || '(unknown class)';\n\n        objName = `(an instance of ${className})`;\n      } else if (obj === undefined) {\n        objName = '(an unknown tag)';\n      } else {\n        objName = String(obj);\n      }\n\n      let dirtyString = keyName ? `\\`${keyName}\\` on \\`${objName}\\`` : `\\`${objName}\\``;\n\n      return `You attempted to update ${dirtyString}, but it had already been used previously in the same computation.  Attempting to update a value after using it in a computation can cause logical errors, infinite revalidation bugs, and performance issues, and is not supported.`;\n    },\n  };\n\n  debug.setTrackingTransactionEnv = (env) => Object.assign(TRANSACTION_ENV, env);\n\n  debug.beginTrackingTransaction = (_debugLabel?: string | false) => {\n    CONSUMED_TAGS = CONSUMED_TAGS || new WeakMap();\n\n    let debugLabel = _debugLabel || undefined;\n\n    let parent = TRANSACTION_STACK[TRANSACTION_STACK.length - 1] ?? null;\n\n    TRANSACTION_STACK.push({\n      parent,\n      debugLabel,\n    });\n  };\n\n  debug.endTrackingTransaction = () => {\n    if (TRANSACTION_STACK.length === 0) {\n      throw new Error('attempted to close a tracking transaction, but one was not open');\n    }\n\n    TRANSACTION_STACK.pop();\n\n    if (TRANSACTION_STACK.length === 0) {\n      CONSUMED_TAGS = null;\n    }\n  };\n\n  debug.resetTrackingTransaction = () => {\n    let stack = '';\n\n    if (TRANSACTION_STACK.length > 0) {\n      stack = debug.logTrackingStack!(TRANSACTION_STACK[TRANSACTION_STACK.length - 1]);\n    }\n\n    TRANSACTION_STACK.splice(0, TRANSACTION_STACK.length);\n    CONSUMED_TAGS = null;\n\n    return stack;\n  };\n\n  /**\n   * Creates a global autotracking transaction. This will prevent any backflow\n   * in any `track` calls within the transaction, even if they are not\n   * externally consumed.\n   *\n   * `runInAutotrackingTransaction` can be called within itself, and it will add\n   * onto the existing transaction if one exists.\n   *\n   * TODO: Only throw an error if the `track` is consumed.\n   */\n  debug.runInTrackingTransaction = <T>(fn: () => T, debugLabel?: string | false) => {\n    debug.beginTrackingTransaction!(debugLabel);\n    let didError = true;\n\n    try {\n      let value = fn();\n      didError = false;\n      return value;\n    } finally {\n      if (didError !== true) {\n        debug.endTrackingTransaction!();\n      }\n\n      // if (id !== TRANSACTION_STACK.length) {\n      //   throw new Error(\n      //     `attempted to close a tracking transaction (${id}), but it was not the last transaction (${TRANSACTION_STACK.length})`\n      //   );\n      // }\n    }\n  };\n\n  let nthIndex = (str: string, pattern: string, n: number, startingPos = -1) => {\n    let i = startingPos;\n\n    while (n-- > 0 && i++ < str.length) {\n      i = str.indexOf(pattern, i);\n      if (i < 0) break;\n    }\n\n    return i;\n  };\n\n  let makeTrackingErrorMessage = <T>(\n    transaction: Transaction,\n    obj?: T,\n    keyName?: keyof T | string | symbol\n  ) => {\n    let message = [TRANSACTION_ENV.debugMessage(obj, keyName && String(keyName))];\n\n    message.push(`\\`${String(keyName)}\\` was first used:`);\n\n    message.push(debug.logTrackingStack!(transaction));\n\n    message.push(`Stack trace for the update:`);\n\n    return message.join('\\n\\n');\n  };\n\n  debug.logTrackingStack = (transaction?: Transaction) => {\n    let trackingStack = [];\n    let current: Transaction | null | undefined =\n      transaction || TRANSACTION_STACK[TRANSACTION_STACK.length - 1];\n\n    if (current === undefined) return '';\n\n    while (current) {\n      if (current.debugLabel) {\n        trackingStack.unshift(current.debugLabel);\n      }\n\n      current = current.parent;\n    }\n\n    return trackingStack.map((label, index) => ' '.repeat(2 * index) + label).join('\\n');\n  };\n\n  debug.markTagAsConsumed = (_tag: Tag) => {\n    if (!CONSUMED_TAGS || CONSUMED_TAGS.has(_tag)) return;\n\n    CONSUMED_TAGS.set(_tag, getLast(asPresentArray(TRANSACTION_STACK)));\n\n    // We need to mark the tag and all of its subtags as consumed, so we need to\n    // cast it and access its internals. In the future this shouldn't be necessary,\n    // this is only for computed properties.\n    let subtag = (_tag as unknown as { subtag: Tag | Tag[] | null }).subtag;\n\n    if (!subtag || !debug.markTagAsConsumed) return;\n\n    if (Array.isArray(subtag)) {\n      subtag.forEach(debug.markTagAsConsumed);\n    } else {\n      debug.markTagAsConsumed(subtag);\n    }\n  };\n\n  debug.assertTagNotConsumed = <T>(tag: Tag, obj?: T, keyName?: keyof T | string | symbol) => {\n    if (CONSUMED_TAGS === null) return;\n\n    let transaction = CONSUMED_TAGS.get(tag);\n\n    if (!transaction) return;\n\n    // This hack makes the assertion message nicer, we can cut off the first\n    // few lines of the stack trace and let users know where the actual error\n    // occurred.\n    try {\n      assert(false, makeTrackingErrorMessage(transaction, obj, keyName));\n    } catch (e) {\n      if (hasStack(e)) {\n        let updateStackBegin = e.stack.indexOf('Stack trace for the update:');\n\n        if (updateStackBegin !== -1) {\n          let start = nthIndex(e.stack, '\\n', 1, updateStackBegin);\n          let end = nthIndex(e.stack, '\\n', 4, updateStackBegin);\n          e.stack = e.stack.substr(0, start) + e.stack.substr(end);\n        }\n      }\n\n      throw e;\n    }\n  };\n}\n\nfunction hasStack(error: unknown): error is { stack: string } {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'stack' in error &&\n    typeof error.stack === 'string'\n  );\n}\n","import type {\n  COMBINATOR_TAG_ID as ICOMBINATOR_TAG_ID,\n  CONSTANT_TAG_ID as ICONSTANT_TAG_ID,\n  ConstantTag,\n  CURRENT_TAG_ID as ICURRENT_TAG_ID,\n  DIRTYABLE_TAG_ID as IDIRTYABLE_TAG_ID,\n  DirtyableTag,\n  MonomorphicTagId,\n  Tag,\n  TagComputeSymbol,\n  TagTypeSymbol,\n  UPDATABLE_TAG_ID as IUPDATABLE_TAG_ID,\n  UpdatableTag,\n  VOLATILE_TAG_ID as IVOLATILE_TAG_ID,\n} from '@glimmer/interfaces';\nimport { scheduleRevalidate } from '@glimmer/global-context';\n\nimport { debug } from './debug';\nimport { unwrap } from './utils';\n\n//////////\n\nexport type Revision = number;\n\nexport const CONSTANT: Revision = 0;\nexport const INITIAL: Revision = 1;\nexport const VOLATILE: Revision = NaN;\n\nexport let $REVISION = INITIAL;\n\nexport function bump(): void {\n  $REVISION++;\n}\n\n//////////\n\nconst DIRYTABLE_TAG_ID: IDIRTYABLE_TAG_ID = 0;\nconst UPDATABLE_TAG_ID: IUPDATABLE_TAG_ID = 1;\nconst COMBINATOR_TAG_ID: ICOMBINATOR_TAG_ID = 2;\nconst CONSTANT_TAG_ID: ICONSTANT_TAG_ID = 3;\n\n//////////\n\nexport const COMPUTE: TagComputeSymbol = Symbol('TAG_COMPUTE') as TagComputeSymbol;\n\n//////////\n\n/**\n * `value` receives a tag and returns an opaque Revision based on that tag. This\n * snapshot can then later be passed to `validate` with the same tag to\n * determine if the tag has changed at all since the time that `value` was\n * called.\n *\n * @param tag\n */\nexport function valueForTag(tag: Tag): Revision {\n  return tag[COMPUTE]();\n}\n\n/**\n * `validate` receives a tag and a snapshot from a previous call to `value` with\n * the same tag, and determines if the tag is still valid compared to the\n * snapshot. If the tag's state has changed at all since then, `validate` will\n * return false, otherwise it will return true. This is used to determine if a\n * calculation related to the tags should be rerun.\n *\n * @param tag\n * @param snapshot\n */\nexport function validateTag(tag: Tag, snapshot: Revision): boolean {\n  return snapshot >= tag[COMPUTE]();\n}\n\n//////////\n\nconst TYPE: TagTypeSymbol = Symbol('TAG_TYPE') as TagTypeSymbol;\n\n// this is basically a const\nexport let ALLOW_CYCLES: WeakMap<Tag, boolean> | undefined;\n\nif (import.meta.env.DEV) {\n  ALLOW_CYCLES = new WeakMap();\n}\n\nfunction allowsCycles(tag: Tag): boolean {\n  if (ALLOW_CYCLES === undefined) {\n    return true;\n  } else {\n    return ALLOW_CYCLES.has(tag);\n  }\n}\n\nclass MonomorphicTagImpl<T extends MonomorphicTagId = MonomorphicTagId> {\n  static combine(this: void, tags: Tag[]): Tag {\n    switch (tags.length) {\n      case 0:\n        return CONSTANT_TAG;\n      case 1:\n        return tags[0] as Tag;\n      default: {\n        let tag: MonomorphicTagImpl = new MonomorphicTagImpl(COMBINATOR_TAG_ID);\n        tag.subtag = tags;\n        return tag;\n      }\n    }\n  }\n\n  private revision = INITIAL;\n  private lastChecked = INITIAL;\n  private lastValue = INITIAL;\n\n  private isUpdating = false;\n  public subtag: Tag | Tag[] | null = null;\n  private subtagBufferCache: Revision | null = null;\n\n  [TYPE]: T;\n\n  constructor(type: T) {\n    this[TYPE] = type;\n  }\n\n  [COMPUTE](): Revision {\n    let { lastChecked } = this;\n\n    if (this.isUpdating === true) {\n      if (import.meta.env.DEV && !allowsCycles(this)) {\n        throw new Error('Cycles in tags are not allowed');\n      }\n\n      this.lastChecked = ++$REVISION;\n    } else if (lastChecked !== $REVISION) {\n      this.isUpdating = true;\n      this.lastChecked = $REVISION;\n\n      try {\n        let { subtag, revision } = this;\n\n        if (subtag !== null) {\n          if (Array.isArray(subtag)) {\n            for (const tag of subtag) {\n              let value = tag[COMPUTE]();\n              revision = Math.max(value, revision);\n            }\n          } else {\n            let subtagValue = subtag[COMPUTE]();\n\n            if (subtagValue === this.subtagBufferCache) {\n              revision = Math.max(revision, this.lastValue);\n            } else {\n              // Clear the temporary buffer cache\n              this.subtagBufferCache = null;\n              revision = Math.max(revision, subtagValue);\n            }\n          }\n        }\n\n        this.lastValue = revision;\n      } finally {\n        this.isUpdating = false;\n      }\n    }\n\n    return this.lastValue;\n  }\n\n  static updateTag(this: void, _tag: UpdatableTag, _subtag: Tag) {\n    if (import.meta.env.DEV && _tag[TYPE] !== UPDATABLE_TAG_ID) {\n      throw new Error('Attempted to update a tag that was not updatable');\n    }\n\n    // TODO: TS 3.7 should allow us to do this via assertion\n    let tag = _tag as MonomorphicTagImpl;\n    let subtag = _subtag as MonomorphicTagImpl;\n\n    if (subtag === CONSTANT_TAG) {\n      tag.subtag = null;\n    } else {\n      // There are two different possibilities when updating a subtag:\n      //\n      // 1. subtag[COMPUTE]() <= tag[COMPUTE]();\n      // 2. subtag[COMPUTE]() > tag[COMPUTE]();\n      //\n      // The first possibility is completely fine within our caching model, but\n      // the second possibility presents a problem. If the parent tag has\n      // already been read, then it's value is cached and will not update to\n      // reflect the subtag's greater value. Next time the cache is busted, the\n      // subtag's value _will_ be read, and it's value will be _greater_ than\n      // the saved snapshot of the parent, causing the resulting calculation to\n      // be rerun erroneously.\n      //\n      // In order to prevent this, when we first update to a new subtag we store\n      // its computed value, and then check against that computed value on\n      // subsequent updates. If its value hasn't changed, then we return the\n      // parent's previous value. Once the subtag changes for the first time,\n      // we clear the cache and everything is finally in sync with the parent.\n      tag.subtagBufferCache = subtag[COMPUTE]();\n      tag.subtag = subtag;\n    }\n  }\n\n  static dirtyTag(\n    this: void,\n    tag: DirtyableTag | UpdatableTag,\n    disableConsumptionAssertion?: boolean\n  ) {\n    if (\n      import.meta.env.DEV &&\n      !(tag[TYPE] === UPDATABLE_TAG_ID || tag[TYPE] === DIRYTABLE_TAG_ID)\n    ) {\n      throw new Error('Attempted to dirty a tag that was not dirtyable');\n    }\n\n    if (import.meta.env.DEV && disableConsumptionAssertion !== true) {\n      // Usually by this point, we've already asserted with better error information,\n      // but this is our last line of defense.\n      unwrap(debug.assertTagNotConsumed)(tag);\n    }\n\n    (tag as MonomorphicTagImpl).revision = ++$REVISION;\n\n    scheduleRevalidate();\n  }\n}\n\nexport const DIRTY_TAG = MonomorphicTagImpl.dirtyTag;\nexport const UPDATE_TAG = MonomorphicTagImpl.updateTag;\n\n//////////\n\nexport function createTag(): DirtyableTag {\n  return new MonomorphicTagImpl(DIRYTABLE_TAG_ID);\n}\n\nexport function createUpdatableTag(): UpdatableTag {\n  return new MonomorphicTagImpl(UPDATABLE_TAG_ID);\n}\n\n//////////\n\nexport const CONSTANT_TAG: ConstantTag = new MonomorphicTagImpl(CONSTANT_TAG_ID);\n\nexport function isConstTag(tag: Tag): tag is ConstantTag {\n  return tag === CONSTANT_TAG;\n}\n\n//////////\n\nconst VOLATILE_TAG_ID: IVOLATILE_TAG_ID = 100;\n\nexport class VolatileTag implements Tag {\n  readonly [TYPE] = VOLATILE_TAG_ID;\n  [COMPUTE](): Revision {\n    return VOLATILE;\n  }\n}\n\nexport const VOLATILE_TAG = new VolatileTag();\n\n//////////\n\nconst CURRENT_TAG_ID: ICURRENT_TAG_ID = 101;\n\nexport class CurrentTag implements Tag {\n  readonly [TYPE] = CURRENT_TAG_ID;\n  [COMPUTE](): Revision {\n    return $REVISION;\n  }\n}\n\nexport const CURRENT_TAG = new CurrentTag();\n\n//////////\n\nexport const combine = MonomorphicTagImpl.combine;\n\n// Warm\n\nlet tag1 = createUpdatableTag();\nlet tag2 = createUpdatableTag();\nlet tag3 = createUpdatableTag();\n\nvalueForTag(tag1);\nDIRTY_TAG(tag1);\nvalueForTag(tag1);\nUPDATE_TAG(tag1, combine([tag2, tag3]));\nvalueForTag(tag1);\nDIRTY_TAG(tag2);\nvalueForTag(tag1);\nDIRTY_TAG(tag3);\nvalueForTag(tag1);\nUPDATE_TAG(tag1, tag3);\nvalueForTag(tag1);\nDIRTY_TAG(tag3);\nvalueForTag(tag1);\n","import type { ConstantTag, UpdatableTag } from '@glimmer/interfaces';\n\nimport type { Indexable } from './utils';\n\nimport { debug } from './debug';\nimport { unwrap } from './utils';\nimport { createUpdatableTag, DIRTY_TAG } from './validators';\n\nfunction isObjectLike<T>(u: T): u is Indexable & T {\n  return (typeof u === 'object' && u !== null) || typeof u === 'function';\n}\n\n///////////\n\nexport type TagMeta = Map<PropertyKey, UpdatableTag>;\n\nconst TRACKED_TAGS = new WeakMap<object, TagMeta>();\n\nexport function dirtyTagFor<T extends object>(\n  obj: T,\n  key: keyof T | string | symbol,\n  meta?: TagMeta\n): void {\n  if (import.meta.env.DEV && !isObjectLike(obj)) {\n    throw new Error(`BUG: Can't update a tag for a primitive`);\n  }\n\n  let tags = meta === undefined ? TRACKED_TAGS.get(obj) : meta;\n\n  // No tags have been setup for this object yet, return\n  if (tags === undefined) return;\n\n  // Dirty the tag for the specific property if it exists\n  let propertyTag = tags.get(key);\n\n  if (propertyTag !== undefined) {\n    if (import.meta.env.DEV) {\n      unwrap(debug.assertTagNotConsumed)(propertyTag, obj, key);\n    }\n\n    DIRTY_TAG(propertyTag, true);\n  }\n}\n\nexport function tagMetaFor(obj: object): TagMeta {\n  let tags = TRACKED_TAGS.get(obj);\n\n  if (tags === undefined) {\n    tags = new Map();\n\n    TRACKED_TAGS.set(obj, tags);\n  }\n\n  return tags;\n}\n\nexport function tagFor<T extends object>(\n  obj: T,\n  key: keyof T | string | symbol,\n  meta?: TagMeta\n): UpdatableTag | ConstantTag {\n  let tags = meta === undefined ? tagMetaFor(obj) : meta;\n  let tag = tags.get(key);\n\n  if (tag === undefined) {\n    tag = createUpdatableTag();\n    tags.set(key, tag);\n  }\n\n  return tag;\n}\n","import type { Tag } from '@glimmer/interfaces';\n\nimport type { Revision } from './validators';\n\nimport { debug } from './debug';\nimport { unwrap } from './utils';\nimport { combine, CONSTANT_TAG, isConstTag, validateTag, valueForTag } from './validators';\n\n/**\n * An object that that tracks @tracked properties that were consumed.\n */\nclass Tracker {\n  private tags = new Set<Tag>();\n  private last: Tag | null = null;\n\n  add(tag: Tag) {\n    if (tag === CONSTANT_TAG) return;\n\n    this.tags.add(tag);\n\n    if (import.meta.env.DEV) {\n      unwrap(debug.markTagAsConsumed)(tag);\n    }\n\n    this.last = tag;\n  }\n\n  combine(): Tag {\n    let { tags } = this;\n\n    if (tags.size === 0) {\n      return CONSTANT_TAG;\n    } else if (tags.size === 1) {\n      return this.last as Tag;\n    } else {\n      return combine(Array.from(this.tags));\n    }\n  }\n}\n\n/**\n * Whenever a tracked computed property is entered, the current tracker is\n * saved off and a new tracker is replaced.\n *\n * Any tracked properties consumed are added to the current tracker.\n *\n * When a tracked computed property is exited, the tracker's tags are\n * combined and added to the parent tracker.\n *\n * The consequence is that each tracked computed property has a tag\n * that corresponds to the tracked properties consumed inside of\n * itself, including child tracked computed properties.\n */\nlet CURRENT_TRACKER: Tracker | null = null;\n\nconst OPEN_TRACK_FRAMES: (Tracker | null)[] = [];\n\nexport function beginTrackFrame(debuggingContext?: string | false): void {\n  OPEN_TRACK_FRAMES.push(CURRENT_TRACKER);\n\n  CURRENT_TRACKER = new Tracker();\n\n  if (import.meta.env.DEV) {\n    unwrap(debug.beginTrackingTransaction)(debuggingContext);\n  }\n}\n\nexport function endTrackFrame(): Tag {\n  let current = CURRENT_TRACKER;\n\n  if (import.meta.env.DEV) {\n    if (OPEN_TRACK_FRAMES.length === 0) {\n      throw new Error('attempted to close a tracking frame, but one was not open');\n    }\n\n    unwrap(debug.endTrackingTransaction)();\n  }\n\n  CURRENT_TRACKER = OPEN_TRACK_FRAMES.pop() || null;\n\n  return unwrap(current).combine();\n}\n\nexport function beginUntrackFrame(): void {\n  OPEN_TRACK_FRAMES.push(CURRENT_TRACKER);\n  CURRENT_TRACKER = null;\n}\n\nexport function endUntrackFrame(): void {\n  if (import.meta.env.DEV && OPEN_TRACK_FRAMES.length === 0) {\n    throw new Error('attempted to close a tracking frame, but one was not open');\n  }\n\n  CURRENT_TRACKER = OPEN_TRACK_FRAMES.pop() || null;\n}\n\n// This function is only for handling errors and resetting to a valid state\nexport function resetTracking(): string | void {\n  while (OPEN_TRACK_FRAMES.length > 0) {\n    OPEN_TRACK_FRAMES.pop();\n  }\n\n  CURRENT_TRACKER = null;\n\n  if (import.meta.env.DEV) {\n    return unwrap(debug.resetTrackingTransaction)();\n  }\n}\n\nexport function isTracking(): boolean {\n  return CURRENT_TRACKER !== null;\n}\n\nexport function consumeTag(tag: Tag): void {\n  if (CURRENT_TRACKER !== null) {\n    CURRENT_TRACKER.add(tag);\n  }\n}\n\n//////////\n\nconst CACHE_KEY = Symbol('CACHE_KEY');\n\n// public interface\nexport interface Cache<T = unknown> {\n  [CACHE_KEY]: T;\n}\n\nconst FN = Symbol('FN');\nconst LAST_VALUE = Symbol('LAST_VALUE');\nconst TAG = Symbol('TAG');\nconst SNAPSHOT = Symbol('SNAPSHOT');\nconst DEBUG_LABEL = Symbol('DEBUG_LABEL');\n\ninterface InternalCache<T = unknown> {\n  [FN]: (...args: unknown[]) => T;\n  [LAST_VALUE]: T | undefined;\n  [TAG]: Tag | undefined;\n  [SNAPSHOT]: Revision;\n  [DEBUG_LABEL]?: string | false | undefined;\n}\n\nexport function createCache<T>(fn: () => T, debuggingLabel?: string | false): Cache<T> {\n  if (import.meta.env.DEV && !(typeof fn === 'function')) {\n    throw new Error(\n      `createCache() must be passed a function as its first parameter. Called with: ${String(fn)}`\n    );\n  }\n\n  let cache: InternalCache<T> = {\n    [FN]: fn,\n    [LAST_VALUE]: undefined,\n    [TAG]: undefined,\n    [SNAPSHOT]: -1,\n  };\n\n  if (import.meta.env.DEV) {\n    cache[DEBUG_LABEL] = debuggingLabel;\n  }\n\n  return cache as unknown as Cache<T>;\n}\n\nexport function getValue<T>(cache: Cache<T>): T | undefined {\n  assertCache(cache, 'getValue');\n\n  let fn = cache[FN];\n  let tag = cache[TAG];\n  let snapshot = cache[SNAPSHOT];\n\n  if (tag === undefined || !validateTag(tag, snapshot)) {\n    beginTrackFrame();\n\n    try {\n      cache[LAST_VALUE] = fn();\n    } finally {\n      tag = endTrackFrame();\n      cache[TAG] = tag;\n      cache[SNAPSHOT] = valueForTag(tag);\n      consumeTag(tag);\n    }\n  } else {\n    consumeTag(tag);\n  }\n\n  return cache[LAST_VALUE];\n}\n\nexport function isConst(cache: Cache): boolean {\n  assertCache(cache, 'isConst');\n\n  let tag = cache[TAG];\n\n  assertTag(tag, cache);\n\n  return isConstTag(tag);\n}\n\nfunction assertCache<T>(\n  value: Cache<T> | InternalCache<T>,\n  fnName: string\n): asserts value is InternalCache<T> {\n  if (import.meta.env.DEV && !(typeof value === 'object' && value !== null && FN in value)) {\n    throw new Error(\n      `${fnName}() can only be used on an instance of a cache created with createCache(). Called with: ${String(\n        value\n      )}`\n    );\n  }\n}\n\n// replace this with `expect` when we can\nfunction assertTag(tag: Tag | undefined, cache: InternalCache): asserts tag is Tag {\n  if (import.meta.env.DEV && tag === undefined) {\n    throw new Error(\n      `isConst() can only be used on a cache once getValue() has been called at least once. Called with cache function:\\n\\n${String(\n        cache[FN]\n      )}`\n    );\n  }\n}\n\n//////////\n\n// Legacy tracking APIs\n\n// track() shouldn't be necessary at all in the VM once the autotracking\n// refactors are merged, and we should generally be moving away from it. It may\n// be necessary in Ember for a while longer, but I think we'll be able to drop\n// it in favor of cache sooner rather than later.\nexport function track(block: () => void, debugLabel?: string | false): Tag {\n  beginTrackFrame(debugLabel);\n\n  let tag;\n\n  try {\n    block();\n  } finally {\n    tag = endTrackFrame();\n  }\n\n  return tag;\n}\n\n// untrack() is currently mainly used to handle places that were previously not\n// tracked, and that tracking now would cause backtracking rerender assertions.\n// I think once we move everyone forward onto modern APIs, we'll probably be\n// able to remove it, but I'm not sure yet.\nexport function untrack<T>(callback: () => T): T {\n  beginUntrackFrame();\n\n  try {\n    return callback();\n  } finally {\n    endUntrackFrame();\n  }\n}\n","export type UnionToIntersection<U> = (U extends unknown ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never;\n\nexport type AnyKey = keyof any;\nexport type Indexable = Record<AnyKey, unknown>;\n\nexport function indexable<T extends object>(input: T): T & Indexable {\n  return input as T & Indexable;\n}\n\nexport function getGlobal(): Indexable {\n  if (typeof globalThis !== 'undefined') return indexable(globalThis);\n  if (typeof self !== 'undefined') return indexable(self);\n  if (typeof window !== 'undefined') return indexable(window);\n  if (typeof global !== 'undefined') return indexable(global);\n\n  throw new Error('unable to locate global object');\n}\n\nexport function unwrap<T>(val: T | null | undefined): T {\n  if (val === null || val === undefined) throw new Error(`Expected value to be present`);\n  return val as T;\n}\n","import { dirtyTagFor, tagFor } from './meta';\nimport { consumeTag } from './tracking';\n\nexport type Getter<T, K extends keyof T> = (self: T) => T[K] | undefined;\nexport type Setter<T, K extends keyof T> = (self: T, value: T[K]) => void;\n\nexport function trackedData<T extends object, K extends keyof T>(\n  key: K,\n  initializer?: (this: T) => T[K]\n): { getter: Getter<T, K>; setter: Setter<T, K> } {\n  let values = new WeakMap<T, T[K]>();\n  let hasInitializer = typeof initializer === 'function';\n\n  function getter(self: T) {\n    consumeTag(tagFor(self, key));\n\n    let value;\n\n    // If the field has never been initialized, we should initialize it\n    if (hasInitializer && !values.has(self)) {\n      value = initializer!.call(self);\n      values.set(self, value);\n    } else {\n      value = values.get(self);\n    }\n\n    return value;\n  }\n\n  function setter(self: T, value: T[K]): void {\n    dirtyTagFor(self, key);\n    values.set(self, value);\n  }\n\n  return { getter, setter };\n}\n","import { getGlobal } from './lib/utils';\n\nconst GLIMMER_VALIDATOR_REGISTRATION = Symbol('GLIMMER_VALIDATOR_REGISTRATION');\n\nconst globalObj = getGlobal();\n\nif (globalObj[GLIMMER_VALIDATOR_REGISTRATION] === true) {\n  throw new Error(\n    'The `@glimmer/validator` library has been included twice in this application. It could be different versions of the package, or the same version included twice by mistake. `@glimmer/validator` depends on having a single copy of the package in use at any time in an application, even if they are the same version. You must dedupe your build to remove the duplicate packages in order to prevent this error.'\n  );\n}\n\nglobalObj[GLIMMER_VALIDATOR_REGISTRATION] = true;\n\nexport { debug } from './lib/debug';\nexport { dirtyTagFor, tagFor, type TagMeta, tagMetaFor } from './lib/meta';\nexport { trackedData } from './lib/tracked-data';\nexport {\n  beginTrackFrame,\n  beginUntrackFrame,\n  type Cache,\n  consumeTag,\n  createCache,\n  endTrackFrame,\n  endUntrackFrame,\n  getValue,\n  isConst,\n  isTracking,\n  resetTracking,\n  track,\n  untrack,\n} from './lib/tracking';\nexport {\n  ALLOW_CYCLES,\n  bump,\n  combine,\n  COMPUTE,\n  CONSTANT,\n  CONSTANT_TAG,\n  createTag,\n  createUpdatableTag,\n  CURRENT_TAG,\n  CurrentTag,\n  DIRTY_TAG as dirtyTag,\n  INITIAL,\n  isConstTag,\n  type Revision,\n  UPDATE_TAG as updateTag,\n  validateTag,\n  valueForTag,\n  VOLATILE,\n  VOLATILE_TAG,\n  VolatileTag,\n} from './lib/validators';\nexport type {\n  CombinatorTag,\n  ConstantTag,\n  DirtyableTag,\n  Tag,\n  UpdatableTag,\n} from '@glimmer/interfaces';\n"],"names":["debug","CONSTANT","INITIAL","VOLATILE","NaN","$REVISION","bump","UPDATABLE_TAG_ID","COMPUTE","Symbol","valueForTag","tag","validateTag","snapshot","TYPE","ALLOW_CYCLES","MonomorphicTagImpl","combine","tags","length","CONSTANT_TAG","subtag","revision","lastChecked","lastValue","isUpdating","subtagBufferCache","constructor","type","this","Array","isArray","value","Math","max","subtagValue","updateTag","_tag","_subtag","dirtyTag","disableConsumptionAssertion","scheduleRevalidate","DIRTY_TAG","UPDATE_TAG","createTag","createUpdatableTag","isConstTag","VolatileTag","VOLATILE_TAG","CurrentTag","CURRENT_TAG","tag1","tag2","tag3","TRACKED_TAGS","WeakMap","dirtyTagFor","obj","key","meta","undefined","get","propertyTag","tagMetaFor","Map","set","tagFor","Tracker","Set","last","add","size","from","CURRENT_TRACKER","OPEN_TRACK_FRAMES","beginTrackFrame","debuggingContext","push","endTrackFrame","current","pop","val","Error","unwrap","beginUntrackFrame","endUntrackFrame","resetTracking","isTracking","consumeTag","FN","LAST_VALUE","TAG","SNAPSHOT","createCache","fn","debuggingLabel","getValue","cache","isConst","track","block","debugLabel","untrack","callback","trackedData","initializer","values","hasInitializer","getter","self","has","call","setter","GLIMMER_VALIDATOR_REGISTRATION","globalObj","globalThis","window","global","getGlobal"],"mappings":"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"}